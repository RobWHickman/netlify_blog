---
title: "Untitled"
output: html_document
---
_There are various claims in this post that are not strictly true and indeed, this post does not even actaully model the main points of the Dixon and Coles 1997 paper, but please not the title says part 1 and some of these things will be addressed in later posts_

```{r libraries, warning=FALSE,message=FALSE}
library(tidyverse)
library(magrittr)
library(goalmodel)

set.seed(3459)
```

##Set up

Lets imagine a summer league between 6 English football clubs where each team plays each other twice (once at home and once away)

```{r teams, warning=FALSE,message=FALSE}
teams <- c("Arsenal", #5th in the 1st tier
           "Blackburn_Rovers", #15th in 2nd tier
           "Coventry_City", #8th in 3rd tier
           "Dover_Athletic", #14th 5th tier 
           "Enfield_Town", #10th in 7th tier
           "Frimley_Green") #2nd in 9th tier

```

We've managed to arrange a league that has a nice stratification between teams, so we'd expect each to be comfortably better than the next best (which will make sanity checking our results easier). Lucky for us, the teams are also in alphabetical order of strength so in case you don't have any prior on a team, take the first letter of it's name (A-F).

Each week each team play one game, so we'll have a fixture list that looks like:

```{r create_fixtures, warning=FALSE,message=FALSE,include=FALSE}
#https://stackoverflow.com/questions/54099990/is-there-an-efficient-algorithm-to-create-this-type-of-schedule
create_fixtures <- function(teams) {
  team1 <- as.character(teams[1])
  other_teams <- as.character(teams[!teams %in% team1])
  length <- length(other_teams)
  
  for(week in seq((length(teams)-1)*2)) {
    
    if(week %% 2 == 0) {
      fixtures <- data.frame(home = c(team1, other_teams[1:2]),
                             away = other_teams[length:3],
                             gameweek = week)
    } else {
      fixtures <- data.frame(home = other_teams[length:3],
                             away = c(team1, other_teams[1:2]),
                             gameweek = week)
      
    }
    
    if(week == 1) {
      fixtures_df <- fixtures 
    } else {
      fixtures_df <- rbind(fixtures_df, fixtures)
    }
    
    other_teams <- c(other_teams[length], other_teams[1:length-1])
  }
  
  return(fixtures_df)
}

fixtures <- create_fixtures(teams) %>%
  mutate_if(is.factor, as.character)
```
```{r create_results, warning=FALSE,message=FALSE,include=FALSE}
model <- list()
model$parameters <- list(attack = seq(1, -1 + 2/length(teams), by = -2/(length(teams)-1)) %>%
                           append(-sum(.)) %>%
                           `names<-`(teams), 
                         defense = seq(1, -1 + 2/length(teams), by = -2/(length(teams)-1)) %>%
                           append(-sum(.)) %>%
                           `names<-`(teams), 
                         intercept = 0, 
                         hfa = 0.3)

model$all_teams <- teams

model$model <- "poisson"
model$maxgoal <- 8

results <- predict_expg(model, fixtures$home, fixtures$away, return_df = TRUE) %>%
  mutate(noise1 = rnorm(nrow(.), 0, 0.5),
         noise2 = rnorm(nrow(.), 0, 0.5)) %>%
  mutate(hgoal = round(expg1 + noise1,0 ),
         agoal = round(expg2 + noise2,0),
         home = as.factor(team1),
         away = as.factor(team2)) %>%
  merge(., fixtures, by = c("home", "away")) %>%
  mutate_at(vars(hgoal:agoal), funs(replace(., .<0, 0))) %>%
  select(home, away, hgoal, agoal, gameweek) %>%
  arrange(gameweek, home) %>%
  filter(gameweek <= 8)

results
```

```{r show_fixtures, warning=FALSE,message=FALSE}
head(fixtures, 8)
```

Obviously for this we're going to have to make up our data. For the code used to generate it, see the bottom of the post.

Let's say that we've had 8 weeks of games played so far, and the results have been as follows

```{r print_results, warning=FALSE,message=FALSE}
head(results,8)
```

A better way to show this is to generte a matrix of home (y axis) vs. away (x axis) which gives us:

```{r plot_results, warning=FALSE,message=FALSE}
p1 <- results %>%
  filter(!is.na(hgoal)) %>%
  ggplot(., aes(x = away, y = home, fill = hgoal-agoal)) +
  geom_tile() +
  geom_label(aes(label = paste(hgoal, agoal, sep = "-")), fill = "white") +
  scale_fill_gradient2(low = "darkred", high = "green", midpoint = 0, guide = FALSE) +
  scale_x_discrete(limits = levels(results$home), position = "top") +
  scale_y_discrete(limits = rev(levels(results$away))) +
  theme_minimal()

p1
```

As the colour gradient (from bottom right to top left) shows, the teams we'd expect to do better are. Given the stochastic nature of football though, there are some surprises. E.g. Blackburn only managing to draw at home to Coventry.

A good sense of teams relative abilities can be seen in the league table of results so far (assuming 3 points for a win, and 1 for a draw):

```{r}
melt_results <- function(results_df) {
  results_df %>%
    select(home, away, hgoal, agoal) %>%
    gather(location, team,  -hgoal, -agoal) %>%
    #calculate goals for/against the team
    mutate(g_for = case_when(
      location == "home" ~ hgoal,
      location == "away" ~ agoal
    )) %>%
    mutate(g_ag = case_when(
      location == "home" ~ agoal,
      location == "away" ~ hgoal
    )) 
}

results_to_table <- function(results_df) {
  results_df %>%
    melt_results(.) %>%
  #3 points for a win, 1 for a draw
  mutate(points = case_when(
    g_for > g_ag ~ 3,
    g_ag > g_for ~ 0,
    g_for == g_ag ~ 1
  )) %>%
  #calculate goal difference for each match
  mutate(gd = g_for - g_ag) %>%
  group_by(team) %>%
  #get the final statistics per team
  summarise(games_played = n(),
            gf = sum(g_for),
            ga = sum(g_ag),
            gd = sum(gd),
            points = sum(points)) %>%
  arrange(-points, -gd, -gf)
}

league_table <- results  %>%
  filter(!is.na(hgoal)) %>%
  select(-gameweek) %>%
  results_to_table(.) %>%
  print()

```

Where teams positions are nicely rank ordered (the data for this example is fairly curated so it's not that surprising).

##Predictions

With two rounds to go, there's still 6 fixtures we might want to predict (to try and judge which team will end up where, or just to bet on the remaining games).

This are:

```{r remaining_fixtures, warning=FALSE,message=FALSE}
unplayed_games <- fixtures %>%
  filter(gameweek > 8) %>%
  print()
```

Before we can predict these though we need to understand how scoring in football is distributed.

Using real data from the engsoccerdata package we can get the results of all 32576 English football league games between August 2000 and May 2016. If we melt this to get the goals scored by each team by their location we get a df of 65152 records such as:

```{r real_world_data, warning=FALSE,message=FALSE}
real_data <- engsoccerdata::england %>%
  filter(Season > 1999) %>%
  select(home, away = visitor, hgoal, agoal = vgoal) %>%
  melt_results() %>%
  select(-hgoal, -agoal) %>%
  mutate(data = "real")

head(real_data)
```
Plotting this shows a nice humped distribution with slightly offset peaks for home and away. 

```{r plot_real_goal_distributions, warning=FALSE,message=FALSE}
p2 <- real_data %>%
  ggplot(., aes(x = g_for, fill = location)) +
  geom_density(adjust = 8, alpha = 0.5) +
  scale_fill_manual(values = c("red", "blue")) +
  labs(title = "Goals scored at home and away in English football",
       subtitle = "data from 32.5k matches 2000-2016",
       x = "goals scored",
       y = "density") +
  theme_minimal()

p2

```

That is to say, teams score more on average when playing at home than away.

```{r}
real_data_means <- real_data %>%
    group_by(location) %>%
    summarise(mean_scored = mean(g_for)) %>%
  print()

```

Goals in games are both relatively sparse, and relatively stochastic, football is a low scoring game where goals are evenly distributed throughout the game. In theory any attack made by a team i has a probability of being scored dependent upon the strength of team i's attack (α~i~) which is independent of all the other attacks that team has made.

(there is some reason to doubt this may be the case, but as I said above, for now this is a fine generalisation)

By grouping all teams together into "home" and "away" categories (in a league setting each team will play each other home and away so this should average out) and taking the average number of goals scored per match as the Poisson mean (λ) we can see how well our above graph fits a simulated Poisson process.

```{r simulated_poisson, warning=FALSE,message=FALSE}
simulated_poisson <- real_data_means %>%
  split(f = .$location) %>%
  lapply(., function(x) df = data.frame(dist = rpois(100000, x$mean_scored),
                                        location = x$location)) %>%
  map_df(I) %>%
  mutate(data = "simulated") 

#add these distributions to the plot
p2 + geom_density(data = simulated_poisson, aes(x = dist), fill = NA, adjust = 8, alpha = 0.2) +
  scale_fill_manual(values = c("red", "blue"), guide = FALSE) +
  facet_wrap(~location)

```

It's not perfect. But it's not a bad fit either

```{r, include = FALSE}
model <- goalmodel(results$hgoal, results$agoal, results$home, results$away)$parameters

params <- model %>%
  #select team parameters
  .[grepl("defense|attack", names(.))] %>%
  do.call(cbind, .) %>%
  as.data.frame() %>%
  rownames_to_column("team")

#munge the other parameters into text
#the home field advantage and the intercept
other_params <- model %>%
  .[!grepl("defense|attack", names(.))] %>%
  as.data.frame() %>%
  mutate_if(is.numeric, round, 3) %>%
  #glue into one object
  glue::glue_data("intercept: {.$intercept},\n hfa: {.$hfa}")

#plot team paramters over attack/defense axis
p2 <- ggplot(params, aes(x = attack, y = defense, label = team)) +
  #add a best fit linear regression line
  stat_smooth(method = "lm", se = FALSE) +
  geom_point() +
  ggrepel::geom_text_repel(nudge_y = 0.1) +
  #annotate the other parameters in
  annotate("text", y = min(params$defense), x = max(params$attack)*0.6, label = other_params, hjust = 0) +
  theme_minimal()

p2

```
