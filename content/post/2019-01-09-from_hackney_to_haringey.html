---
title: 
author: Robert Hickman
date: '2020-01-09'
slug: from_hackney_to_haringey
output: pdf_document
categories: []
tags:
  - maps
  - politics
header:
  caption: ''
  image: ''
---



<p>A perculiar way in which the UK’s constituency-based electoral system shapes media coverage is that the names of certain towns/districts have an outsized effect. For instance, in the 2019 UK general election, much was made of <a href="https://www.newstatesman.com/politics/uk/2019/10/which-voters-who-swing-election-2019-workington-man">Workington</a> <a href="https://www.dailymail.co.uk/news/article-7640915/Workington-Man-backing-Boris-Johnson-Survey-finds-Tories-course-win-key-Labour-seat.html">Man</a>* in Cumbria- a seat that had fairly consistently returned Labour MPs in the modern era.</p>
<p>One particular media trend made possible by the variety of names for UK seats is to alliterate between constituencies that are seen as showing a range of geography/opinion/etc. This is best summed up in a great exchange between the absolute boy, and Health Secretary, Matt Hancock, and Kay Burley:</p>
<blockquote class="twitter-tweet" data-lang="en-gb">
<p lang="en" dir="ltr">
On Sky, Matt Hanock says new cancer treatments are being rolled out “from Barnsley to Bassetlaw; from Wigan to Warrington.”<br><br>Kay Burley: “That's not very far, you know.”<br><br>Hancock: “It's also happening in Cornwall.”
</p>
— Peter Walker (<span class="citation">@peterwalker99</span>) <a href="https://twitter.com/peterwalker99/status/1189443331237003265?ref_src=twsrc%5Etfw">30 October 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>Given that I had an afternoon off sick from work, and enjoy wasting my time on such things, I wanted to see what the best constituencies to use for ‘From Xx to Xy’ in British politics is. For this I’m going to use mostly data that is hosted on this website, however, where it isn’t I’ve made it pretty clear in comments where it can be downlaoded.</p>
<p>*for a good take on this, see <a href="https://www.theguardian.com/commentisfree/2019/nov/22/workington-man-voter-caricature-essex-man">here</a></p>
<pre><code>## OGR data source with driver: ESRI Shapefile 
## Source: &quot;C:\Users\rob-getty\Desktop\cleanup desktop\geo_data\boundary\Data\GB&quot;, layer: &quot;westminster_const_region&quot;
## with 632 features
## It has 15 fields
## Integer64 fields read as strings:  NUMBER NUMBER0 POLYGON_ID UNIT_ID</code></pre>
<p>First, and easiest, let’s start with geographic distances between constituencies. For this I use the Ordnance Survey <a href="https://www.ordnancesurvey.co.uk/business-government/products/boundaryline">boundary line</a> dataset which gives shapefile of each constituency in the UK.</p>
<p>After some string regex to match names between datasets, I also removed all constituencies beginning with North/South/East/West (as ‘From East Surry to East Hampshire’ doesn’t really have a ring to it) and also only took seats within England or Wales (more on why later). I also took out constituency names that were longer than two words, again for stylistic reasons.</p>
<p>We’re then left with 350 (out of 650 total) seats which we can plot, filled by the first letter of their name.</p>
<pre class="r"><code>#load tidyverse for munging
library(tidyverse)

#this data can be found at https://www.ordnancesurvey.co.uk/business-government/products/boundaryline
#open as:
# constituency_shapefiles &lt;- readOGR(dsn = &quot;where/you/downloaded&quot;, 
#                                    layer = &quot;westminster_const_region&quot;)
#using rgdal and sf for geospatial work
library(rgdal)
library(sf)

constituency_geography &lt;- constituency_shapefiles %&gt;%
  st_as_sf() %&gt;%
  #some munging to line up datasets
  mutate(name = gsub(&quot; Co Const| Burgh Const| Boro Const&quot;, &quot;&quot;, NAME)) %&gt;%
  mutate(name = case_when(
    grepl(&quot;London and Westminster&quot;, name) ~ &quot;Cities of London and Westminster&quot;,
    grepl(&quot;-.*-&quot;, name) ~ gsub(&quot;(-)([a-z]{1})(.*-)&quot;, perl = TRUE, &quot;\\1\\U\\2\\E\\3&quot;, name),
    grepl(&quot;St\\. &quot;, name) ~ gsub(&quot;St\\. &quot;, &quot;St &quot;, name),
    grepl(&quot; of &quot;, name) ~ gsub(&quot; of &quot;, &quot; Of &quot;, name),
    grepl(&quot;Newcastle upon &quot;, name) ~ gsub(&quot; upon &quot;, &quot; Upon &quot;, name),
    TRUE ~ name
  )) %&gt;%
  #get the first letter
  #removing compass directions
  filter(!grepl(&quot;North |East |South |West &quot;, name) &amp; !grepl(&quot; .* &quot;, name)) %&gt;%
  mutate(first_letter = gsub(&quot;(.)(.*)&quot;, &quot;\\1&quot;,  name)) %&gt;%
  #only going to play with English constituencies here
  filter(grepl(&quot;^E|^W&quot;, CODE)) %&gt;%
  #remove Chorley (speaker&#39;s seat)
  filter(!grepl(&quot;Chorley&quot;, name)) %&gt;%
  #select and rename relevant columns
  select(WSTid = CODE, WSTnm = name, first_letter)

constituency_names &lt;- constituency_geography %&gt;%
  `st_geometry&lt;-`(NULL)

#ggthemes for map theme
library(ggthemes)

#plot remaining constituencies coloured based on first letter
first_letter_plot &lt;- ggplot() +
  geom_sf(data = constituency_geography, aes(fill = first_letter)) +
  scale_fill_discrete(guide = FALSE) +
  theme_map()

plot(first_letter_plot)</code></pre>
<p><img src="/post/2019-01-09-from_hackney_to_haringey_files/figure-html/get_data-1.png" width="672" /></p>
<p>To calculate the distance between any two constituencies, I use the center location of each, calculated using sf::st_centroid(). Grouping by first letter then creating a matrix from each to each is simple enough using sf::st_distance() as follows:</p>
<pre class="r"><code>#get the coordinates of the center of each constituency
geographic_centers &lt;- constituency_geography %&gt;%
  st_centroid() %&gt;%
  split(f = .$first_letter)

#function to find distances between center points
get_distances &lt;- function(letter_list) {
  constituencies &lt;- letter_list$WSTnm
  first_letter &lt;- unique(letter_list$first_letter)
  
  #get distance to/from every center point with same first letter
  distance_matrix &lt;- st_distance(letter_list, letter_list)
  
  distances_df &lt;- distance_matrix %&gt;%
    as.data.frame()
  names(distances_df) &lt;- constituencies
  
  melted_df &lt;- distances_df %&gt;%
    pivot_longer(., names(.), names_to = &quot;to&quot;, values_to = &quot;distance&quot;) %&gt;%
    mutate(from = rep(unique(to), each = length(unique(to)))) %&gt;%
    mutate(first_letter = first_letter)
  
  return(melted_df)
}

#run the function to get the distances between constituencies with same
#first letter
constituency_interdistances &lt;- map_df(geographic_centers, get_distances)</code></pre>
<p>We can then find the longest distance (in metres) between the centre of constituencies, grouped by the first letter of their name using some simple muning:</p>
<pre class="r"><code>#find the longest distances 
longest_distances &lt;- constituency_interdistances %&gt;%
  #arrange by longest first
  arrange(-distance) %&gt;%
  #take the longest per first letter
  filter(!duplicated(first_letter)) %&gt;%
  filter(distance != 0)

#show the ongest 10 interdistances
head(longest_distances %&gt;% arrange(-distance))</code></pre>
<pre><code>## # A tibble: 6 x 4
##   to                 distance from               first_letter
##   &lt;chr&gt;                 &lt;dbl&gt; &lt;chr&gt;              &lt;chr&gt;       
## 1 St Ives             601117. Sunderland Central S           
## 2 Tynemouth           540605. Totnes             T           
## 3 Berwick-Upon-Tweed  528160. Brighton, Kemptown B           
## 4 Worthing West       490544. Wansbeck           W           
## 5 Hove                488181. Hexham             H           
## 6 Carlisle            483127. Canterbury         C</code></pre>
<p>Perhaps not surprisingly, St Ives (in the far South West on England) to Sunderland Central (in the far North East) is the furthest distance (601km). We can see though that there’s a fair few first letter for which we have a pair of constituencies that are pretty far away from each other.</p>
<p>To plot the longest distance between a pair of constituencies that alliterate is simple enough. I also load a shapefile of the outline of England and Wales to pretty up the plots and create lines between each constituency. Where constituencies are too small to be plotted on this scale, I use a red dot.</p>
<pre class="r"><code>#shapefile of England and Wales for plotting
eng_wal &lt;- &quot;C:/Users/rob-getty/Desktop/netlify_blog/static/files/constituency_distances/england_wales_shape.rds&quot; %&gt;%
  readRDS()

#filter the longest journey per letter
selected_constituencies &lt;- constituency_geography %&gt;%
  filter(WSTnm %in% pivot_longer(longest_distances, cols = c(&quot;to&quot;, &quot;from&quot;))$value) %&gt;%
  left_join(., 
            longest_distances %&gt;% 
              mutate(journey = paste(to, from, sep = &quot; to\n&quot;)) %&gt;% 
              select(first_letter, journey),
            by = &quot;first_letter&quot;)

#get the center coordinates of constituencies
#to help plotting small constituencies
plotting_points &lt;- do.call(rbind, geographic_centers) %&gt;%
  filter(WSTnm %in% selected_constituencies$WSTnm) %&gt;%
  left_join(., 
            longest_distances %&gt;% 
              mutate(journey = paste(to, from, sep = &quot; to\n&quot;)) %&gt;% 
              select(first_letter, journey),
            by = &quot;first_letter&quot;) %&gt;%
  st_transform(crs = st_crs(eng_wal))

#calculate straight lines between two constituencies
plotting_lines &lt;- plotting_points %&gt;%
  split(f = .$journey) %&gt;%
  map_df(., function(data) {
    coords &lt;- rbind(st_coordinates(data[1,]), st_coordinates(data[2,]))
    line &lt;- st_linestring(coords)
    df &lt;- st_sfc(line, crs = st_crs(&quot;+init=epsg:27700&quot;)) %&gt;%
      as.data.frame() %&gt;%
      mutate(journey = unique(data$journey))
  }) %&gt;%
  st_as_sf(crs = st_crs(plotting_points))

#plot the longest journey between constituencies with the same first letter
alliterative_journeys_plot &lt;-  ggplot() +
  geom_sf(data = eng_wal, fill = &quot;white&quot;) +
  geom_sf(data = plotting_lines, colour = &quot;darkblue&quot;) +
  #some constituencies are too small to plot as shapefiles
  geom_sf(data = plotting_points, colour = &quot;red&quot;, size = 2.5) +
  geom_sf(data = selected_constituencies, fill = &quot;red&quot;) +
  theme_map() +
  #split by first letter
  facet_wrap(~journey)

plot(alliterative_journeys_plot)</code></pre>
<p><img src="/post/2019-01-09-from_hackney_to_haringey_files/figure-html/plot_interdistances-1.png" width="1344" /></p>
<pre class="r"><code>#load data on voting in the 2019 general election
#2016 brexit vote based on Hanretty work also included
votes_data &lt;- readRDS(&quot;../../static/files/constituency_distances/ge2019_results.rds&quot;) %&gt;%
  select(WSTnm = constituency_name, winner = first_party, votes = electorate, 
         con, lab, ld, brexit, green, other, brexit_hanretty) %&gt;%
  #convert to vote fractions
  modify_at(c(&quot;con&quot;, &quot;lab&quot;, &quot;ld&quot;, &quot;brexit&quot;, &quot;green&quot;, &quot;other&quot;), function(x) x/.$votes) %&gt;%
  #take only relevant constituencies
  filter(WSTnm %in% constituency_geography$WSTnm)

head(votes_data)</code></pre>
<pre><code>##                 WSTnm winner votes       con       lab         ld
## 1            Aberavon    Lab 50750 0.1284335 0.3351330 0.02112315
## 2           Aberconwy    Con 44699 0.3285756 0.2830712 0.04073917
## 3           Aldershot    Con 72617 0.3853092 0.1553631 0.09529449
## 4 Aldridge-Brownhills    Con 60138 0.4631015 0.1332602 0.03942599
## 5        Amber Valley    Con 69976 0.4157997 0.1744884 0.04105693
## 6               Arfon     PC 42215 0.1048916 0.2452446 0.00000000
##       brexit       green      other brexit_hanretty
## 1 0.06124138 0.008866995 0.01440394       0.6012448
## 2 0.00000000 0.000000000 0.00000000       0.5219712
## 3 0.00000000 0.024099040 0.00000000       0.5789777
## 4 0.00000000 0.012820513 0.00558715       0.6779635
## 5 0.00000000 0.019835372 0.00000000       0.6529912
## 6 0.02745470 0.000000000 0.00000000       0.3584544</code></pre>
<pre class="r"><code>#find the largest gap in 2016 brexit vote between constituencies
#which same first letter
brexit_differences &lt;- votes_data %&gt;%
  left_join(., constituency_names, by = &quot;WSTnm&quot;) %&gt;%
  split(f = .$first_letter) %&gt;%
  map_df(., function(data) {
    difference &lt;- outer(data$brexit_hanretty, data$brexit_hanretty, &quot;-&quot;) %&gt;%
      as.data.frame() %&gt;%
      mutate(from = data$WSTnm)
    names(difference)[1:(ncol(difference) - 1)] &lt;- data$WSTnm
    df &lt;- difference %&gt;%
      pivot_longer(cols = -starts_with(&quot;from&quot;),
                   names_to = &quot;to&quot;,
                   values_to = &quot;brexit_2016_difference&quot;) %&gt;%
      mutate(first_letter = unique(data$first_letter))
  }) %&gt;%
  #arrange by greatest difference
  arrange(-brexit_2016_difference)

head(brexit_differences, n = 10)</code></pre>
<pre><code>## # A tibble: 10 x 4
##    from                 to           brexit_2016_difference first_letter
##    &lt;chr&gt;                &lt;chr&gt;                         &lt;dbl&gt; &lt;chr&gt;       
##  1 Stoke-On-Trent North Streatham                     0.516 S           
##  2 Stoke-On-Trent South Streatham                     0.506 S           
##  3 Barnsley East        Bristol West                  0.503 B           
##  4 Bolsover             Bristol West                  0.497 B           
##  5 Barnsley East        Battersea                     0.489 B           
##  6 Bolsover             Battersea                     0.483 B           
##  7 Scunthorpe           Streatham                     0.481 S           
##  8 Bassetlaw            Bristol West                  0.476 B           
##  9 Barnsley Central     Bristol West                  0.475 B           
## 10 Blackpool South      Bristol West                  0.471 B</code></pre>
<pre class="r"><code>#plot the distances between constituencies of same first letter with
#greatest difference in 2016 brexit vote
brexit_distance_plot &lt;- brexit_differences %&gt;%
  filter(!duplicated(first_letter)) %&gt;%
  left_join(constituency_interdistances, by = c(&quot;to&quot;, &quot;from&quot;)) %&gt;%
  mutate(journey = paste(to, from, sep = &quot;-&quot;)) %&gt;%
  select(journey, first_letter.x, brexit_2016_difference, distance) %&gt;%
  ggplot(aes(x = brexit_2016_difference, y = distance, label = journey)) +
  geom_text() +
  theme_minimal()

brexit_distance_plot</code></pre>
<p><img src="/post/2019-01-09-from_hackney_to_haringey_files/figure-html/plot_brexit_differences-1.png" width="672" /></p>
<pre class="r"><code>#load the raw values from the census data for each output area
census_oa_data &lt;- census_oa_data %&gt;%
  #select only integer data (counts not percentages)
  select(OAid = GeographyCode, which(sapply(.,class)==&quot;integer&quot;))

#load the lookup between output areas to westminster constituency
oa_to_westminster &lt;- readRDS(&quot;../../static/files/constituency_distances/oa_to_westminster.rds&quot;) %&gt;%
  select(OAid = OA11CD, WSTid = PCON11CD, WSTnm = PCON11NM, WSTperc = OA11PERCENT) %&gt;%
  #select only english constituencies
  filter(WSTid %in% constituency_names$WSTid)


#gather the census data by westminster constituency
census_data_westminster &lt;- left_join(census_oa_data, oa_to_westminster, by = &quot;OAid&quot;) %&gt;%
  filter(!is.na(WSTid)) %&gt;%
  #for output areas split between constituencies guesstimate the correct amounts
  mutate_if(is.integer, funs(round(. * (WSTperc/100)))) %&gt;%
  select(-WSTnm, -WSTperc, -OAid) %&gt;%
  #sum the counts per constituency for each statistic
  group_by(WSTid) %&gt;%
  summarise_if(is.numeric, sum, na.rm = TRUE) %&gt;%
  #turn into percentages from the total number of people (KS101)
  modify_if(is.numeric, function(x) x/.$KS101EW0001) %&gt;%
  #arrange by name
  arrange(WSTid)

#only preview the first few columns as we have ~400 total
head(census_data_westminster[1:8])</code></pre>
<pre><code>## # A tibble: 6 x 8
##   WSTid KS101EW0001 KS101EW0002 KS101EW0003 KS101EW0004 KS101EW0005
##   &lt;chr&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;       &lt;dbl&gt;
## 1 E140~           1       0.499       0.501       0.980     0.0195 
## 2 E140~           1       0.489       0.511       0.994     0.00574
## 3 E140~           1       0.492       0.508       0.991     0.00885
## 4 E140~           1       0.492       0.508       0.989     0.0111 
## 5 E140~           1       0.485       0.515       0.992     0.00791
## 6 E140~           1       0.492       0.508       0.992     0.00766
## # ... with 2 more variables: KS101EW0006 &lt;dbl&gt;, KS102EW0001 &lt;dbl&gt;</code></pre>
<pre class="r"><code>#load the terminology for each census statistic
census_index &lt;- readRDS(&quot;../../static/files/constituency_distances/census_names.rds&quot;)

head(select(census_index, Code, Meaning))</code></pre>
<pre><code>##          Code
## 2 KS101EW0001
## 3 KS101EW0002
## 4 KS101EW0003
## 5 KS101EW0004
## 6 KS101EW0005
## 7 KS101EW0006
##                                                                           Meaning
## 2                                                             All categories: Sex
## 3                                                                           Males
## 4                                                                         Females
## 5                                                            Lives in a household
## 6                                               Lives in a communal establishment
## 7 Schoolchild or full-time student aged 4 and over at their non term-time address</code></pre>
<pre class="r"><code>census_data_westminster &lt;- census_data_westminster %&gt;%
  #a few codes missing from the index
  .[-which(!names(.)[2:ncol(.)] %in% census_index$Code)] %&gt;%
  .[c(1, which(!apply(.[2:ncol(.)],2,function(x) var(x,na.rm=T)==0))+1)]</code></pre>
<pre class="r"><code>get_correlations_tidy &lt;- function(demography, dependent_var) {
  #first split up the demography data by variable so we can independently
  #correlate each against the dependent variable
  split_demog &lt;- demography %&gt;%
    column_to_rownames(&quot;WSTid&quot;) %&gt;%
    t() %&gt;%
    split(f = rownames(.))
  
  #run the values for each variables against the dependent_var
  correlations &lt;- map_df(split_demog, function(x) {
    regression &lt;- lm(dependent_var ~ x)
    adj_r_squared &lt;- summary(regression)$adj.r.squared
    f_stat &lt;- summary(regression)$fstatistic[1]
    df &lt;- summary(regression) %&gt;%
      #tidy it to bind to df
      broom::tidy() %&gt;%
      filter(term != &quot;(Intercept)&quot;) %&gt;%
      mutate(adj_r = adj_r_squared, f_stat)
  })
  
  tidy_df &lt;- correlations %&gt;%
    #left join in the meaning for each variable
    mutate(Code = names(demography[2:ncol(demography)])) %&gt;%
    left_join(., select(census_index, Code, Meaning), by = &quot;Code&quot;) %&gt;%
    arrange(-abs(statistic)) %&gt;%
    select(-term)
  
  #return this data frame
  return(tidy_df)
}</code></pre>
<pre class="r"><code>lr_margin &lt;- votes_data %&gt;%
  left_join(constituency_names, by = &quot;WSTnm&quot;) %&gt;%
  #must line up in order with census data
  arrange(WSTid) %&gt;%
  #assuming a simple left vs right decision for voters
  mutate(left = lab + ld + green,
         right = con + brexit) %&gt;%
  #take the difference between left and right sum votes for each constituency
  mutate(margin = left - right) %&gt;%
  .$margin

#run in the above function
lr_correlations &lt;- get_correlations_tidy(census_data_westminster, lr_margin)

head(select(lr_correlations, Code, Meaning, statistic, p.value))</code></pre>
<pre><code>## # A tibble: 6 x 4
##   Code      Meaning                                      statistic  p.value
##   &lt;chr&gt;     &lt;fct&gt;                                            &lt;dbl&gt;    &lt;dbl&gt;
## 1 KS104EW0~ Not living in a couple: Single (never marri~      26.0 1.86e-83
## 2 KS404EW0~ All categories: Car or van availability          -23.4 1.67e-73
## 3 KS104EW0~ Living in a couple: Married or in a registe~     -23.2 1.44e-72
## 4 KS105EW0~ One family only: Married or same-sex civil ~     -22.2 1.78e-68
## 5 KS103EW0~ Married                                          -22.0 4.93e-68
## 6 KS404EW0~ 2 cars or vans in household                      -22.0 5.77e-68</code></pre>
<pre class="r"><code>lr_correlations &lt;- lr_correlations %&gt;%
  #lots of these stats are self-correlated
  #e.g. 3 cars in household vs 4+ cars in household
  mutate(stat_category = gsub(&quot;(.{5})(.*)&quot;, &quot;\\1&quot;, Code)) %&gt;%
  group_by(stat_category) %&gt;%
  #take only the strongest correlated variable from each &#39;category&#39;
  mutate(duplicate_n = 1:n()) %&gt;%
  ungroup() %&gt;%
  filter(duplicate_n == 1 &amp; abs(statistic) &gt; 10 &amp; !duplicated(Meaning))

right_variables &lt;- lr_correlations %&gt;%
  mutate(census_info = paste(Code, Meaning)) %&gt;%
  filter(statistic &lt; 0) %&gt;%
  .$census_info

left_variables &lt;- lr_correlations %&gt;%
  mutate(census_info = paste(Code, Meaning)) %&gt;%
  filter(statistic &gt; 0) %&gt;%
  .$census_info

right_variables</code></pre>
<pre><code>##  [1] &quot;KS404EW0007 All categories: Car or van availability&quot;                                   
##  [2] &quot;KS105EW0005 One family only: Married or same-sex civil partnership couple: No children&quot;
##  [3] &quot;KS103EW0003 Married&quot;                                                                   
##  [4] &quot;KS501EW0004 Highest level of qualification: Level 2 qualifications&quot;                    
##  [5] &quot;KS102EW0013 Age 60 to 64&quot;                                                              
##  [6] &quot;KS401EW0008 Whole house or bungalow: Detached&quot;                                         
##  [7] &quot;KS603EW0002 Economically active: Employee: Part-time&quot;                                  
##  [8] &quot;KS609EW0006 5. Skilled trades occupations&quot;                                             
##  [9] &quot;KS605EW0007 F Construction&quot;                                                            
## [10] &quot;KS402EW0002 Owned: Owned outright&quot;                                                     
## [11] &quot;KS301EW0014 Provides 1 to 19 hours unpaid care a week&quot;                                 
## [12] &quot;KS209EW0002 Christian&quot;</code></pre>
<pre class="r"><code>left_variables</code></pre>
<pre><code>##  [1] &quot;KS104EW0004 Not living in a couple: Single (never married or never registered a same-sex civil partnership)&quot;
##  [2] &quot;KS403EW0004 Occupancy rating (rooms) of -1 or less&quot;                                                         
##  [3] &quot;KS201EW0007 Mixed/multiple ethnic group: White and Black African&quot;                                           
##  [4] &quot;KS604EW0008 Males: Part-time: 16 to 30 hours worked&quot;                                                        
##  [5] &quot;KS612EW0012 L14.1 Never worked&quot;                                                                             
##  [6] &quot;KS613EW0014 Not classified&quot;                                                                                 
##  [7] &quot;KS202EW0039 Other identities only&quot;                                                                          
##  [8] &quot;KS206EW0005 No people in household have English as a main language (English or Welsh in Wales)&quot;             
##  [9] &quot;KS204EW0010 Other countries&quot;                                                                                
## [10] &quot;KS205EW0008 Middle East and Asia&quot;                                                                           
## [11] &quot;KS107EW0012 Female lone parent: Not in employment&quot;                                                          
## [12] &quot;KS106EW0002 No adults in employment in household: With dependent children&quot;</code></pre>
<pre class="r"><code>brexit_vote &lt;- votes_data %&gt;%
  left_join(constituency_names, by = &quot;WSTnm&quot;) %&gt;%
  #must line up in order with census data
  arrange(WSTid) %&gt;%
  .$brexit_hanretty

brexit_correlations &lt;- get_correlations_tidy(census_data_westminster, brexit_vote) %&gt;%
  #lots of these stats are self-correlated
  #e.g. 3 cars in household vs 4+ cars in household
  mutate(stat_category = gsub(&quot;(.{5})(.*)&quot;, &quot;\\1&quot;, Code)) %&gt;%
  group_by(stat_category) %&gt;%
  #take only the strongest correlated variable from each &#39;category&#39;
  mutate(duplicate_n = 1:n()) %&gt;%
  ungroup() %&gt;%
  filter(duplicate_n == 1 &amp; abs(statistic) &gt; 10 &amp; !duplicated(Meaning))</code></pre>
<pre><code>## Warning: Column `Code` joining character vector and factor, coercing into
## character vector</code></pre>
<pre class="r"><code>head(brexit_correlations) </code></pre>
<pre><code>## # A tibble: 6 x 10
##   estimate std.error statistic   p.value adj_r f_stat Code  Meaning
##      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;fct&gt;  
## 1     5.27     0.171      30.8 2.32e-101 0.731   948. KS50~ Highes~
## 2     6.08     0.239      25.4 3.36e- 81 0.648   645. KS61~ 6. Sem~
## 3    -3.14     0.126     -25.0 1.52e- 79 0.641   623. KS60~ 2. Pro~
## 4     9.04     0.380      23.8 5.00e- 75 0.618   567. KS60~ 8. Pro~
## 5     7.65     0.329      23.3 6.44e- 73 0.608   542. KS61~ 5. Low~
## 6    -2.20     0.103     -21.3 5.47e- 65 0.564   453. KS30~ Very g~
## # ... with 2 more variables: stat_category &lt;chr&gt;, duplicate_n &lt;int&gt;</code></pre>
<pre class="r"><code>lr_correlations$Meaning[which(lr_correlations$Code %in% brexit_correlations$Code)]</code></pre>
<pre><code>## [1] Not living in a couple: Single (never married or never registered a same-sex civil partnership)
## [2] Economically active: Employee: Part-time                                                       
## [3] Occupancy rating (rooms) of -1 or less                                                         
## 793 Levels: 0 or multiple adults in household ... Widowed or surviving partner from a same-sex civil partnership</code></pre>
<pre class="r"><code>pca_census &lt;- census_data_westminster %&gt;%
  #take only the variable that strongly correlate with 2019/brexit vote
  select(unique(c(lr_correlations$Code, brexit_correlations$Code))) %&gt;%
  #scale before pca
  scale()

#run the pca
#take first 3 components
demographic_pca &lt;- prcomp(pca_census)$x %&gt;%
  as.data.frame() %&gt;%
  .[1:3] %&gt;%
  #add back in ID column
  mutate(WSTid = census_data_westminster$WSTid) %&gt;%
  #join in additional dta for plotting
  left_join(., constituency_names, by = &quot;WSTid&quot;) %&gt;%
  left_join(., select(votes_data, WSTnm, winner), by = &quot;WSTnm&quot;)

#plot
demographic_pca_plot &lt;- demographic_pca %&gt;%
  ggplot(aes(x = PC1, y = PC2, label = gsub(&quot;a|e|i|o|u&quot;, &quot;&quot;, WSTnm), colour = winner)) +
  geom_point() +
  geom_text() +
  scale_colour_manual(values = c(&quot;mediumblue&quot;, &quot;green&quot;, &quot;red&quot;, &quot;goldenrod&quot;, &quot;darkgreen&quot;)) +
  labs(x = &quot;PC1 - Urban, Young &amp; Diverse -&gt;&quot;,
       y = &quot;PC2 - Economically &#39;Left Behind&#39; -&gt;&quot;) +
  facet_wrap(~first_letter)

demographic_pca_plot</code></pre>
<p><img src="/post/2019-01-09-from_hackney_to_haringey_files/figure-html/do_census_pca-1.png" width="672" /></p>
<pre class="r"><code>distances &lt;- demographic_pca %&gt;%
  split(f = .$first_letter) %&gt;%
  map_df(., function(data) {
    distances &lt;- (outer(data$PC1, data$PC1, &quot;-&quot;)^2 + outer(data$PC2, data$PC2, &quot;-&quot;)^2) %&gt;%
    sqrt() %&gt;%
    as.data.frame() %&gt;%
    mutate(from = data$WSTnm)
    names(distances)[1:(ncol(distances)-1)] &lt;- as.character(data$WSTnm)
    df &lt;- pivot_longer(distances, -starts_with(&quot;from&quot;),
                       names_to = &quot;to&quot;,
                       values_to = &quot;pca_distance&quot;) %&gt;%
      mutate(pca_distance = abs(pca_distance))
    return(df)
  }) %&gt;%
  filter(!duplicated(pca_distance) &amp; pca_distance != 0)</code></pre>
<pre class="r"><code>library(ggrepel)
all_distances &lt;- distances %&gt;%
  left_join(brexit_differences, by = c(&quot;from&quot;, &quot;to&quot;)) %&gt;%
  mutate(brexit_2016_difference = abs(brexit_2016_difference)) %&gt;%
  select(-first_letter) %&gt;%
  left_join(constituency_interdistances, by = c(&quot;from&quot;, &quot;to&quot;)) %&gt;%
  mutate(label = case_when(
    distance &gt; 400000 &amp; pca_distance &gt; 15 &amp; brexit_2016_difference &gt; 0.3 ~ paste(to, from, sep = &quot;-&quot;)
  )) %&gt;%
  mutate(distance = distance / 1000)

p &lt;- ggplot(all_distances, aes(x = distance, y = pca_distance, size = brexit_2016_difference)) +
  geom_point(alpha = 0.2) +
  geom_point(data = filter(all_distances, !is.na(label))) +
  geom_text_repel(aes(label = label)) +
  scale_size_continuous(name = &quot;diff Brexit\n 2016 vote&quot;, range = c(0.5, 5)) +
  labs(x = &quot;Geographic Distances between Constituences (/km&quot;,
       y = &quot;&#39;Distance&#39; between Constituencies Demograph (2011 Census)&quot;) +
  theme_minimal()

plot(p)</code></pre>
<pre><code>## Warning: Removed 4608 rows containing missing values (geom_text_repel).</code></pre>
<p><img src="/post/2019-01-09-from_hackney_to_haringey_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
