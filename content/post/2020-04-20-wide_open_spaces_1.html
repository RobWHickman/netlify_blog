---
title: Papers Please! 'Wide Open Spaces A statistical technique for measuring space creation in professional soccer' pt 1
author: Robert Hickman
date: '2020-04-20'
slug: fall_back_in_to_space
output: pdf_document
categories: []
tags:
  - research
  - football
  - modelling
header:
  caption: ''
  image: ''
---



<p><em>written during lockdown so while I think it adds some value (and is useful to organise my thoughts on the paper for my own work on football) there are probably mistakes. E.g. the C++ code is still pretty inefficient and could well be improved and I’ve surely confused some maths concepts. To be honest, the post is just an excuse to practice writing LaTeX maths and some C++. Let me know my errors and I’ll correct</em></p>
<p><a href="https://www.youtube.com/watch?v=f9X1C7pTu-M">Beach House - Space Song</a></p>
<div id="intropre-amble" class="section level1">
<h1>Intro/Pre-amble</h1>
<p>When analysing football (whether as a scout watching games, or an analyst using data), we want the greatest sample size possible. During a single match a player might well make fewer than 100 ‘events’ (passes, tackles, interceptions, shots, …) and still play well enough that he might be a worthwhile purchase. As we increase the number of matches we watch that player play, a more accurate ‘smoothed’ representation of their game should emerge. However, time is very obviously a limited resource. If we assume a very hardworking scout can watch 6 football matches a day, it will probably take them a week to cover all of the games of one team in a season, and over 3 months to cover an entire season of a league.</p>
<p>An obvious way to get around some of these limitations is augment scouting using data. If a player is obviously an <a href="https://en.wikipedia.org/wiki/Filippo_Inzaghi">Filipo Inzaghi</a> style poacher, its feasible we might watch 5-6 games of his to get a feel of his ability, then check some basic stats such a shots, xG, … etc. per game over his last few seasons to see how representative our sample was and flesh out our scouting.</p>
<p>When we build these models (even just counting shot numbers) we are in essence ‘teaching’ machines to do the scouting for us. We provide them with a model of how the game works and ask them to ‘watch’ a huge number of matches very quickly. The obvious pitfall of this is that ‘computers don’t play football’, and they don’t, so the output of our model is going to be proportional to the understanding of the game the computer has. For example, a computer who only counts shot numbers has a poorer understanding of football than a machine who weights these by xG per shot. Just as humans understand creating better shooting chances is important, the second computer has come to grasp that.</p>
<p>Some of these computational models seem to work, even with simple inputs. The xG a striker produces per season does for instance align quite well with how good the human eye test thinks a striker is. However, many are <em>quite bad</em>, especially as you move back through play away from shots on goal. To fix this, we need machines who understand the game better, and in the same ways humans do.</p>
<p>This is really the idea behind a lot of modern football analytics research, but I think especially behind <a href="http://www.sloansportsconference.com/wp-content/uploads/2018/03/1003.pdf">Wide Open Spaces</a>, a 2019 Sloan conference paper by Javier Fernandez and Luke Bornn. I’m not going to review the whole paper, but the key takeaway is that for every ‘event’ that a player takes, there are actually many more uncaptured events where players are continually creating and destroying space. Combining these gives us a better approximation of what the human brain does when evaluating players. If this seems confusing, a simpler way to think about this is consider <a href="https://www.youtube.com/watch?v=sZsJo7ZKdjQ">this Tifo football video on Thomas Mueller</a>.</p>
<p><em>It is probably more valuable to be able to create and exploit space, than it is to be able to technically execute a pass. The reverse is also clearly true for defenders; consider Maldini’s famous quote: “If I have to make a tackle then I have already made a mistake.”</em></p>
<p>The paper, while very clearly written, does not explain it’s maths as accessibly as I might like, so I thought a post going through exactly what the paper is doing might be of value. All the hard work for this post is reall done by <a href="https://twitter.com/AnEnglishGoat">Will Thomson’s</a> whose implementation of the algorithm in python <a href="https://colab.research.google.com/drive/1V75UgfJEfCWgbfxnG4OuB1WpvqahUJPU">here</a> forms the basis (and only has minor tweaks in my final code).</p>
<p>As always, let’s first load some libraries we’ll need:</p>
<pre class="r"><code>set.seed(3459)
#libraries
library(tidyverse)
library(ggsoccer)
library(mvtnorm) #might be possible with MASS
library(zoo)</code></pre>
</div>
<div id="the-theory" class="section level1">
<h1>The Theory</h1>
<p>Imagine two teams, I and J. Each of these has 11 players (hopefully) on the pitch at any time chasing after one ball. We want to know which team controls which parts of the pitch for each point in the match. As ‘control’ in a football match really only refers to “will player on my team get to a potential pass there first”, we are just looking at where players i,j,k… are going to be at time t + n seconds.</p>
<p>The easiest way to start to approximate this is to imagine a set of players who never change direction, they only speed up or slow down (and possibly reverse). E.g. a full back running up and down the wings like a rook in a chess game. Their location at t + 1 will be their current location plus the expected value of their velocity.</p>
<pre class="r"><code>#make up some movement data
full_back_pos &lt;- data.frame(x = 40, y = 70)
full_back_movement &lt;- data.frame(
  pos = 40,
  x = c(10, 100),
  y_pos = 70)

next_x &lt;- rnorm(10000, 60, 5)
next_x &lt;- next_x - (next_x %% 5)
full_back_next_pos &lt;- data.frame(table(next_x)) %&gt;%
  mutate(y = 70, 
         next_x = as.numeric(as.character(next_x)),
         Freq = Freq / sum(Freq))
  

#plot fake movement data
p &lt;- ggplot() +
  annotate_pitch(dimensions = pitch_statsbomb) +
  geom_tile(data = full_back_next_pos, 
            aes(x = next_x, y = y, fill = Freq),
            alpha = 0.7, height = 10) +
  scale_fill_viridis_c(name = &quot;confidence&quot;) +
  geom_segment(data = full_back_movement,
               aes(x = pos, xend = x, y = y_pos, yend = y_pos), size = 2) +
  geom_point(data = full_back_pos, 
             aes(x = x , y = y), 
             shape = 21, colour = &quot;black&quot;, fill = &quot;red&quot;, size = 5) +
  theme_pitch()

p</code></pre>
<p><img src="/post/2020-04-20-wide_open_spaces_1_files/figure-html/player_example-1.png" width="672" /></p>
<p>As we’re not fully confident in our assessment of how fast this full back is, we aren’t 100% sure where his next position will be (at time t + n seconds), but given how quick we <em>expect</em> him to be, we can produce produce an expected distribution of his next x coordinate (here binned into boxes of 5m worth). This estimate will vary according to two parameters, the mean speed (μ) and the standard deviation of that speed (σ). If we make 10000 such estimates (assuming no bias and forgetting our previous estimate etc.) these will form the normal distribution probability density function</p>
<pre class="r"><code>#plot histogram of fake movement data
p2 &lt;- ggplot(full_back_next_pos, aes(x = next_x, y = Freq)) +
  geom_bar(stat = &quot;identity&quot;) +
  ylab(&quot;confidence&quot;) +
  xlab(&quot;next x coordinate&quot;) +
  theme_minimal()

p2</code></pre>
<p><img src="/post/2020-04-20-wide_open_spaces_1_files/figure-html/player_example_hist-1.png" width="672" /></p>
<p>(here I’ve plotted the x axis as the next x coordinate which is just our estimate of the x speed + the original x coordinate [40]).</p>
<p>But this is obviously an oversimplification because players can travel in a myriad different directions across the pitch- we need our normal distribution confidence interval to generalise across more than 1 dimension.</p>
<pre class="r"><code>#fake data in 2 dimensions now
next_x &lt;- rnorm(10000, 60, 5)
next_x &lt;- next_x - (next_x %% 5)
next_y &lt;- rnorm(10000, 65, 3)
next_y &lt;- next_y - (next_y %% 5)

full_back_next_pos &lt;- data.frame(next_x, next_y) %&gt;%
  group_by(next_x, next_y) %&gt;%
  summarise(Freq = n())

full_back_movement &lt;- data.frame(x = 40, y = 70, next_x = 60, next_y = 60)

#plot
p3 &lt;- ggplot() +
  annotate_pitch(dimensions = pitch_statsbomb) +
  geom_tile(data = full_back_next_pos, 
            aes(x = next_x, y = next_y, fill = Freq), 
            alpha = 0.7, height = 10) +
  scale_fill_viridis_c(name = &quot;confidence&quot;) +
  geom_segment(data = full_back_movement, 
               aes(x = x, xend = next_x, y = y, yend = next_y),
               size = 2, arrow = arrow(length = unit(0.03, &quot;npc&quot;))) +
  geom_point(data = full_back_pos,
             aes(x = x , y = y),
             shape = 21, colour = &quot;black&quot;, fill = &quot;red&quot;, size = 5) +
  theme_pitch()

p3</code></pre>
<p><img src="/post/2020-04-20-wide_open_spaces_1_files/figure-html/player_example_2d-1.png" width="672" />
So now we have a realistic of guess, based upon the players velocity vector, of where they will be in n seconds time. If we do the same for every player of the pitch, we get a (roughly) 22 layer raster detailing how likely any single player is to be able to be in location x, y at time t + n. If a football magically appeared at point x,y, we now know which player(s) are likely to be able to reach it. Therefore, we know we parts of the pitch team I or J ‘controls’- where their teammates can pass to and expect them to receive the ball.</p>
<p>This really is the fundamental idea of the pitch control metric presented in <a href="http://www.sloansportsconference.com/wp-content/uploads/2018/03/1003.pdf">Wide Open Spaces</a>- we can use the expected 2d position of each player in the next n seconds, to work out which team would win the ball if it were dropped on a specific coordinate. This is what we mean by ‘pitch control’.</p>
</div>
<div id="the-math" class="section level1">
<h1>The Math</h1>
<p>Now we have an idea of what we want to do, ‘we’ need to formalise it. Luckily the paper already does it for us and all we need to do is follow the derivation. First, need to define two terms. We’ll call the space of possible locations (120 x 80m for me) P(itch) and the range of times T(ime)</p>
<p>For every single point p at time t pitch control (PC) is defined by equation 2</p>
<p><span class="math display">\[PC_{(p,t)} = \sigma \sum_{i} I_{(p,t)} - \sum_{j} I_{(p,t)}\]</span></p>
<p>where you sum across i (all the players on team I) and j (all the players on team J). This is then multiplied by a logistic function (σ). Due to the logistic function, the output of this (PC) will have a value from 0 to 1 where &lt;0.5 is control by team J and &gt;0.5 is control by team I. E.g. if you drop a ball at place p at time t, if PC(p,t) is greater than 0.5, team I is likelier to get the ball, and viceversa for &lt;0.5.</p>
<p>We’ll rewrite this with sigma replace with numbers as:</p>
<p><span class="math display">\[PC(p,t) = \frac{1}{1 + (\sum_{i} I(p,t) - \sum_{j} I(p,t))}\]</span></p>
<p>From here it should be obvious we need to calculate I(p,t) for each player. We do this in equation 1</p>
<p><span class="math display">\[I_{i}(p,t) = \frac{f_{i}(p,t)}{f_{i}(p_{i}(t), t)} \]</span></p>
<p>The numerator here is the probability density function of the player influence. How much influence does a single player have over any single part of the pitch surface (p) at a time (t). This is normalised by the denominator which does the same thing only for the players current location at time t (p_i(t)).</p>
<p>Ok so so far so good. Equations 4 and 5 in the paper we’ll come back to later but they define the value of having the ball at these locations. Don’t worry about that for now. We won’t really go into that in this post.</p>
<p>If we then skip to the supplemental figures we hit the pretty rough equation 12 which tells us how to solve for f_i(p,t)</p>
<p><span class="math display">\[f_{i}(p,t) = \frac{1}{\sqrt{(2\pi)^2detCOV_{i}(t)}}exp(-\frac{1}{2}(p-\mu_{i}(\overrightarrow{s}_{i}(t)))^tCOV_{i}(t)^{-1}(p-\mu_{i}(t)))  \]</span></p>
<p>It looks horrendous but it’s just the equation for the multivariate normal distribution. See for example <a href="https://wikimedia.org/api/rest_v1/media/math/render/svg/c66e6f6abd66698181e114a4b00da97446efd3c4">here</a>. It’s not a surprise to see this equation because we know we need to solve a multivariate normal from the example using our full back above!</p>
<p>All we need to do is find x, μ, and Σ, in the linked picture above. Then we’re going to use mvtnorm::dmvnorm to calculate the density function. If you run</p>
<pre class="r"><code>?mvtnorm::dmvnorm</code></pre>
<p>you can see that ‘coincidentally’ this also requires 3 arguments (ignore the 4th log = FALSE), x, μ (mean), and sigma. All we have to do is find out what each of these arguments are equal to.</p>
<p>Firstly we want to find the covariance matrix (COV_i(t)). To calculate this, we can rewrite it as Sigma- the product of two matrices R and S such that:</p>
<p><span class="math display">\[ \Sigma = R\cdot S \cdot S \cdot R^{-1}\]</span>
where R is the rotation matrix around the euclidean plane:</p>
<p><span class="math display">\[R = 
\begin{bmatrix}
cos(\theta) &amp; -sin(\theta) \\
sin(\theta) &amp; cos(\theta) \\
\end{bmatrix}
\]</span></p>
<p>and S is a scaling matrix</p>
<p><span class="math display">\[S = 
\begin{bmatrix}
s_{x} &amp; 0 \\
0 &amp; s_{y} \\
\end{bmatrix}
\]</span></p>
<p>The details of this transformation aren’t really important, but a good explanation can be found <a href="https://www.visiondummy.com/2014/04/geometric-interpretation-covariance-matrix/">here</a>.</p>
<p>After resolving these matrices, we then only need to find the mean value of the distribution (μ_i(t)) which is defined in equation 21 of the paper</p>
<p><span class="math display">\[\mu_{i}(t) = p_{i}(t) + \overrightarrow{\widehat{s}}_{i}(t) \cdot 0.5 \]</span>
(we’ll go over the details of this equation later)</p>
<p>and also the pitch area, p, which is just an area of the pitch we want to find the control a player exerts over. We define this by dividing the total pitch area into many ‘pixels’ sampling each in our multivariate normal function. For example, in you split a 120m x 80m pitch into 1m^2 boxes, there are 120 * 80 = 9600 ‘pixels’ to run across.</p>
</div>
<div id="the-data" class="section level1">
<h1>The Data</h1>
<p>Now we’ve (briefly) gone through the theory, we can start working with the data and build our way back up. First we need to get our hands on the data itself. As part of the Friends of Tracking project during lockdown, Metrica Sports have kindly provided 2 sample matches (I’m using match 1 here) of tracking and event data which can be found <a href="https://github.com/metrica-sports/sample-data">here</a>.</p>
<p>The function below downloads, melts and organises the data.</p>
<pre class="r"><code>#func to download and melt tracking data
#will use game 1
get_tracking_data &lt;- function(file, directory = &quot;metrica-sports/sample-data&quot;, x_adj = 120, y_adj = 80) {
  #build url
  url &lt;- paste0(&quot;https://raw.githubusercontent.com/&quot;, directory, &quot;/master/data/&quot;, file)
  #read data
  data &lt;- read_csv(url, skip = 2)
  
  #fix names
  names(data)[grep(&quot;^X[0-9]*$&quot;, names(data))-1] &lt;- paste0(names(data)[grep(&quot;^X[0-9]*$&quot;, names(data))-1], &quot;_x&quot;)
  names(data)[grep(&quot;^X[0-9]*$&quot;, names(data))] &lt;- gsub(&quot;_x$&quot;, &quot;_y&quot;, names(data)[grep(&quot;^X[0-9]*$&quot;, names(data))-1])
  
  #melt it from long to wide
  melted_data &lt;- data %&gt;%
    pivot_longer(cols = starts_with(&quot;Player&quot;)) %&gt;%
    separate(name, into = c(&quot;player&quot;, &quot;coord&quot;), sep = &quot;_&quot;) %&gt;%
    pivot_wider(names_from = &quot;coord&quot;, values_from = &quot;value&quot;) %&gt;%
    rename(time = `Time [s]`) %&gt;%
    rename_all(tolower) %&gt;%
    #add the team info
    #scale coords to statsbomb spec
    mutate(team = gsub(&quot;(.*)(Home_Team|Away_Team)(\\..*)&quot;, &quot;\\2&quot;, file)) %&gt;%
    mutate_at(vars(ends_with(&quot;x&quot;)), ~.x * x_adj) %&gt;%
    mutate_at(vars(ends_with(&quot;y&quot;)), ~.x * y_adj) %&gt;%
    arrange(player, frame) %&gt;%
    #some missing values on the ball location
    #will just say ball stays where it is when no location data
    #could interpolate but w/e
    mutate(ball_x = na.locf(ball_x),
           ball_y = na.locf(ball_y))
  return(melted_data)
}

#run
tracking_data &lt;- map_df(
  c(&quot;Sample_Game_1/Sample_Game_1_RawTrackingData_Away_Team.csv&quot;, 
    &quot;Sample_Game_1/Sample_Game_1_RawTrackingData_Home_Team.csv&quot;),
  get_tracking_data) %&gt;%
  filter(!is.na(x) &amp; !is.na(y))</code></pre>
<p>To calculate pitch control, we only need 4 pieces on information on each player to calculate their relative pitch control:</p>
<ul>
<li>their x,y location on the pitch</li>
<li>the x,y location of the ball</li>
<li>the time at which they were at that location</li>
<li>and also, their location x,y at time t + n</li>
</ul>
<pre class="r"><code>head(tracking_data)</code></pre>
<pre><code>## # A tibble: 6 x 9
##   period frame  time ball_x ball_y player       x     y team     
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    
## 1      1     1  0.04   54.6   31.0 Player15  70.1  16.6 Away_Team
## 2      1     2  0.08   59.6   32.5 Player15  70.1  16.6 Away_Team
## 3      1     3  0.12   64.5   34.0 Player15  70.1  16.6 Away_Team
## 4      1     4  0.16   66.4   33.8 Player15  70.0  16.7 Away_Team
## 5      1     5  0.2    66.6   32.5 Player15  69.9  16.8 Away_Team
## 6      1     6  0.24   66.8   31.1 Player15  69.9  16.9 Away_Team</code></pre>
<p>and from this we can build up everything we need. We’ll also want the team data at the end to sum across all players but for now that isn’t important.</p>
<p>First lets do the two simplest: the speed and trajectory of a player’s movement. To ease processing, first we’ll put all the information needed per frame on one line. Not strictly necessary, but allows for neater functions when we really get processing</p>
<pre class="r"><code>#first add in the lead x/y to ease processing 
tracking_data &lt;- tracking_data %&gt;%
  group_by(player, team, period) %&gt;%
  #player x,y and time at t + n
  mutate(next_x = lead(x), next_y = lead(y), next_time = lead(time)) %&gt;%
  #to develop velocity arrows per player
  mutate(forward_x = lead(x, 10), forward_y = lead(y, 10)) %&gt;%
  ungroup() </code></pre>
<p>We calculate the speed in the x and y dimensions simply as the change in position divided by the time taken, and can calculate theta using either this speed vector, or the change in position (defined as the angle from the x axis the vector takes).</p>
<p>For an example, here is the data for 4 seconds on Player15 in the sample dataset. It’s taken from about 4 minutes into the match.</p>
<pre class="r"><code>#filters for some data to plot
player_spec &lt;- &quot;Player15&quot;
#each frame is 0.04s apart, take 100 frames worth from t = 250
times_spec &lt;- seq(250, by = 0.04, length.out = 100)

#filter
example_data &lt;- tracking_data %&gt;%
  filter(player == player_spec &amp; time %in% times_spec)

#plot the players trajectory over this time
#and the velocity and theta derived from it
p4 &lt;- ggplot(example_data) +
  geom_point(aes(x = x, y = y, colour = time), alpha = 0.6, size = 3) +
  #plot the x-axis as a green line
  geom_hline(yintercept = first(example_data$y), colour = &quot;green&quot;, alpha = 0.5, size = 3) +
  #plot the x-axis movement
  geom_segment(aes(x = first(x), xend = last(x), y = first(y), yend = first(y)), 
               arrow = arrow(length = unit(0.03, &quot;npc&quot;))) +
  #plot the y axis movement
  geom_segment(aes(x = last(x), xend = last(x), y = first(y), yend = last(y)), 
               arrow = arrow(length = unit(0.03, &quot;npc&quot;))) +
  #plot the hypotenuse
  geom_segment(aes(x = first(x), xend = last(x), y = first(y), yend = last(y)),
               size = 2, colour = &quot;red&quot;, arrow = arrow(length = unit(0.03, &quot;npc&quot;))) +
  #anotate speeds and theta
  annotate(&quot;text&quot;, x = 105.5, y = 17.3, label = &quot;x speed = 0.95 m/s&quot;) +
  annotate(&quot;text&quot;, x = 106.75, y = 16.25, label = &quot;y speed =\n0.56m/s&quot;) +
  annotate(&quot;text&quot;, x = 104.25, y = 16.9, label = &quot;theta = -30.4°&quot;) +
  labs(x = &quot;pitch x coord (/m)&quot;,
       y = &quot;pitch y coord (/m)&quot;,
       title = &quot;example player movement over 4 seconds&quot;) +
  #scale manually so it isn&#39;t distorted
  scale_x_continuous(limits = c(103.5, 107.5)) +
  scale_y_continuous(limits = c(14, 18)) +
  theme_minimal()

p4</code></pre>
<p><img src="/post/2020-04-20-wide_open_spaces_1_files/figure-html/example_data-1.png" width="672" /></p>
<p>So we get a good idea of the players trajectory over those 4 seconds and the average velocity and angle he is travelling at.</p>
<p>We can now start building up all the calculations we need to do to work out the pitch control any one player (and then whole teams) exert from basics. Through this I’m going to define each sum as a function to make it <em>extremely</em> clear what’s going on. Some of those functions will be ridiculously simple, but I don’t want to skip over anything.</p>
<p>Starting with the speed in any dimension and the angle from the x axis (theta) the player is travelling at:</p>
<pre class="r"><code>#no real reason for these to be functions, but just to
#make it more obvious what we&#39;re doing
get_speed &lt;- function(coord, next_coord, time, next_time) {
  #speed in meters per second
  speed = (next_coord - coord) / (next_time - time)
  return(speed)
}

#again very simple for illustrative purposes
get_theta &lt;- function(x_speed, y_speed) {
  hypotenuse_speed = sqrt(x_speed^2 + y_speed^2)
  theta = acos(x_speed / hypotenuse_speed)
  return(theta)
}</code></pre>
<p>if we plug our data from graph p4 into these very verbose-ly we get</p>
<pre class="r"><code>x_start &lt;- first(example_data$x)
x_end &lt;- last(example_data$x)
y_start &lt;- first(example_data$y)
y_end &lt;- last(example_data$y)
t_start &lt;- first(example_data$time)
t_end &lt;- last(example_data$time)

#in m/s
speed_x &lt;- get_speed(x_start, x_end, t_start, t_end)
speed_y &lt;- get_speed(y_start, y_end, t_start, t_end)

#convert to degrees
theta &lt;- get_theta(speed_x, speed_y)
theta_deg &lt;- theta * (180/pi)

results &lt;- c(speed_x, speed_y, theta_deg)
names(results) &lt;- c(&quot;speed_x&quot;, &quot;speed_y&quot;, &quot;theta&quot;)
print(results)</code></pre>
<pre><code>##    speed_x    speed_y      theta 
##  0.9496970 -0.5575758 30.4175840</code></pre>
<p>(the calculations will use theta in radians, but I think it makes more sense to show it here in degrees).</p>
<p>We can now very trivially solve equation 21 right off the bat</p>
<p><span class="math display">\[\mu_{i}(t) = p_{i}(t) + \overrightarrow{\widehat{s}}_{i}(t) \cdot 0.5 \]</span></p>
<p>Where p is the location of player i at time t, and s_hat is the speed of the player in either dimension. The mean of the distribution (where we expect the player to have the most pitch control) is his current position + (where he will be / 2)</p>
<pre class="r"><code>#another simple function to find mu
get_mu &lt;- function(location, speed) {
  mu = location + speed / 2
  return(mu)
}

mu_x &lt;- get_mu(x_start, speed_x)
mu_y &lt;- get_mu(y_start, speed_y)</code></pre>
<p>Which means we now have the first of our variables for our big multivariate normal distribution equation (paper equation 12)</p>
<p><span class="math display">\[f_{i}(p,t) = \frac{1}{\sqrt{(2\pi)^2detCOV_{i}(t)}}exp(-\frac{1}{2}(p-\mu_{i}(\overrightarrow{s}_{i}(t)))^tCOV_{i}(t)^{-1}(p-\mu_{i}(t)))  \]</span></p>
<p>and just need to define p, and calculate the covariance matrix COV.</p>
<p>We can start calculating the components of the covariance matrix with equation 18 (calculating the speed as a ratio of max speed) which is also trivial to solve now. Instead of using the speed in either direction, this relies on the total velocity , which we can find using school trigonometry</p>
<p><span class="math display">\[ Srat_{i}(t) = \frac{s^2}{ 13^2 } \]</span>
The 13m/s constant is the assumed maximum possible speed of a player (averaging this over 100m would break the world record by ~2 seconds)</p>
<pre class="r"><code>get_srat &lt;- function(speed_x, speed_y) {
  #find total velocity
  speed &lt;- sqrt(speed_x^2 + abs(speed_y)^2)
  srat = (speed / 13)^2
  return(srat)
}

srat &lt;- get_srat(speed_x, speed_y)</code></pre>
<p>And we can also find the constant Ri- the radius of a players influence- which isn’t listed in the paper but gives rise to figure 9. Given the formula isn’t listed, the numeric constants in the equation might be slightly off. They’re all taken from Will Thomson’s work <a href="https://colab.research.google.com/drive/1V75UgfJEfCWgbfxnG4OuB1WpvqahUJPU?pli=1">here</a>.</p>
<p><span class="math display">\[R_{i}(t) = 
\begin{cases} 
4 + \frac{(p_{i}(t) - p_{b}(t))^3}{18^3 / 6} &amp; \text{if &lt; 10} \\
10 &amp; \text{else}
\end{cases}\]</span></p>
<p>It specifies that a player has an influence radius of 10 metres, unless they are within ~15metres of the ball, in which case their influence radius decreases with ball_distance to a minimum of 4 metres. The idea behind this is that a player nearer the ball is much more geographically focused in their movement- as they either posses the ball or are trying to win it back.</p>
<pre class="r"><code>#allocate a few more variables from our example data
ball_x &lt;- first(example_data$ball_x)
ball_y &lt;- first(example_data$ball_y)

#little bit more complicated but still easy
get_ri &lt;- function(x, y, ball_x, ball_y) {
  ball_diff &lt;- sqrt((x - ball_x) ^ 2 + (y - ball_y)^2)
  ri = 4 + ((ball_diff^3) / ((18^3) / 6))
  return(min(ri, 10))  
}

ri &lt;- get_ri(x_start, y_start, ball_x, ball_y)</code></pre>
<p>We can test this function in the range of distance to the ball 0-30m and compare it to figure 9 in the paper</p>
<pre class="r"><code>p5 &lt;- data.frame(
  x = 0:30,
  y = map_dbl(0:30, get_ri,
    #set all other args to 0
    y = 0, ball_x = 0, ball_y = 0)) %&gt;%
  ggplot(aes(x = x, y = y)) +
  geom_line(colour = &quot;maroon&quot;, size = 2) +
  geom_point(size = 3, alpha = 0.5) +
  scale_y_continuous(limits = c(0, 12)) +
  labs(title = &quot;paper figure 9 (approx)&quot;,
       x = &quot;distance to the ball (/m)&quot;,
       y = &quot;influence radius (/m)&quot;) +
  theme_minimal() 

p5</code></pre>
<p><img src="/post/2020-04-20-wide_open_spaces_1_files/figure-html/test_function-1.png" width="672" /></p>
<p>We’re really getting there now. We just need to define our covariance matrix and we’re done with equations. Remember earlier with redefined</p>
<p><span class="math display">\[ \Sigma = R\cdot S \cdot S \cdot R^{-1}\]</span>
in paper equation 14, where R is the rotation matrix, and S is the scaling matrix.</p>
<p>To rotate in Euclidean space clockwise from the x-axis, the rotation matrix <a href="https://en.wikipedia.org/wiki/Rotation_matrix">is just</a></p>
<p><span class="math display">\[R = 
\begin{bmatrix}
cos(\theta) &amp; -sin(\theta) \\
sin(\theta) &amp; cos(\theta) \\
\end{bmatrix}
\]</span>
as also defined in the paper in equation 16. Easy enough to define, we just need to put the right transform of theta in the right space</p>
<pre class="r"><code>get_R &lt;- function(theta) {
  #R fills down first so these aren&#39;t the wrong way round
  R = matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), nrow = 2)
  return(R)
}

R &lt;- get_R(theta)</code></pre>
<p>For simplicity, I earlier said that the scaling matrix (S) was equivalent to the speed of the player in x and y dimensions, which was a bit of a white lie. It <em>is</em> derived from that, but itself scaled by the influence radius of the player (Ri)</p>
<p><span class="math display">\[S = 
\begin{bmatrix}
s_{x} &amp; 0 \\
0 &amp; s_{y} \\
\end{bmatrix}
\]</span>
<span class="math display">\[S_{i}(t) = 
\begin{bmatrix}
\frac{R_{i}(t) \cdot (1 + Srat_{i}(\overrightarrow{s}_{i}(t)))}{2} &amp; 0 \\
0 &amp; \frac{R_{i}(t) \cdot (1-Srat_{i}(\overrightarrow{s}_{i}(t)))}{2} \\
\end{bmatrix}
\]</span></p>
<p>This is the same as equation 19, I’ve just taken the Ri outside the brackets. As with the rotation matrix R, this is just matrix building and putting the right variables in the right place</p>
<pre class="r"><code>get_S &lt;- function(ri, srat) {
  top_left &lt;- ri * (1 + srat) / 2
  bottom_right &lt;- ri * (1-srat) / 2
  S = matrix(c(top_left, 0, 0, bottom_right), nrow = 2)
}

S &lt;- get_S(ri, srat)</code></pre>
<p>Once we have R and S, Σ is just equal to the dot product of these as in equation 15</p>
<pre class="r"><code>get_Sigma &lt;- function(R, S) {
  inv_R &lt;- solve(R)
  Sigma = R %*% S %*% S %*% inv_R
  return(Sigma)
}

Sigma &lt;- get_Sigma(R, S)</code></pre>
<p>So now we have the mean (μ), sigma (Σ) arguments to our dmvnorm function to calculate a players pitch control. We just to plug in the p term (corresponding to x in the R function arguments).</p>
<p>As in equation 1 (and 13), we actually need <em>two</em> p terms:</p>
<p><span class="math display">\[I_{i}(p,t) = \frac{f_{i}(p,t)}{f_{i}(p_{i}(t), t)} \]</span></p>
<p>the first (p) account for every ‘unit’ of the pitch (we divide the pitch up into each squares and calculate a players influence on each) and a second (p_i) which is the control of a player on their own area of pitch p. The denominator (control of pitch at player i’s x,y) is used to normalise the control they exert across the pitch from 0-1.</p>
<p>To create the matrix of pitch zones, we can simply use seq and expand.grid on the dimensions of the pitch. Splitting each dimension 200 ways leaves us with a 40000 x 2 data.frame to apply as p. For p_i, we just use the player’s x and y coordinates.</p>
<pre class="r"><code>#use statsbomb coords - 120m x 80m pitch
#split into 200x200 rectangles
pitch &lt;- expand.grid(seq(0, 120, length.out = 200), seq(0, 80, length.out = 200)) %&gt;%
    rename(x = Var1, y = Var2)

#function to calculate I as in equation 1/13
calc_I &lt;- function(pitch_area, x, y, mu_x, mu_y, Sigma) {
  #create vectors
  mu &lt;- c(mu_x, mu_y)
  player_loc &lt;- c(x, y)
  
  numerator &lt;- dmvnorm(as.matrix(pitch_area), mu, Sigma)
  denominator &lt;- dmvnorm(t(matrix(player_loc)), mu, Sigma)
  #and normalise
  norm_pdf = numerator/denominator
  return(norm_pdf)
}

#column I is the control on pitch area x,y of player I
I &lt;- calc_I(pitch, x_start, y_start, mu_x, mu_y, Sigma)
head(mutate(pitch, I))</code></pre>
<pre><code>##           x y            I
## 1 0.0000000 0 4.256184e-96
## 2 0.6030151 0 5.076124e-95
## 3 1.2060302 0 5.967198e-94
## 4 1.8090452 0 6.914091e-93
## 5 2.4120603 0 7.896343e-92
## 6 3.0150754 0 8.888804e-91</code></pre>
<p>We of course need to do this across the whole team, summing the pitch influence per team then finding the difference between them as per equation 2 in the paper</p>
<p><span class="math display">\[PC_{(p,t)} = \sigma \sum_{i} I_{(p,t)} - \sum_{j} I_{(p,t)}\]</span></p>
<p>I’ve neatly nested all the functions we’ve written into one larger function which every row of a team is then applied to using pmap from the purrr package.</p>
<pre class="r"><code>#test our functions on one frame of the tracking data
testing_data &lt;- tracking_data %&gt;%
  filter(time == 600) 

#sum all our little functions into one bigger function
calc_PC &lt;- function(time, next_time, ball_x, ball_y, x, y, next_x, next_y, team, player, pitch_area) {
  speed_x &lt;- get_speed(x, next_x, time, next_time)
  speed_y &lt;- get_speed(y, next_y, time, next_time)
  srat &lt;- get_srat(speed_x, speed_y)
  theta &lt;- get_theta(speed_x, speed_y)
  
  mu_x &lt;- get_mu(x, speed_x)
  mu_y &lt;- get_mu(y, speed_y)
  
  ri &lt;- get_ri(x, y, ball_x, ball_y)

  R &lt;- get_R(theta)
  S &lt;- get_S(ri, srat)
  
  Sigma &lt;- get_Sigma(R, S)
  
  pitch_area$I &lt;- calc_I(as.matrix(pitch), x, y, mu_x, mu_y, Sigma)
  pitch_area$team &lt;- team
  pitch_area$time &lt;- time
  pitch_area$player &lt;- player
  return(pitch_area)
}

#run the pitch control function
pitch_control &lt;- testing_data %&gt;%
  select(time, next_time, ball_x, ball_y, x, y, next_x, next_y, player, team) %&gt;%
  #run func
  pmap_df(., calc_PC, pitch_area = pitch) %&gt;%
  #sum by team and area
  group_by(team, x, y) %&gt;%
  summarise(team_sum = sum(I)) %&gt;%
  pivot_wider(names_from = team, values_from = team_sum) %&gt;%
  #σ - logistic function
  mutate(PC = 1 / (1 + exp(Home_Team - Away_Team)))</code></pre>
<p>After calculating the individual pitch control metrics, we sum by team and pixel and then subtract the away team sum from the home team sum and run it through a simple logistic function (σ)</p>
<pre class="r"><code>#get the position of the ball for this frame
ball_location &lt;- testing_data %&gt;%
  select(ball_x, ball_y) %&gt;%
  unique()

#plot it all
p6 &lt;- ggplot() +
  #pitch layout background
  annotate_pitch(dimensions = pitch_statsbomb) +
  #pitch control raster
  geom_tile(data = pitch_control, aes(x = x, y = y, fill = PC), alpha = 0.7) +
  scale_fill_gradient2(low = &quot;blue&quot;, high = &quot;red&quot;, mid = &quot;white&quot;, midpoint = 0.5) +
  #players for each team
  #also add in little vector arrows
  geom_segment(data = testing_data, aes(x = x, y = y, xend = forward_x, yend = forward_y, colour = team),
               size = 1, arrow = arrow(length = unit(0.01, &quot;npc&quot;))) +
  geom_point(data = testing_data, aes(x = x, y = y, colour = team), size = 3) +
  scale_colour_manual(values = c(&quot;black&quot;, &quot;gold&quot;), guide = FALSE) +
  #ball location
  geom_point(data = ball_location, aes(x = ball_x, y = ball_y),
             colour = &quot;black&quot;, fill = &quot;white&quot;, shape = 21, size = 2.5, stroke = 2) +
  theme_pitch()

p6</code></pre>
<p><img src="/post/2020-04-20-wide_open_spaces_1_files/figure-html/plot_PC-1.png" width="672" /></p>
<p>It looks pretty good! We can see which areas on the pitch the yellow and black (blue and red areas respectively) control (the ball here is the white circle outlined in black). In theory we can now run this function over the whole tracking_data data frame and calculate the control of each time over every part of the pitch at any time.</p>
<p>If we know this, we can work out (e.g.) the potential of an attack by multiplying the pitch control by a second layer, the value of every area of the pitch. For a very good intro into why/how you might value pitch areas, see <a href="https://karun.in/blog/expected-threat.html">Karun Singh’s explanation of Expected Threat</a>. The paper itself uses a neural network based on the ball location. It can be best understood as imaging that you only know the location of the ball and are asked where the best place to pass it to would be? Moving it towards the centre of the opposition goal (reducing distance and angle) is always better, but you also want to maximise the chance of the pass being successful. The paper includes a great mp4 of modeled real life play hosted on <a href="http://www.lukebornn.com/sloan/field_value.mp4">Luke Bornn’s website</a>.</p>
<p>This post is already long enough so I’m not going to go into pitch value more here, but will hopefully write a followup combining the two at some point.</p>
</div>
<div id="premature-optimisation" class="section level1">
<h1>(premature) optimisation</h1>
<p>(There’s not really much gain from reading beyond here, but I attempted to implement it in Rcpp for some optimisation which worked a little bit- I’m sure this function could be vastly improved though so it might be of value leaving it here for others to run with)</p>
<p>So this is all fine and good, but we probably want to run this at least over every frame in the game, and possibly many games! To do this we’re really going to want to optimise the crap out of this function. I’ve had a first go at this using Rcpp and RcppArmadillo to implement the whole pitch control algorithm. It actually didn’t speed things up as much as I wanted*, but does remove 20-30% of the time the R function takes. (it’s also just good practice to write more C++ for myself).</p>
<p>*lots more low hanging fruit to take out of it, but it does the job for now</p>
<p>We’ll need a few Rcpp libraries to implement this:</p>
<pre class="r"><code>library(Rcpp)
library(RcppArmadillo)</code></pre>
<p>And then can use a Rcpp chunk to export a compiled function that R can access</p>
<pre class="cpp"><code>//namespaces
#include &lt;RcppArmadillo.h&gt;
// [[Rcpp::depends(RcppArmadillo)]]

using namespace Rcpp;

/* C++ version of the dtrmv BLAS function */
// stolen from https://gallery.rcpp.org/articles/dmvnorm_arma/
void inplace_tri_mat_mult(arma::rowvec &amp;x, arma::mat const &amp;trimat){
  arma::uword const n = trimat.n_cols;
  
  for(unsigned j = n; j-- &gt; 0;){
    double tmp(0.);
    for(unsigned i = 0; i &lt;= j; ++i)
      tmp += trimat.at(i, j) * x[i];
    x[j] = tmp;
  }
}

//set log(2pi) as a constant
static double const log2pi = std::log(2.0 * M_PI);

//replaces the dmvnorm() multivariate sampling
arma::vec dmvnrm_arma_fast(arma::mat const &amp;x,  
                           arma::rowvec const &amp;mean,  
                           arma::mat const &amp;sigma, 
                           bool const logd = false) { 
    using arma::uword;
    uword const n = x.n_rows, 
             xdim = x.n_cols;
    arma::vec out(n);
    arma::mat const rooti = arma::inv(trimatu(arma::chol(sigma)));
    double const rootisum = arma::sum(log(rooti.diag())), 
                constants = -(double)xdim/2.0 * log2pi, 
              other_terms = rootisum + constants;
    
    arma::rowvec z;
    for (uword i = 0; i &lt; n; i++) {
        z = (x.row(i) - mean);
        inplace_tri_mat_mult(z, rooti);
        out(i) = other_terms - 0.5 * arma::dot(z, z);     
    }  
      
    if (logd)
      return out;
    return exp(out);
}

//does all the calculations in the paper
//outputs a vector
// [[Rcpp::export]]
arma::vec calc_I_cpp(arma::vec coords, arma::vec next_coords, arma::vec ball_coords, double t, double next_t, arma::mat pitch, arma::mat coord_mat) {
  arma::vec rng = runif(1);
  arma::vec velocity = ((next_coords - coords) + (rng[0] / 10000)) / (next_t - t);
  double speed = norm(velocity);
  double srat =pow((speed / 13), 2.0);
  double theta = acos(velocity[0] / speed);
  
  //sometimes players reach &#39;impossible&#39; speeds
  if(srat &gt; 1) {
    velocity = {(12.5 * cos(theta)), (12.5 * sin(theta))};
    speed = norm(velocity);
    srat = pow((speed / 13), 2.0);
  }
  
  arma::mat R = {{+cos(theta), -sin(theta)},
                 {+sin(theta), +cos(theta)}};
  
  arma::vec m = coords + velocity / 2;
  arma::rowvec mu = arma::conv_to&lt;arma::rowvec&gt;::from(m);

  
  double ri_val = 4.0 + (pow(norm(ball_coords - coords), 3.0) / (pow(18.0, 3) / 6));
  double ri = std::min(ri_val, 10.0);
  arma::mat S = {{ri * (1 + srat) / 2, 0},
                 {0, ri * (1 - srat) / 2}};
  arma::mat inv_R = arma::inv(R);
  arma::mat Sigma = R * S * S * inv_R;
  
  arma::vec numerator = dmvnrm_arma_fast(pitch, mu, Sigma);
  arma::vec denominator = dmvnrm_arma_fast(coord_mat, mu, Sigma);
  arma::vec I = numerator / denominator[0];
  return I;
}
</code></pre>
<p>And we can now start running this over multiple frames. My laptop is pretty hideously falling apart at the moment, so I’ve limited it here, but really you could for sure run it over many frames. For plotting as a single object, remember, we’re using a 40000 (200 * 200) row df to store stuff which is surely less than optimal, but even cutting that down as much as feasible, with 25 frames a second, memory bloat is going to happen fast.</p>
<p>In a future post at some point I’d like to actually try some analysis using this work, and I think the key is really to analyse within frame and output a condensed pitch area controlled * value for each player.</p>
<p>For now though, I’ve posted a plot of ten seconds (not consecutive frames) of data. If you click on that, it links to an imgur of the gif of the proper combination of those frames.</p>
<pre class="r"><code>#ugly packaged up function
calc_PC_cpp &lt;- function(time, next_time, ball_x, ball_y, x, y, next_x, next_y, team, player, pitch_area) {
  #blargh terribly written- run out of energy to improve
  pitch_area$I &lt;- calc_I_cpp(c(x, y), c(next_x, next_y), c(ball_x, ball_y), time, next_time, as.matrix(pitch_area), t(c(x, y)))
  pitch_area$team &lt;- team
  pitch_area$time &lt;- time
  pitch_area$player &lt;- player
  return(pitch_area)
}

#sample 10 seconds worth of data
animation_data &lt;- tracking_data %&gt;%
  filter(time %in% 600:610) %&gt;%
  dplyr::select(time, next_time, ball_x, ball_y, x, y, next_x, next_y, team, player) 

#run the function over the data
anim_pitch_control &lt;- animation_data %&gt;%
  #run func
  pmap_df(., calc_PC_cpp, pitch_area = pitch) %&gt;%
  #sum by team and area
  group_by(team, x, y, time) %&gt;%
  summarise(team_sum = sum(I)) %&gt;%
  pivot_wider(names_from = team, values_from = team_sum) %&gt;%
  #σ - logistic function
  mutate(PC = 1 / (1 + exp(Home_Team - Away_Team)))

#plot
p7 &lt;- ggplot(anim_pitch_control, aes(x = x, y = y, colour = PC)) +
  annotate_pitch(dimensions = pitch_statsbomb) +
  geom_point(alpha = 0.7, shape = 15) +
  scale_colour_gradient2(low = &quot;blue&quot;, high = &quot;red&quot;, mid = &quot;white&quot;, midpoint = 0.5) +
  theme_pitch() +
  labs(title = &quot;pitch control rasters by match time (s)&quot;) +
  facet_wrap(~time)</code></pre>
<p><a href="https://i.imgur.com/fYIfjaR.mp4" title="plot of surface control"><img src="/img/pitch_control_raster.png" alt="plot of surface control" /></a></p>
<p>(click for link to gif)</p>
<p>I actually really like these plots of just the surface control; they remind me of high dimensional (e.g. biological sample) sorting and I think just look pretty funky</p>
<p>I mentioned I benchmarked the functions themselves earlier, here’s some sample code of benchmarking. It’s not really apples to oranges because of the tweaks to the cpp function, and obviously calling pmap_df on a single row of a data.frame isn’t really what it’s for… it’s more just to document a little bit (also please ignore the spaghetti passing of functions).</p>
<pre class="r"><code>library(microbenchmark)
microbenchmark(
  pmap_calc_pc = pmap_df(animation_data[1,], calc_PC, pitch_area = pitch),
  pmap_calc_pc_cpp = pmap_df(animation_data[1,], calc_PC_cpp, pitch_area = pitch),
  calc_pc = calc_PC(animation_data$time[1], animation_data$next_time[1], animation_data$ball_x[1], animation_data$ball_y[1], animation_data$x[1], animation_data$y[1], animation_data$next_x[1], animation_data$next_y[1], &quot;teamA&quot;, &quot;playera&quot;, pitch),
  calc_pc_cpp = calc_PC_cpp(animation_data$time[1], animation_data$next_time[1], animation_data$ball_x[1], animation_data$ball_y[1], animation_data$x[1], animation_data$y[1], animation_data$next_x[1], animation_data$next_y[1], &quot;teamA&quot;, &quot;playera&quot;, pitch),
  times = 1000
)</code></pre>
<pre><code>## Unit: milliseconds
##              expr    min      lq     mean  median      uq      max neval
##      pmap_calc_pc 4.5347 5.95505 7.129008 6.30795 6.84670 125.7230  1000
##  pmap_calc_pc_cpp 3.8280 4.93920 5.608463 5.20625 5.64985 126.1780  1000
##           calc_pc 3.1482 4.16710 5.136463 4.38575 4.82170 127.3604  1000
##       calc_pc_cpp 2.4537 3.15150 4.023492 3.31625 3.63570 212.4050  1000</code></pre>
<p>That’s all for this post! As I said at some point (soon? later? who knows) I’d like to include the value term because conceptually it’s not hard to get a stupid version of it going. Hopefully this is of use to some people. As I said up top, written in evenings locked inside during quarantine so probably maths mistakes/ huge coding errors etc. If people point them out and get in touch I’ll fix them.</p>
<p>Best!</p>
</div>
