---
title: Racing Bar Charts and Some Gnarly data.table Munging
author: Robert Hickman
date: '2019-11-17'
slug: racing_bar_charts
output: pdf_document
categories: []
tags:
  - R
  - bar_charts
  - data.table
header:
  caption: ''
  image: ''
---

A while ago (and also still a bit) [racing bar charts]() were all the rage on data visualisation forums/twitter. Perhaps one of the real breakout examples is this tweet from the, always excellent, John Burn-Murdochat the Financial Times, looking at the most populous cities in the world since the middle ages:

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">New project:<br> <br>A “Bar Chart Race” animation showing the changing ranks of the 10 biggest cities in the world since 1500.<br><br>Fascinating to watch giant cities vanish after falling in conquests, and amazing that three UK cities were in the top 8 in the late 1800s. <a href="https://t.co/KglMZbYobr">pic.twitter.com/KglMZbYobr</a></p>&mdash; John Burn-Murdoch (@jburnmurdoch) <a href="https://twitter.com/jburnmurdoch/status/1107552367795412992?ref_src=twsrc%5Etfw">March 18, 2019</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script> 

As with most things I blog about here I wondered if I could make them in R, and how easy that would be. The first half of this post is basically recreating the aforementioned gif pretty simply using [gganimate](). However, I also wanted to see if I could use the format to look at the strongest English football teams across history in [link to second half of blogpost]() which gave me an unexpected lesson in using [data.table]() and especially some lesser used facets of it- ones that might require more complex multiline solutions in the tidyverse

As a brief aside before I get to the code, the munging with data.table also made me think about why I code in my free time. I spend quite a substantial portion of my free time doing analysis using techniques/datasets that interest me, even though they provide no real tangible benefit (when I do code for my current job, it's mostly in MATLAB with a small remained in Python and on fairly tidy datasets).

One thing that _is_ related to my PhD however, is watching lots of videos of Macaques and other primates. Almost all young primates engage in wrestling behaviour for fun, but also so that when they are older and actually do have to fight, they have some experience in low-stakes play. It struck me as a nice parallel to my small/weird coding projects which mean I have to end up doing odd bits of munging to data in various states of tidyness, instead of the work on much more curated data I do for my day job. It's also a good excuse to insert a related video of very cute baby Snow Macaques wrestling.

<iframe width="560" height="315" src="https://www.youtube.com/watch?v=xyaRubgMyks" frameborder="0" allowfullscreen></iframe>

# Reproducing Racing Bar Charts in R

Anyway, getting on with actually producing racing bar charts, first we want to load up the libraries we'll need.

```{r, warning=FALSE,message=FALSE}
library(tidyverse)
library(gganimate)
library(tweenr)
library(stringi)
#for getting the continents of various cities
library(countrycode)
```

Then also grab the data. This isn't exactly all the data used by John in his tweet but it's close enough. I can't remember where I got the data from but similar datasets can be found by googling "world cities populations csv" e.g. [here](https://datahub.io/core/population-city).

```{r get_city_data, warning=FALSE,message=FALSE}
#read in data from blog repo
city_data <- read.csv("https://raw.githubusercontent.com/RobWHickman/netlify_blog/race_bar_charts/static/files/racing_bar_charts/city_populations.csv", 
                 encoding = "UTF-8", stringsAsFactors = FALSE)

head(city_data)
```

Then we want to pull out the relevant data and do some melting to get a nice long format data frame of our data.

```{r munge_city_data1, warning=FALSE,message=FALSE}
city_data <- city_data %>%
  #select out relevant columns
  select(country_id = Country.Code, country = Country.or.area,
         city_id = City.Code, city = Urban.Agglomeration,
         X1950, X1955, X1960, X1965, X1970, X1975, X1980, X1985, X1990,
         X1995, X2000, X2005, X2010, X2015, X2020, X2025, X2030) %>%
  #melt the data to long format
  reshape2::melt(id.vars = c("country_id", "country", "city_id", "city"),
                 variable.name = "year", value.name = "population") %>%
  #conver the data into usuable numbers
  mutate(year = as.numeric(gsub("^X", "", year)),
         population = as.numeric(gsub(",", "", population)),
         #convert the text into utf-8 readable
         city = stri_trans_general(city, "latin-ascii")) %>%
  #extract the english names for cities
  mutate(city_name = case_when(
    grepl("\\(", city) ~ str_extract(city,  "(?<=\\().+?(?=\\))"),
    grepl("-", city) ~ gsub("-.*", "", city),
    TRUE ~ as.character(city)
  ))

head(city_data)
```
As the y axis of our racing bar chart is going to be the cities rank in terms of population for any given observation year, we need to list cities in order. Using the Tidyverse a simple group_by() and mutating an order column will do the trick

```{r order_cities_by_year, warning=FALSE,message=FALSE}
city_data <- city_data %>%
  #group by and find order at any point
  group_by(year) %>%
  arrange(-population) %>%
  mutate(order = row_number()) %>%
  ungroup()

head(city_data)
```
I also wanted to colour the bars by the continent of the city for a little extra aesthetic. Easy to do by joining with the data from countrycode.

```{r get_continent, warning=FALSE,message=FALSE}
#get the id data for each unique city
id_data <- city_data %>%
  select(city_id, city_name, country_id, country) %>%
  unique() %>%
  #find the continent of each city
  mutate(continent = countrycode(.$country, origin = "country.name", destination = "continent"))

```

Then we just need to do a final bit of munging on our data. I think in theory it's possible to do this purely within the gganimate plotting machinery, but I prefer to munge the data outside.

First we want to select the columns that will be 'animated'- i.e. the population and the order, and then also the time information (year), and group (city_id). We pre-specify a linear ease (i.e that between time points the numbers increase/decrease linearly per frame). 

Finally I merge in our id data we prepared above and also round off the population numbers to leave a data frame ready for plotting!

```{r tween_data, warning=FALSE,message=FALSE}
#the number of frames the output will contain
frames <- 500

#use tweenr to manually make the naimation frame data
frame_data <- city_data %>%
  group_by(year) %>%
  arrange(-population) %>%
  mutate(order = row_number()) %>%
  #tweenr stuff here
  select(city_id, year, population, order) %>%
  mutate(ease = "linear") %>%
  tween_elements(., "year", "city_id", "ease", nframes= frames) %>%
  #select out columns
  select(population, order, year, .frame, city_id = .group) %>%
  #merge in id data
  merge(., id_data, by = 'city_id') %>%
  #munge population numbers
  mutate(pop = round(population/1000, 2))

head(frame_data)
```

Then we just want to filter out only the information we want to plot (the top 10 cities per year, I use 10.8 so you see cities as they enter the top 10) and use the lesser-spotted geom_tile() geom from ggplot2 which I found is the easiest to manually move about. After some extra aesthetics we then specify the transition_states()- in our case transition based on the year- and some cool little extras like dynamically adjusting the y axis, and also fading bars as they enter and exit the plot. 

At the bottom we then turn this plot into a gif using animate and add a little pause at the start and end.

```{r plot_and_gif_city_data, warning=FALSE,message=FALSE}
p_cities <- frame_data %>%
  #only want to plot the top 10
  filter(order < 10.8) %>%
  ggplot(aes(y = order, x = pop)) +
  #hack to plot the moving bars
  #from v helpful answer at
  #https://stackoverflow.com/questions/53162821/
  #animated-sorted-bar-chart-with-bars-overtaking-each-other/53163549
  geom_tile(aes(x = pop/2, width = pop, fill = continent),
            alpha = 0.8, colour = "black", height = 0.9) +
  geom_text(aes(label = sprintf("%1.2f",pop)), hjust = 1) +
  geom_text(aes(x = 0, label = paste(city_name, " ")),
            vjust = 0.2, hjust = 1) +
  #add labels to plot
  labs(title='{round(as.numeric(closest_state))}',
       x = "Population (millions)", y = "") +
  #y limits at 0-10.5
  #don't clip as will screw the labels outside the plot
  coord_cartesian(ylim = c(0,10.5), clip = "off") +
  #flip the y axis
  scale_y_reverse(position = "left") +
  #theme stuff
  #taken from same stackoverflow answer
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0, size = 22),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_blank(), 
        #make sure labels will be visible
        plot.margin = margin(0,0,0,2.5, "cm")) +
  #transition by our calculated year
  transition_states(year, transition_length = 1, state_length = 0) +
  #scale x axis as pop increases
  view_follow(fixed_y = TRUE) +
  #fade as bares enter and exit the plot
  exit_fade() +
  enter_fade()

#animate the gif
city_gif <- animate(p_cities, frames, start_pause = 0.5, end_pause = 1)
#e.g. if you want to save the output
#anim_save("city_gif.gif", city_gif)
```

And voilà! here is our gif

```{r plot_city_gif, warning=FALSE,message=FALSE}
city_gif
```

# The Next Level

So as I mentioned, I wanted the example to be a plot of how English football teams have risen and fallen in strength over the ~150 years the league has been playing. This turned out to be more difficult than I anticipated so also gives a nice little intro to data.table beyond the basic i,j,k syntax.

For this we need James Curley's engsoccerdata package and then also data.table and zoo for munging our data

```{r extra_libraries, warning=FALSE,message=FALSE}
#use James Curley's engsoccer data for the match data
library(engsoccerdata)
#this file will be in the next version of engsoccerdata but isn't at time of writing
club_data <- read.csv("https://raw.githubusercontent.com/RobWHickman/netlify_blog/race_bar_charts/static/files/racing_bar_charts/england_club_data.csv",
                      stringsAsFactors = FALSE)

#data.table and zoo for munging
library(data.table)
library(zoo)

```

Then we want to select only the relevant bits of the data for calculating the [ELO]() ratings of teams on a match-by-match basis. For this I use the formula used by the folks who calculate the national football ELO ratings at [eloratings.net](https://www.eloratings.net/about) so if you're confused by what K and G mean look there.

```{r get_match_data}
match_data <- engsoccerdata::england %>%
  mutate(date = as.Date(Date)) %>%
  select(date, season = Season, home, visitor, tier, hgoal, vgoal, result) %>%
  mutate(K = (5-tier) * 10) %>%
  mutate(G = case_when(
    abs(hgoal-vgoal) < 2 ~ 1,
    abs(hgoal-vgoal) < 3 ~ 1.5,
    abs(hgoal-vgoal) >= 3 ~ (11 + abs(hgoal-vgoal)) / 8
  )) %>%
  mutate(result = case_when(
    result == "H" ~ 1,
    result == "A" ~ 0,
    result == "D" ~ 0.5
  )) %>%
  arrange(date)

head(match_data)
```

We can then define a quick function to update ELO ratings based on the match results and push out the updated ratings to a data frame holding the current rating over time. This will take a few minutes given how many matches we have so it's worth going to make a cup of tea while it runs.

```{r set_up_ELO, warning=FALSE,message=FALSE,eval=FALSE}
#start all teams with an ELO of 1000
team_ratings <- data.frame(team = unique(match_data$home),
                           rating = 1000)

#function to calculate team ELO and update back to the ratings df
calc_ELO <- function(row) {
  #get the difference in ratings
  hr <- team_ratings$rating[which(team_ratings$team == row$home)]
  vr <- team_ratings$rating[which(team_ratings$team == row$visitor)]
  dr <- (hr + 100) - vr
  
  e_result <- 1/ (10^(-dr/400)+1)
  new_hr <- hr + ((row$K*row$G) * (row$result - e_result))
  new_vr <- vr + ((row$K*row$G) * ((1-row$result) - (1-e_result)))
  
  team_ratings$rating[which(team_ratings$team == row$home)] <<- new_hr
  team_ratings$rating[which(team_ratings$team == row$visitor)] <<- new_vr
  
  output_row <- row %>%
    mutate(h_rating = new_hr, v_rating = new_vr)
  
  return(output_row)
}

#split and lapply function
elo_data <- match_data %>%
  split(f = seq(nrow(.))) %>%
  lapply(., calc_ELO) %>%
  do.call(rbind, .)

#melt the elo data
melt <- elo_data %>%
  select(date, season, home, visitor, h_rating, v_rating) %>%
  reshape2::melt(id.vars = c("date", "season", "h_rating", "v_rating"),
                 variable.name = "location", value.name = "team") %>%
  mutate(rating = case_when(
    location == "home" ~ h_rating,
    location == "visitor" ~ v_rating
  )) %>%
  select(date, season, team, rating)

#df of each teams rating after each game day
head(melted_elo_data)
```

```{r load_elo_data, warning=FALSE,message=FALSE,echo=FALSE}
melted_elo_data <- readRDS("../../static/files/racing_bar_charts/melted_elo_data.rds")

```

Now we have our ELO ratings for each team updated after every match, we can start munging the data to plot the racing bar chart. There's a few steps here that I'm going to separate out but keep the same name for the data.table we are working on. It's worth just working through step by step and seeing how the dt has been altered by the functions applied.

First, I want to initialise a data table that will eventually hold the rating of each team over every day. We'll tween() the ratings later, for now we need a column which has every combination of date and team

```{r munge_football_data, warning=FALSE,message=FALSE}
days <- map2(melted_elo_data[melted_elo_data[, .I[which.min(date)], by = "season"]$V1, date], 
             melted_elo_data[melted_elo_data[, .I[which.max(date)], by = "season"]$V1, date],
             seq.Date, by = "day") %>%
  do.call("c", .) %>%
  data.table(date = .)

munged_football_data <- melted_elo_data[days, on = "date"] %>%
  .[CJ(date = date, team = team, unique=TRUE), 
    on=.(date, team)] %>%
  .[!is.na(team)] %>%
  .[days[, year := as.numeric(gsub("-.*", "", date))], on = "date"] %>%
  .[order(date)] %>%
  #use tween fill for each team to get intermediate ratings
  .[, rating := tween_fill(rating, ease = "linear"), by = team] %>%
  .[, frame := .GRP, by = date] %>%
  .[frame %% 5 == 1] %>%
  #take the rolling mean over 10 days to smooth out jumps
  .[order(date), roll_rating := frollmean(rating, n = 10, algo = "exact", align = "left"), by = "team"] %>%
  #remove unrated rows
  .[!is.na(roll_rating)] %>%
    #order by rolling rating
  .[order(-roll_rating)] %>%
  #rating stransition over a 10 day window
  #order by rating (as with the cities when rating by size)
  .[frame %% 30 == 1, team_order := 1:.N, by = date] %>%
  #use tweenr to make transitions smooth
  .[order(date), order_fill := tween_fill(team_order, ease = "cubic-in-out"), by = team] %>%
  .[!is.na(order_fill)] %>%
  .[order(date)] %>%
  .[frame != lag(frame, default = 0), year_frame := 1:.N, by = year] %>%
  #fill down
  .[, year_frame := na.locf(year_frame)] %>%
  #frame is the season plus the amount through that season
  #could probably do something fancy and label as unique days but this suffices
  .[, year_frame := year + year_frame/(max(year_frame) + 1)] %>%
  .[, c("date", "team", "roll_rating", "order_fill", "year_frame")]

```


```{r plotting_football_data, warning=FALSE,message=FALSE}
plotting_data <- club_data %>%
  filter(team %in% munged_football_data$team) %>%
  munged_football_data[., on = "team"] %>%
  #only plot a cutdown here as it takes a while
  filter(date > "2014-07-01") %>%
  #only want to plot the top 10
  filter(order_fill < 10.8)

palette <- plotting_data %>%
  filter(!duplicated(team)) 
fills <- palette %>%
  .$col1 %>%
  `names<-`(palette$team)
cols <- palette %>%
  .$col2 %>%
  `names<-`(palette$team)

p_football <- plotting_data %>%
  ggplot(aes(y = order_fill, x = roll_rating, fill = team, colour = team)) +
  geom_tile(aes(x = roll_rating/2, width = roll_rating),
            alpha = 0.8, height = 0.9, size = 1) +
  geom_text(aes(x = 0, label = paste(short_name, " ")),
            vjust = 0.2, hjust = 1, colour = "black") +
  geom_text(aes(label = sprintf("%1.2f",roll_rating)), hjust = 1.5, colour = "black") +
  scale_fill_manual(values = fills, guide = FALSE) +
  scale_colour_manual(values = cols, guide = FALSE) +
  labs(title='{as.character(current_frame)}',
       x = "ELO rating", y = "") +
  coord_cartesian(ylim = c(0,10.5), clip = "off") +
  scale_y_reverse(position = "left") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0, size = 22),
        axis.ticks.y = element_blank(),
        axis.text.y  = element_blank(), 
        plot.margin = margin(0,0,0,2.5, "cm")) +
  transition_manual(date) +
  view_follow(fixed_y = TRUE)

football_gif <- animate(p_football, nframes = length(unique(plotting_data$year_frame)) * 0.8, fps = 10)
```

```{r plot_football_gif, warning=FALSE,message=FALSE}
anim_save("fooball_gif1.gif", football_gif)
```

