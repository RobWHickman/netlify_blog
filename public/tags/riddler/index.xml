<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>riddler on Robert Hickman</title>
    <link>/tags/riddler/</link>
    <description>Recent content in riddler on Robert Hickman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Mon, 29 Jun 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/riddler/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Riddler - June 26th</title>
      <link>/post/riddler_june_26th/</link>
      <pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler_june_26th/</guid>
      <description>


&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#for working with polygons
library(sf)
library(sfheaders)

library(tidyverse)
library(gtools)

set.seed(22081992)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;riddler-express&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Riddler Express&lt;/h1&gt;
&lt;p&gt;This weeks express deals with an erratic driver:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In Riddler City, the city streets follow a grid layout, running north-south and east-west. You’re driving north when you decide to play a little game. Every time you reach an intersection, you randomly turn left or right, each with a 50 percent chance.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;After driving through 10 intersections, what is the probability that you are still driving north?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So all we have to do is create a binomial tree of depth 10 and then sum by final heading direction. As the driver &lt;em&gt;must&lt;/em&gt; turn left or right at each junction, we actually only have to consider the final turn as this will change it from whichever North/South or East/West it is heading to the other with p = 0.5. But if we want to prove this, let’s consider it as a more canonical ball-drawing probability task where one can draw balls from a bag:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red (right) ball with probability p or&lt;/li&gt;
&lt;li&gt;Lime (left) ball with probability q&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;drawing balls 10 times without replacement&lt;/p&gt;
&lt;p&gt;We know that as there are only two balls, the total probability is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q) = 1 \]&lt;/span&gt;
on the first pick we are just choosing p or q so can raise everything to the power 1 (pick) to get the same formula:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^1 = 1^1 \]&lt;/span&gt;
and can generalise to n picks&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^n = 1^n \]&lt;/span&gt;
to expand this we’re going to get combinations of p and q to the powers from 0:n, multiplied by the combinatorics from &lt;a href=&#34;https://en.wikipedia.org/wiki/Pascal%27s_triangle&#34;&gt;Pascal’s triangle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If we set this multiplication as m, we can express this as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ m = \frac{n!}{(n-k!)k!} \]&lt;/span&gt;
(where k is 0:n)&lt;/p&gt;
&lt;p&gt;so for n = 10 (turns of the car, or picks of a ball), we get&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate pascals triangle via factorials
calc_pascal &amp;lt;- function(n,k) {
  factorial(n) / (factorial(n-k) * factorial(k))
}

#run for n turns
n_turns &amp;lt;- 10
m = map2_dbl(n_turns, 0:n_turns, calc_pascal)
m&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]   1  10  45 120 210 252 210 120  45  10   1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so for&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^{10}\]&lt;/span&gt;
we will expand this into&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ 1p^{10} + 10p^9q + 45p^8q^2 + 120 p^7q^3 + 210p^6q^4 + 252p^5q^5 + 210p^4q^6 + 120p^3q^7 + 45p^2q^8 + 10pq^9 + 1q^{10}\]&lt;/span&gt;
But where we now diverge from the balls in a bag, each time we draw (/turn), the position of our car updates. We don’t care about the probability of each of these per se, but the probabilities grouped by the final direction of the car.&lt;/p&gt;
&lt;p&gt;It should be clear that every p draw (a right turn), moves the car 1 cardinal direction to the right, whereas a left turn moves it -1 cardinal direction. In our expansion we have 210 examples of drawing 6 right turns and 4 left turns, which would end up having the car face due south (2 cardinal turns). For each term, we just have to minus the exponent of the left turns from the exponent of the right turns, then find the direction by taking the 4th modulus of this.&lt;/p&gt;
&lt;p&gt;For a binomial expansion like this, it’s very easy:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate the end heading for each term of the expansion
term_direction = (n_turns:0 - 0:n_turns) %% 4
term_direction&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 2 0 2 0 2 0 2 0 2 0 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so we’re either going to end up facing north (0 overall turn) or south (2 overall turns). We can then multiply these by the m for each term&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#list of cardinal direction
final_directions &amp;lt;- c(&amp;quot;north&amp;quot;, &amp;quot;east&amp;quot;, &amp;quot;south&amp;quot;, &amp;quot;west&amp;quot;)

#loop through each expansion term to get the final direction
direction_p &amp;lt;- c()
for(d in 0:3) {
  direction_p[d+1] &amp;lt;- sum(m[term_direction == d])
}

#find the probability of facing any direction
names(direction_p) &amp;lt;- final_directions
direction_p / sum(direction_p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## north  east south  west 
##   0.5   0.0   0.5   0.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so we have a 50% chance of ending up facing either north or south. So the answer to this weeks riddler express is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[p(North) = 0.5 \]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;extra-credit&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extra Credit&lt;/h2&gt;
&lt;p&gt;For extra credit, the driver decides instead to turn left, right, or continue straight with equal probability (1/3). In addition to p and q, we now also have an r probability where&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ r = p(No Turn) \]&lt;/span&gt;
We can then use expand.grid() to produce combinations of these three probabilities, and count the combinations by number of each of these:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find combinations of p, q, and r
extra_credit &amp;lt;- expand.grid(rep(list(c(&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;)), n_turns)) %&amp;gt;%
  #label each combination
  mutate(id = 1:n()) %&amp;gt;%
  #count numbers of p, q, and r
  pivot_longer(cols = starts_with(&amp;quot;Var&amp;quot;)) %&amp;gt;%
  group_by(id, value) %&amp;gt;%
  summarise(n = n()) %&amp;gt;%
  #pivot back to wide
  pivot_wider(id_cols = id, names_from = value, values_from = n) %&amp;gt;%
  mutate_at(c(&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;),  ~replace(., is.na(.), 0)) %&amp;gt;%
  #count numbers of each combination
  group_by(p, q, r) %&amp;gt;%
  summarise(n = n()) %&amp;gt;%
  arrange(n)

extra_credit&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 66 x 4
## # Groups:   p, q [66]
##        p     q     r     n
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
##  1     0     0    10     1
##  2     0    10     0     1
##  3    10     0     0     1
##  4     0     1     9    10
##  5     0     9     1    10
##  6     1     0     9    10
##  7     1     9     0    10
##  8     9     0     1    10
##  9     9     1     0    10
## 10     0     2     8    45
## # ... with 56 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we might expect, we get the same number of each combinations, but with 3x combinations for each x^n y^n (for each combination of p, q, and r). As we know that the final heading will be the difference in number of right and left turns, we can subtract these and count the number of combinations leading to each direction&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;extra_credit_answer &amp;lt;- extra_credit %&amp;gt;%
  mutate(net_turns = p - q) %&amp;gt;%
  mutate(final_direction = net_turns %% 4) %&amp;gt;%
  .$final_direction %&amp;gt;%
  table()

names(extra_credit_answer) &amp;lt;- final_directions
extra_credit_answer / sum(extra_credit_answer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     north      east     south      west 
## 0.2727273 0.2272727 0.2727273 0.2272727&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;giving us an answer of&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ p(North) = 0.\dot{2}\dot{7} \]&lt;/span&gt;
# Riddler Classic&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Polly Gawn loves to play “connect the dots.” Today, she’s playing a particularly challenging version of the game, which has six unlabeled dots on the page. She would like to connect them so that they form the vertices of a hexagon. To her surprise, she finds that there are many different hexagons she can draw, each with the same six vertices.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is the greatest possible number of unique hexagons Polly can draw using six points?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a pretty tricky question! I can’t see any way to analytically solve it and given that it involves polygons (and not just pure numbers) it seems like a tricky question to brute force. That doesn’t mean we can’t try though.&lt;/p&gt;
&lt;p&gt;Let’s start by using the data in the hint- that for n = 4 points, the maximum number is 3 polygons, given that the fourth point lies within an enclosing triangle of the other three. We can generate some points randomly for this pretty easily, and use the &lt;a href=&#34;https://r-spatial.github.io/sf/articles/sf1.html&#34;&gt;simple features&lt;/a&gt; package to test the properties of the resulting polygons:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#generate 3 random points
points &amp;lt;- data.frame(
  x = runif(3),
  y = runif(3)
)

#create a triangle from these points
triangle &amp;lt;- sf_polygon(points)

#randomly generate a fourth point within the bounding box of these points
new_point &amp;lt;- data.frame(
  x = runif(1, min = min(points$x), max = max(points$x)),
  y = runif(1, min = min(points$y), max = max(points$y))
)

#keep generate this point until it lies within the triangle of the previous 3
while(length(unlist(st_contains(triangle, sf_point(new_point)))) ==0) {
  new_point &amp;lt;- data.frame(
    x = runif(1, min = min(points$x), max = max(points$x)),
    y = runif(1, min = min(points$y), max = max(points$y))
  )
}

#bind the fourth point onto the previous 3
points &amp;lt;- rbind(points, new_point)

#plot the points
p2 &amp;lt;- ggplot() +
  #triangle
  geom_sf(data = triangle, alpha = 0.1) +
  geom_point(data = points, aes(x, y), 
             shape = 21, fill = &amp;quot;skyblue&amp;quot;, colour = &amp;quot;black&amp;quot;, size = 3) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/generate_four_points-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we need to brute force through every possible polygon. To do this we can use combinatorics again, this time with the permutations() function from the gtools package. We create every possible route of points, then take only the routes that start on the first point (to cut down our search space, as many routes will be the same just shifted to a different start node)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create all possible routes of 4 points
routes &amp;lt;- permutations(4, 4, 1:4) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  #filter those beginning with node 1
  filter(V1 == 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each route we then create the resulting polygon by ordering the points and creating a simple features polygon. These are then bound together and each given an id.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#cycle through routes to create polygons
for(r in seq(nrow(routes))) {
  nodes &amp;lt;- as.numeric(routes[r,])
  sf_points &amp;lt;- points[nodes,]
  sf &amp;lt;- sf_polygon(sf_points)
  
  if(r == 1) {
    polygons &amp;lt;- sf
  } else {
    polygons &amp;lt;- rbind(polygons, sf)
  }
}

polygons$id &amp;lt;- 1:nrow(polygons)

#plot the resulting polygons
p3 &amp;lt;- ggplot() +
  geom_sf(data = polygons, fill = &amp;quot;dodgerblue&amp;quot;) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/test_resulting_polygons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;However, we know that there are only 3 unique polygons for n = 4 points. Why have we found 6? From inspection it’s pretty clear that even though they all have unique paths, 3 of these are duplicates of 3 others. This occurs as for each starting node, there are two paths to create each polygon, a ‘clockwise’ path and an ‘anticlockwise’ one.&lt;/p&gt;
&lt;p&gt;We can easily test for this and remove half the polygons as such:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test for duplicate polygons
duplicates &amp;lt;- as.data.frame(st_equals(polygons, polygons)) %&amp;gt;%
  #ignore self matches
  filter(row.id != col.id) %&amp;gt;%
  mutate(id = 1:n()) %&amp;gt;%
  #remove the last 3 polygons
  top_frac(0.5, id)

polygons &amp;lt;- polygons[-duplicates$row.id,]

#replot
p4 &amp;lt;- ggplot() +
  geom_sf(data = polygons, fill = &amp;quot;dodgerblue&amp;quot;) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/remove_duplicate_polygons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And we have our 3 unique polygons. For a higher number n, we want to spin out and generalise two functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one to create points on a ‘page’&lt;/li&gt;
&lt;li&gt;one to build as many unique polygons as possible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To create points, we can pretty much verbatim take the previous code. I’ve added a second argument of how many points should lie within a perimeter triangle of points, though this will always be n-3 (where n &amp;gt; 3), as far as I can see.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#take our previous code for any n
create_points &amp;lt;- function(sides, within) {
  points &amp;lt;- data.frame(
    x = runif(sides - within),
    y = runif(sides - within)
  )
  perimeter &amp;lt;- sf_polygon(points)
  
  new_points &amp;lt;- data.frame(
    x = runif(within, min = min(points$x), max = max(points$x)),
    y = runif(within, min = min(points$y), max = max(points$y))
  )

  while(length(unlist(st_contains(perimeter, sf_point(new_points)))) != within) {
    new_points &amp;lt;- data.frame(
      x = runif(within, min = min(points$x), max = max(points$x)),
      y = runif(within, min = min(points$y), max = max(points$y))
    )
  }
  
  points &amp;lt;- rbind(points, new_points) %&amp;gt;%
    mutate(id = 1:n())
  return(points)
}

#run to create a pentagon
five_points &amp;lt;- create_points(5, 2)

#plot the five points
p5 &amp;lt;- ggplot() +
  geom_point(data = five_points, aes(x, y, fill = as.factor(id)),
             shape = 21, colour = &amp;quot;black&amp;quot;, size = 3) +
  scale_fill_discrete(guide = FALSE) +
  theme_minimal()

p5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/generalise_point_creation-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The second function (to test how many polygons can be drawn) needs two minor tweaks. Polygons are created as before, but to test for duplicates, we now take the smaller id each time, and also use st_is_valid() to check that the polygon does not contain any self-intersections (where lines cross each other).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create polygons for n points
get_unique_polygons &amp;lt;- function(points) {
  #create polygons as before
  sides &amp;lt;- nrow(points)
  routes &amp;lt;- permutations(sides, sides, 1:sides) %&amp;gt;%
    as.data.frame() %&amp;gt;%
    filter(V1 == 1)
  
  for(r in seq(nrow(routes))) {
    nodes &amp;lt;- as.numeric(routes[r,])
    sf_points &amp;lt;- points[nodes,]
    sf &amp;lt;- sf_polygon(sf_points)
    
    if(r == 1) {
      polygons &amp;lt;- sf
    } else {
      polygons &amp;lt;- rbind(polygons, sf)
    }
  }
  
  polygons$id &amp;lt;- 1:nrow(polygons)
  
  #find duplicate polygons
  duplicates &amp;lt;- as.data.frame(st_equals(polygons, polygons)) %&amp;gt;%
    filter(row.id != col.id) %&amp;gt;%
    mutate(smaller = case_when(
      row.id &amp;lt; col.id ~ row.id,
      col.id &amp;lt; row.id ~ col.id
    ))
  #always take the smaller id
  polygons &amp;lt;- polygons[polygons$id %in% duplicates$smaller,]
  #test for valid polygons
  #i.e. no self-intersections
  polygons &amp;lt;- polygons[st_is_valid(polygons),]
  
  return(polygons)
}

#create pentagons
pentagons &amp;lt;- get_unique_polygons(five_points)
#calculate and arrange by the area of each for aesthetics
pentagons$area &amp;lt;- st_area(pentagons)
pentagons &amp;lt;- pentagons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#plot the unique pentagons
p6 &amp;lt;- ggplot() +
  geom_sf(data = pentagons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id, nrow = 2)

p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/create_polygons_function-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So for 5 points, the answer seems to be 8 unique polygons that can be drawn.&lt;/p&gt;
&lt;p&gt;For higher n, I then ran these function repeatedly and found the largest number of polygons for any random allocation of points, I’ve used 6 here, but the number can be any. At n = 6 points it’s already struggling (my code here wasn’t written for efficiency) and at 7 is reaaalllly slow, so the loops can be arbitrarily large and run while you make dinner/watch TV etc.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#very dirty inefficient brute force code
all_n &amp;lt;- c()
n_points &amp;lt;- 6
for(i in 1:1){
  #randomly create points
  points &amp;lt;- create_points(n_points, n_points-3)
  #build polygons from these
  polygon &amp;lt;- get_unique_polygons(points)
  n &amp;lt;- nrow(polygon)
  all_n[i] &amp;lt;- n
  #report back from the loop
  print(paste(i, &amp;quot;loops run&amp;quot;))
  print(paste(&amp;quot;biggest n so far is&amp;quot;, max(all_n)))
  print(all_n)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1 loops run&amp;quot;
## [1] &amp;quot;biggest n so far is 24&amp;quot;
## [1] 24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While I was running this to check if I’d missed anything, I tried to solve the problem logically (but not analytically). It seemed clear that you want as many points within larger perimeter triangle of 3 points. It also seemed like you wanted to make sure that none of these points were on a straight line of 3 points (which would limit the number of possible connections of those 3 points). For n = 6 I settled on a slightly offset (by rounding errors) triangle-within-a-triangle&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#logic-created six points
six_points &amp;lt;- data.frame(
  x = c(0, 1, 0.55, 0.25, 0.75, 0.45),
  y = c(0, 0, sqrt(0.75), 0.22, 0.22, 0.65)
)


#plot the six points
p7 &amp;lt;- ggplot() +
  geom_point(data = six_points, aes(x, y),
             shape = 21, fill = &amp;quot;skyblue&amp;quot;, colour = &amp;quot;black&amp;quot;, size = 3) +
  theme_minimal()

p7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/six_points-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;if we pass these points through our function we find that it can create 29 unique polygons (the same number I found from ~100 loops of my brute force attack). Plotting them as before, these are:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test the six points and munge
heaxgons &amp;lt;- get_unique_polygons(six_points)
heaxgons$area &amp;lt;- st_area(heaxgons)
heaxgons &amp;lt;- heaxgons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#plot
p8 &amp;lt;- ggplot() +
  geom_sf(data = heaxgons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)
  
p8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/create_hexagons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This isn’t a proof, but I feel reasonably confident in this as the answer for the classic&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;extra-credit-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extra Credit&lt;/h2&gt;
&lt;p&gt;As mentioned, now we want to find this for 7 points creating heptagons. Given we can now fit 4 spare points inside our original triangle, I decided to see what would happen if you stretched the triangle-within-a-triangle and point the final point inside this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#logic-created seven points
#stretched y axis on point six
#point seven lies within new triangle
seven_points &amp;lt;- data.frame(
  x = c(0, 1, 0.55, 0.25, 0.75, 0.5, 0.45),
  y = c(0, 0, sqrt(0.75), 0.22, 0.22, 0.75, 0.65)
)

#munge our heptagons
heptagons &amp;lt;- get_unique_polygons(seven_points)
heptagons$area &amp;lt;- st_area(heptagons)
heptagons &amp;lt;- heptagons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#aaaaand plot
p9 &amp;lt;- ggplot() +
  geom_sf(data = heptagons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)
  
p9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/test_heptagon-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Again, running a brute force (though for few iterations as seven really stretches the inefficient code here), 91 polygons seems a common end point, which is pretty close. I think there’s probably a very limited error on the difference between 91 and 92 polygons, so I maybe got lucky. But who knows?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;final-answers&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Final Answers&lt;/h1&gt;
&lt;div id=&#34;express&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Express&lt;/h2&gt;
&lt;div id=&#34;section&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;0.5&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&#34;extra-credit-0.27-recurring&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;extra credit: 0.27 recurring&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;classic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Classic&lt;/h2&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;29&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;92&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Riddler 1st February 2019</title>
      <link>/post/riddler-1st-feb-2019/</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler-1st-feb-2019/</guid>
      <description>


&lt;div id=&#34;riddler-classic&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Riddler Classic&lt;/h1&gt;
&lt;p&gt;In my spare time &lt;a href=&#34;http://www.robert-hickman.eu/post/riddler-27th-april-2018/&#34;&gt;I enjoy solving&lt;/a&gt; &lt;a href=&#34;https://fivethirtyeight.com/tag/the-riddler/&#34;&gt;538’s The Riddler column&lt;/a&gt;. This week I had a spare few hours waiting for the Superbowl to start and decided to code up a solution to the latest problem to keep me busy.&lt;/p&gt;
&lt;p&gt;The question revolves around a card game in which whatever choice a player makes, they are likely to lose to a con artist. Formally this is phrased as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You meet someone on a street corner who’s standing at a table on which there are three decks of playing cards. He tells you his name is “Three Deck Monte.” Knowing this will surely end well, you inspect the decks. Each deck contains 12 cards …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Red Deck: four aces, four 9s, four 7s Blue Deck: four kings, four jacks, four 6s Black Deck: four queens, four 10s, four 8s The man offers you a bet: You pick one of the decks, he then picks a different one. You both shuffle your decks, and you compete in a short game similar to War. You each turn over cards one at a time, the one with a higher card wins that turn (aces are high), and the first to win five turns wins the bet. (There can’t be ties, as no deck contains any of the same cards as any other deck.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Should you take the bet? After all, you can pick any of the decks, which seems like it should give you an advantage against the dealer. If you take the bet, and the dealer picks the best possible counter deck each time, how often will you win?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Obviously if you’ve ever seen a trick like this you’ll know you shouldn’t. But what is the probability you lose?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(Rcpp)

#set up the parameters
deck_names &amp;lt;- c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;black&amp;quot;)
decks &amp;lt;- list(
  c(rep(14, 4), rep(9, 4), rep(7, 4)),
  c(rep(13, 4), rep(11, 4), rep(6, 4)),
  c(rep(12, 4), rep(10, 4), rep(8, 4))
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in tidy R we can easily simulate a game using a quickly written function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;play_game &amp;lt;- function(deck_player, deck_grifter) {
  #shuffle the decks
  deck_player &amp;lt;- sample(decks[[grep(deck_player, deck_names)]])
  deck_grifter &amp;lt;- sample(decks[[grep(deck_grifter, deck_names)]])
  
  #set the point to zero
  points_player &amp;lt;- 0
  points_grifter &amp;lt;- 0
  
  #set the turn to 0
  n &amp;lt;- 1
  
  #keep drawing cards until one player wins 5 times
  while(points_grifter &amp;lt; 5 &amp;amp; points_player &amp;lt; 5) {
    if(deck_player[n] &amp;gt; deck_grifter[n]) {
      points_player &amp;lt;- points_player + 1
    } else {
      points_grifter &amp;lt;- points_grifter + 1
    }
    
    #and update the turn 
    n &amp;lt;- n + 1
  }
  
  if(points_player &amp;gt; points_grifter) {
    return(1)
  } else {
    return(0)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, there’s not much learnt from just answering these question as easily/quickly as possible, so I frequently try and write out my solutions using the &lt;a href=&#34;https://cran.r-project.org/web/packages/Rcpp/index.html&#34;&gt;Rcpp package&lt;/a&gt; from Dirk Edelbuettel which allows for C++ integration into R.&lt;/p&gt;
&lt;p&gt;For problems like this it isn’t reaaalllly necessary, but it’s good practice nonetheless.&lt;/p&gt;
&lt;p&gt;The equivalent Rcpp function looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#first declare the type_of_output function_name(type_of_input argument) up top
cppFunction(&amp;#39;int play_gameC(NumericVector player_deck, NumericVector grifter_deck) {
  //shuffle the decks
  std::random_shuffle(player_deck.begin(), player_deck.end());
  std::random_shuffle(grifter_deck.begin(), grifter_deck.end());
  
  //initialise
  int turn = 0;
  int points_player = 0;
  int points_grifter = 0;

  //play each round
  while(points_player &amp;lt; 5 &amp;amp;&amp;amp; points_grifter &amp;lt; 5) {
    int player_card = player_deck(turn);
    int grifter_card = grifter_deck(turn);

    if(player_card &amp;gt; grifter_card)
    {
      points_player = points_player + 1;
    } 
    else 
    {
      points_grifter = points_grifter + 1;
    }

    turn = turn + 1;
  }
  
  //say default result =0 and update when player wins
  int result = 0;

  if(points_player &amp;gt; points_grifter) {
    result = result + 1;
  }

//return the game result
  return result;
}&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;all that’s left is to rerun this a load of times. Fortunately purrr makes this super easy&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create a df of all deck combinations
combinations &amp;lt;- data.frame(player_choice = deck_names,
                           grifter_choice = deck_names) %&amp;gt;%
    expand(player_choice, grifter_choice) %&amp;gt;%
    filter(player_choice != grifter_choice)

#choose how many games to play
number_of_games &amp;lt;- 10000

#find how often the player wins for each deck choice
results &amp;lt;- rerun(number_of_games,
                 map2(combinations$player_choice,
                      combinations$grifter_choice,
                      play_game)
                 ) %&amp;gt;%
  unlist(.) %&amp;gt;%
  matrix(ncol = number_of_games) %&amp;gt;%
  #as a proportion of games
  rowSums() / number_of_games 

#mutate this back onto the combinations
combinations &amp;lt;- combinations %&amp;gt;%
  mutate(win_chance = results) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 3
##   player_choice grifter_choice win_chance
##   &amp;lt;fct&amp;gt;         &amp;lt;fct&amp;gt;               &amp;lt;dbl&amp;gt;
## 1 black         blue                0.299
## 2 black         red                 0.701
## 3 blue          black               0.704
## 4 blue          red                 0.306
## 5 red           black               0.295
## 6 red           blue                0.709&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So whatever deck you pick you have a 70% chance of losing providing the grifter has memorized the winning counter-deck. What an unfortunate state of affairs.&lt;/p&gt;
&lt;p&gt;Giving we’ve written the C++ code (which I didn’t use in the end to run my model), it’s worth seeing what the speed advantage would have been. If you’re eagle-eyed you might notice that play_game and play_gameC have a slightly different way to defining the decks (the R function selects based on name in the first line) so I also wrote a play_gameR function that functions the same as the C++ one for a fairer comparison.&lt;/p&gt;
&lt;p&gt;We can benchmark these using the microbenchmark&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbenchmark)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: package &amp;#39;microbenchmark&amp;#39; was built under R version 3.5.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#we&amp;#39;ll just use deck1 vs deck2 for the example
deck1 &amp;lt;- decks[[1]]
deck2 &amp;lt;- decks[[2]]

microbenchmark(
  play_gameR(deck1, deck2),
  play_gameC(deck1, deck2),
  times = 10000
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: microseconds
##                      expr   min    lq      mean median     uq      max
##  play_gameR(deck1, deck2) 8.388 9.847 14.202272 10.576 13.858 7745.265
##  play_gameC(deck1, deck2) 1.094 1.459  2.333585  1.824  2.553  815.771
##  neval
##  10000
##  10000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can see that despite being very similar, the C++ code is much faster. For problems like this it makes no difference (a mean of 13 vs. 2ms isn’t going to be noticeable to a human except on very large numbers of reruns), but it’s fun to know how to get some free speed out of code in any case.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=8nTFjVm9sTQ&#34;&gt;Radiohead - House of Cards&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;riddler-express---can-you-escape-a-maze-without-walls&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Riddler Express - Can You Escape a Maze Without Walls&lt;/h1&gt;
&lt;p&gt;I also completed the riddler express which involves a maze. Obviously look away if you don’t want it spoiled, but the key is to work backwards and see there’s 1 clear fastest path. You can complete the maze in 42 moves. I’ve tried to show my messy working&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/riddler_maze.png&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
