<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>riddler on Robert Hickman</title>
    <link>/tags/riddler/</link>
    <description>Recent content in riddler on Robert Hickman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sun, 27 Sep 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/riddler/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Slicing the onion 3 ways- Toy problems in R, python, and Julia</title>
      <link>/post/riddler_nba_tour_de_frace/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler_nba_tour_de_frace/</guid>
      <description>


&lt;p&gt;Between writing up my thesis, applying to jobs &lt;a href=&#34;robwhickman@gmail.com&#34;&gt;hire me! I’m quite good at programming&lt;/a&gt;, and the ongoing pandemic, I don’t really have time to write full blogposts. I have however decided to brush up my python skills and dive headfirst into Julia. As such, I like to answer the toy problems posted at &lt;a href=&#34;https://fivethirtyeight.com/tag/the-riddler/&#34;&gt;fivethirtyeight’s riddler&lt;/a&gt; weekly. These will likely be even a few weeks late but it motivates me to tend to the blog and keep up my programming.&lt;/p&gt;
&lt;div id=&#34;express&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Express&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;From Zack Beamer comes a baffling brain teaser of basketball, just in time for the NBA playoffs:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Once a week, folks from Blacksburg, Greensboro, and Silver Spring get together for a game of pickup basketball. Every week, anywhere from one to five individuals will show up from each town, with each outcome equally likely.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Using all the players that show up, they want to create exactly two teams of equal size. Being a prideful bunch, everyone wears a jersey that matches the color mentioned in the name of their city. However, since it might create confusion to have one jersey playing for both sides, they agree that the residents of two towns will combine forces to play against the third town’s residents.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is the probability that, on any given week, it’s possible to form two equal teams with everyone playing, where two towns are pitted against the third?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Extra credit: Suppose that, instead of anywhere from one to five individuals per town, anywhere from one to N individuals show up per town. Now what’s the probability that there will be two equal teams?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a nice little combinatorics problem, as such we can solve it by finding all combinations and then the combinations where the maximum value is equal to the sum of the remaining values:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create lists of possible values for all team a, b, or c
players &amp;lt;- list(a = 1:5, b = 1:5, c = 1:5)
#find all combinations
player_combinations &amp;lt;- do.call(expand.grid, players)

#get the value of the largest team in each combination
largest_team &amp;lt;- apply(player_combinations, 1, max)
#get the sum of the remaining teams in each combination
reamining_players &amp;lt;- apply(player_combinations, 1, function(x) sum(x) - max(x))

#check when these match
matched_teams &amp;lt;- nrow(player_combinations[which(largest_team == reamining_players),])
#find the fraction which match
fraction_even_teams &amp;lt;- matched_teams / nrow(player_combinations)

fraction_even_teams&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the answer to the main express question is 0.24, or about 1 in 4 chance.&lt;/p&gt;
&lt;p&gt;It’s easy to expand this to multiple players by allowing the first line to take any value:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#rewrite previous chunk as function that takes max_players as an argument
find_matches_fraction &amp;lt;- function(max_players) {
  players &amp;lt;- list(a = seq(max_players), b = seq(max_players), c = seq(max_players))
  player_combinations &amp;lt;- do.call(expand.grid, players)
  
  largest_team &amp;lt;- apply(player_combinations, 1, max)
  reamining_players &amp;lt;- apply(player_combinations, 1, function(x) sum(x) - max(x))
  
  matched_teams &amp;lt;- nrow(player_combinations[which(largest_team == reamining_players),])
  fraction_even_teams &amp;lt;- matched_teams / nrow(player_combinations)
}

#run for n 1:50
fraction_even_teams &amp;lt;- lapply(seq(50), find_matches_fraction)

answers_df &amp;lt;- data.frame(
  townspeople = seq(50),
  chance = unlist(fraction_even_teams)
)

#for plotting
library(ggplot2)

#plot the answers for 1 to n players where max n is 50
p1 &amp;lt;- ggplot(answers_df, aes(x = townspeople, y = chance)) +
  geom_point() +
  geom_line() +
  labs(
    title = &amp;quot;solution to Riddler express&amp;quot;,
    subtitle = &amp;quot;chance of matched team with max n players&amp;quot;,
    x = &amp;quot;max N players per town&amp;quot;,
    y = &amp;quot;chance of even teams&amp;quot;
  ) +
  theme_minimal()

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/solve_express_r_extra-1.png&#34; width=&#34;672&#34; /&gt;
Let’s implement this in python. I won’t comment lines again, the flow of the function is fundamentally the same&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import itertools

def find_matches_fraction(max_players):
  team_a = range(1,max_players)
  team_b = range(1,max_players)
  team_c = range(1,max_players)
 
  matched_team = []
  for players in list(itertools.product(team_a,team_b,team_c)):
      largest_team = max(players)
     
      l_combinations = list(players)
      l_combinations.pop(l_combinations.index(max(l_combinations)))
      remaining_players = sum(l_combinations)
     
      if remaining_players == largest_team:
          matched_team.append(1)
      else:
          matched_team.append(0)
         
  fraction_success = sum(matched_team) / len(matched_team)
  return(fraction_success)

answer_express = find_matches_fraction(6)
print(answer_express)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in Julia&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using IterTools

function find_matches_fraction_jl(max_players)
  team_a = 1:max_players
  team_b = 1:max_players
  team_c = 1:max_players
 
  matched_teams = []

  for players in product(team_a, team_b, team_c)
    largest_team = maximum(players)
    other_teams = collect(players)
    deleteat!(other_teams, argmax(players))
    remaining_players = sum(other_teams)
   
    if largest_team == remaining_players
      push!(matched_teams, 1)
    else
      push!(matched_teams, 0)
    end
  end
  
  fraction_success = sum(matched_teams) / length(matched_teams)
  return fraction_success
end&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## find_matches_fraction_jl (generic function with 1 method)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;
answer_express = find_matches_fraction_jl(5);
answer_express&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also run these chunks in R using &lt;a href=&#34;https://rstudio.github.io/reticulate/&#34;&gt;reticulate&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/JuliaCall/readme/README.html&#34;&gt;JuliaCall&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#packages to call other languages into R
library(JuliaCall)
library(reticulate)

#run the functions to check answers
py$find_matches_fraction(as.integer(6))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;julia_eval(&amp;quot;find_matches_fraction_jl(5)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then use &lt;a href=&#34;https://www.rdocumentation.org/packages/microbenchmark/versions/1.4-7/topics/microbenchmark&#34;&gt;microbenchmark&lt;/a&gt; to test the speeds of the functions written here. We run each n times and look at the distribution of times spent running each.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#microbenchmark to time functions
library(microbenchmark)

#run each function 10000 times
n &amp;lt;- 10000
bench_express &amp;lt;- microbenchmark(
  jl = julia_eval(&amp;quot;find_matches_fraction_jl(5)&amp;quot;),
  py = py$find_matches_fraction(as.integer(6)),
  r = find_matches_fraction(5),
  times = n
)

#plot the speeds of each functions
p2 &amp;lt;- ggplot2::autoplot(bench_express) +
  labs(
    title = &amp;quot;benchmarking of functions for Riddler Express&amp;quot;
  ) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/benchmark_express-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I’m pretty happy with that. Even my rusty python ends up being faster than the R code (which I wrote for expressiveness and not speed per se), but my first ever solution in Julia outstrips both!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;classic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Classic&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;This month, the Tour de France is back, and so is the Tour de FiveThirtyEight!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;For every mountain in the Tour de FiveThirtyEight, the first few riders to reach the summit are awarded points. The rider with the most such points at the end of the Tour is named “King of the Mountains” and gets to wear a special polka dot jersey.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;At the moment, you are racing against three other riders up one of the mountains. The first rider over the top gets 5 points, the second rider gets 3, the third rider gets 2, and the fourth rider gets 1.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;All four of you are of equal ability — that is, under normal circumstances, you all have an equal chance of reaching the summit first. But there’s a catch — two of your competitors are on the same team. Teammates are able to work together, drafting and setting a tempo up the mountain. Whichever teammate happens to be slower on the climb will get a boost from their faster teammate, and the two of them will both reach the summit at the faster teammate’s time.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;As a lone rider, the odds may be stacked against you. In your quest for the polka dot jersey, how many points can you expect to win on this mountain, on average?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A quick guess can be gotten by assuming there were &lt;em&gt;no&lt;/em&gt; teams and just taking the expected points after random assignment&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;riders &amp;lt;- 4
points &amp;lt;- c(5,3,2,1)

sum(points/riders)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.75&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then work out the answer to the classic analytically by calculating the chance that the rider is bumped back a spot for any position they find themselves in. For instance, if they finish 2nd, there is a 1 in 2 chance the rider ahead of them is part of the team, which would bump our rider into 3rd to make run for the teammate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;expected_points &amp;lt;- 
  #first
  (points[1] / riders) + 
  #second
  (points[2] / riders)/(riders-1) + 2 * (points[(riders-1)] / riders)/(riders-1) + 
  #third
  (points[(riders-1)] / riders) / (riders-1) + 2 *(points[riders] / riders)/(riders-1) + 
  #last
  (points[riders] / riders)

expected_points&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.416667&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we have our answer, but what about for any combination of team and points? We can write an R function to assign riders to teams and simulating many races to get an estimate of the total points. We could again solve these analytically, but that wouldn’t really benefit my programming.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_team_points &amp;lt;- function(teams, points) {
  team_pos &amp;lt;- sample(unique(teams), length(unique(teams)), prob = table(teams))
  all_positions &amp;lt;- unlist(lapply(team_pos, function(p) rep(p, length(which(p == teams)))))
  team_points &amp;lt;- lapply(unique(teams), function(i) sum(points[which(all_positions == i)]))
  names(team_points) &amp;lt;- unique(teams)
  return(team_points)
}

sim_race &amp;lt;- function(n_riders, n_per_team = 2, points = c(5,3,2,1), times = 1000) {
  leftover_riders &amp;lt;- (n_riders-1) %% n_per_team
 
  teams &amp;lt;- (n_riders - leftover_riders - 1) / n_per_team
 
  teamed_riders &amp;lt;- c(
    rep(seq(teams), each = n_per_team),
    rep(max(teams)+1, leftover_riders),
    999
  )
 
  all_points &amp;lt;- c(
    points,
    rep(0, n_riders - length(points))
  )
 
  simmed_points &amp;lt;- unlist(purrr::rerun(times, get_team_points(teamed_riders, all_points)))
  expected_points &amp;lt;- tapply(simmed_points, names(simmed_points), sum) / times
  expected_points[names(expected_points) == 999]
}

expected_points &amp;lt;- sim_race(4, 2, points = c(5,3,2,1), times = 10000)
expected_points&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    999 
## 2.4093&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a range of n riders and team sizes, we can calculate our riders expected points per race (we’ll use the same point structure of c(1:n-1, n+1)) for a little extra flourish&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;riders &amp;lt;- 1:20
n_per_team &amp;lt;- 1:5

library(dplyr)

arguments &amp;lt;- expand.grid(riders, n_per_team) %&amp;gt;%
  dplyr::rename(n_riders = Var1, n_per_team = Var2) %&amp;gt;%
  #must be more riders than riders per team
  dplyr::filter(n_riders &amp;gt; n_per_team)
arguments$points &amp;lt;- lapply(arguments$n_riders, function(r) c(r+1, (r-1):1))

#use map2
library(purrr)

sims &amp;lt;- 1000
arguments$expected_points &amp;lt;- pmap_dbl(arguments, sim_race, times = sims)

#plot the expected points
p3 &amp;lt;- ggplot(arguments, aes(x = n_riders, y = n_per_team)) +
  geom_tile(aes(fill = expected_points / (n_riders+1))) +
  scale_fill_viridis_c(option = &amp;quot;plasma&amp;quot;, name = &amp;quot;expected points\n / max possible points&amp;quot;) +
  labs(
    title = &amp;quot;solution to Riddler classic&amp;quot;,
    subtitle = &amp;quot;expected points for our rider&amp;quot;,
    x = &amp;quot;total n riders&amp;quot;,
    y = &amp;quot;number of riders per team&amp;quot;
  ) +
  theme_minimal()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/extra_credit_classic-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Lets now port our function for this over the python…&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from numpy.random import choice
import numpy as np
import pandas as pd
import math
import itertools

def sim_race_py(n_riders, n_per_team, points):
  n_teams = math.ceil((n_riders - 1) / n_per_team) + 1
  filled_teams = math.floor((n_riders - 1) / n_per_team)
  leftover_riders = (n_riders - 1) % n_per_team
  
  if leftover_riders &amp;gt; 0:
    extra_riders = [leftover_riders, 1]
  else:
    extra_riders = 1
  
  if filled_teams == 1:
    win_prob = [n_per_team, extra_riders]
  else:
    win_prob = [n_per_team] * filled_teams
    win_prob.extend([extra_riders])
  flattened_probs = list(pd.core.common.flatten(win_prob))
  
  sum_probs = np.sum(flattened_probs)
  adjusted_probs = [p/sum_probs for p in flattened_probs]
  
  no_teams = list(range(len(flattened_probs)))
  
  finish_order = choice(no_teams, len(no_teams), p = adjusted_probs, replace = False)
  
  expanded_finish_order = []
  for team in finish_order:
   if team &amp;lt; filled_teams:
     expanded_finish_order += [team] * n_per_team
   else:
      if team != max(no_teams):
        expanded_finish_order += [team] * leftover_riders
      else:
        expanded_finish_order += [team]
  
  won_points = points[np.argmax(expanded_finish_order)]
  return won_points

def sim_races_py(n_riders, n_per_team, points, n_times):
  won_points = []
  for _ in range(n_times):
    sim_points = sim_race_py(n_riders, n_per_team, points)
    won_points.append(sim_points)
    expected_points = np.sum(won_points) / len(won_points)
    
  return(expected_points)
  
answer_classic = sim_races_py(4,2,[5,3,2,1], 10000)
print(answer_classic)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2.4286&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…and in Julia&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using StatsBase

function sim_race_jl(n_riders, n_per_team, points);
  n_teams = Int(ceil((n_riders - 1) / n_per_team));
  filled_teams = Int(floor((n_riders - 1) / n_per_team));
  leftover_riders = mod(n_riders - 1, n_per_team);
  
  if leftover_riders &amp;gt; 0
    extra_riders = [leftover_riders, 1];
  else
    extra_riders = 1;
  end
  
  if filled_teams == 1
    win_prob = vcat(n_per_team, extra_riders);
  else
    win_prob = vcat(repeat([n_per_team], filled_teams), extra_riders);
  end
  
  finish_order = sample(1:length(win_prob),
                        ProbabilityWeights(win_prob), 
                        length(win_prob), 
                        replace = false
  );
  
  expanded_finish_order = Vector{Int}();
  for team in finish_order
    if team &amp;lt;= filled_teams
       append!(expanded_finish_order, repeat([team], n_per_team));
    else
      if team != length(finish_order)
        append!(expanded_finish_order, repeat([team], leftover_riders));
      else
        append!(expanded_finish_order, team);
      end
    end
  end
  
  rider_position = findall(expanded_finish_order .== maximum(expanded_finish_order));
  points_won = points[rider_position];
return points_won
end&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## sim_race_jl (generic function with 1 method)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;
function sim_races_jl(n_riders, n_per_team, points, n_times);
  won_points = Vector{Int}();
  
  for _ in 1:n_times
    sim_points = sim_race_jl(n_riders, n_per_team, points);
    append!(won_points, sim_points);
  end
    
  expected_points = sum(won_points) / length(won_points);
    
  return expected_points;
end&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## sim_races_jl (generic function with 1 method)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;
answer_classic = sim_races_jl(4,2,[5,3,2,1], 10000);
answer_classic&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2.4098&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then lets benchmark each of these functions again&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#run each function 10000 times
n &amp;lt;- 10000

bench_classic &amp;lt;- microbenchmark(
  jl = julia_eval(&amp;quot;sim_race_jl(4,2,[5,3,2,1])&amp;quot;),
  py = py$sim_race_py(as.integer(4),as.integer(2),c(5,3,2,1)),
  r = sim_race(4,2,c(5,3,2,1), times = 1),
  times = n
)

#plot the speeds of each functions
p4 &amp;lt;- ggplot2::autoplot(bench_classic) +
  labs(
    title = &amp;quot;benchmarking of functions for Riddler Classic&amp;quot;
  ) +
  theme_minimal()

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/benchmark_classic-1.png&#34; width=&#34;672&#34; /&gt;
A bit closer this time. I think I haven’t quite got efficiency for more involved functions down for python and Julia. Julia still wins this round but I feel could be speed up by at least a factor 2 or 3x.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>The Riddler - June 26th</title>
      <link>/post/riddler_june_26th/</link>
      <pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler_june_26th/</guid>
      <description>


&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#for working with polygons
library(sf)
library(sfheaders)

library(tidyverse)
library(gtools)

set.seed(22081992)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;riddler-express&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Riddler Express&lt;/h1&gt;
&lt;p&gt;This weeks express deals with an erratic driver:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In Riddler City, the city streets follow a grid layout, running north-south and east-west. You’re driving north when you decide to play a little game. Every time you reach an intersection, you randomly turn left or right, each with a 50 percent chance.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;After driving through 10 intersections, what is the probability that you are still driving north?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So all we have to do is create a binomial tree of depth 10 and then sum by final heading direction. As the driver &lt;em&gt;must&lt;/em&gt; turn left or right at each junction, we actually only have to consider the final turn as this will change it from whichever North/South or East/West it is heading to the other with p = 0.5. But if we want to prove this, let’s consider it as a more canonical ball-drawing probability task where one can draw balls from a bag:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red (right) ball with probability p or&lt;/li&gt;
&lt;li&gt;Lime (left) ball with probability q&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;drawing balls 10 times without replacement&lt;/p&gt;
&lt;p&gt;We know that as there are only two balls, the total probability is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q) = 1 \]&lt;/span&gt;
on the first pick we are just choosing p or q so can raise everything to the power 1 (pick) to get the same formula:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^1 = 1^1 \]&lt;/span&gt;
and can generalise to n picks&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^n = 1^n \]&lt;/span&gt;
to expand this we’re going to get combinations of p and q to the powers from 0:n, multiplied by the combinatorics from &lt;a href=&#34;https://en.wikipedia.org/wiki/Pascal%27s_triangle&#34;&gt;Pascal’s triangle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If we set this multiplication as m, we can express this as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ m = \frac{n!}{(n-k!)k!} \]&lt;/span&gt;
(where k is 0:n)&lt;/p&gt;
&lt;p&gt;so for n = 10 (turns of the car, or picks of a ball), we get&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate pascals triangle via factorials
calc_pascal &amp;lt;- function(n,k) {
  factorial(n) / (factorial(n-k) * factorial(k))
}

#run for n turns
n_turns &amp;lt;- 10
m = map2_dbl(n_turns, 0:n_turns, calc_pascal)
m&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]   1  10  45 120 210 252 210 120  45  10   1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so for&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^{10}\]&lt;/span&gt;
we will expand this into&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ 1p^{10} + 10p^9q + 45p^8q^2 + 120 p^7q^3 + 210p^6q^4 + 252p^5q^5 + 210p^4q^6 + 120p^3q^7 + 45p^2q^8 + 10pq^9 + 1q^{10}\]&lt;/span&gt;
But where we now diverge from the balls in a bag, each time we draw (/turn), the position of our car updates. We don’t care about the probability of each of these per se, but the probabilities grouped by the final direction of the car.&lt;/p&gt;
&lt;p&gt;It should be clear that every p draw (a right turn), moves the car 1 cardinal direction to the right, whereas a left turn moves it -1 cardinal direction. In our expansion we have 210 examples of drawing 6 right turns and 4 left turns, which would end up having the car face due south (2 cardinal turns). For each term, we just have to minus the exponent of the left turns from the exponent of the right turns, then find the direction by taking the 4th modulus of this.&lt;/p&gt;
&lt;p&gt;For a binomial expansion like this, it’s very easy:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate the end heading for each term of the expansion
term_direction = (n_turns:0 - 0:n_turns) %% 4
term_direction&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 2 0 2 0 2 0 2 0 2 0 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so we’re either going to end up facing north (0 overall turn) or south (2 overall turns). We can then multiply these by the m for each term&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#list of cardinal direction
final_directions &amp;lt;- c(&amp;quot;north&amp;quot;, &amp;quot;east&amp;quot;, &amp;quot;south&amp;quot;, &amp;quot;west&amp;quot;)

#loop through each expansion term to get the final direction
direction_p &amp;lt;- c()
for(d in 0:3) {
  direction_p[d+1] &amp;lt;- sum(m[term_direction == d])
}

#find the probability of facing any direction
names(direction_p) &amp;lt;- final_directions
direction_p / sum(direction_p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## north  east south  west 
##   0.5   0.0   0.5   0.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so we have a 50% chance of ending up facing either north or south. So the answer to this weeks riddler express is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[p(North) = 0.5 \]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;extra-credit&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extra Credit&lt;/h2&gt;
&lt;p&gt;For extra credit, the driver decides instead to turn left, right, or continue straight with equal probability (1/3). In addition to p and q, we now also have an r probability where&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ r = p(No Turn) \]&lt;/span&gt;
We can then use expand.grid() to produce combinations of these three probabilities, and count the combinations by number of each of these:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find combinations of p, q, and r
extra_credit &amp;lt;- expand.grid(rep(list(c(&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;)), n_turns)) %&amp;gt;%
  #label each combination
  mutate(id = 1:n()) %&amp;gt;%
  #count numbers of p, q, and r
  pivot_longer(cols = starts_with(&amp;quot;Var&amp;quot;)) %&amp;gt;%
  group_by(id, value) %&amp;gt;%
  summarise(n = n()) %&amp;gt;%
  #pivot back to wide
  pivot_wider(id_cols = id, names_from = value, values_from = n) %&amp;gt;%
  mutate_at(c(&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;),  ~replace(., is.na(.), 0)) %&amp;gt;%
  #count numbers of each combination
  group_by(p, q, r) %&amp;gt;%
  summarise(n = n()) %&amp;gt;%
  arrange(n)

extra_credit&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 66 x 4
## # Groups:   p, q [66]
##        p     q     r     n
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
##  1     0     0    10     1
##  2     0    10     0     1
##  3    10     0     0     1
##  4     0     1     9    10
##  5     0     9     1    10
##  6     1     0     9    10
##  7     1     9     0    10
##  8     9     0     1    10
##  9     9     1     0    10
## 10     0     2     8    45
## # ... with 56 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we might expect, we get the same number of each combinations, but with 3x combinations for each x^n y^n (for each combination of p, q, and r). As we know that the final heading will be the difference in number of right and left turns, we can subtract these and count the number of combinations leading to each direction&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;extra_credit_answer &amp;lt;- extra_credit %&amp;gt;%
  mutate(net_turns = p - q) %&amp;gt;%
  mutate(final_direction = net_turns %% 4) %&amp;gt;%
  .$final_direction %&amp;gt;%
  table()

names(extra_credit_answer) &amp;lt;- final_directions
extra_credit_answer / sum(extra_credit_answer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     north      east     south      west 
## 0.2727273 0.2272727 0.2727273 0.2272727&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;giving us an answer of&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ p(North) = 0.\dot{2}\dot{7} \]&lt;/span&gt;
# Riddler Classic&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Polly Gawn loves to play “connect the dots.” Today, she’s playing a particularly challenging version of the game, which has six unlabeled dots on the page. She would like to connect them so that they form the vertices of a hexagon. To her surprise, she finds that there are many different hexagons she can draw, each with the same six vertices.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is the greatest possible number of unique hexagons Polly can draw using six points?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a pretty tricky question! I can’t see any way to analytically solve it and given that it involves polygons (and not just pure numbers) it seems like a tricky question to brute force. That doesn’t mean we can’t try though.&lt;/p&gt;
&lt;p&gt;Let’s start by using the data in the hint- that for n = 4 points, the maximum number is 3 polygons, given that the fourth point lies within an enclosing triangle of the other three. We can generate some points randomly for this pretty easily, and use the &lt;a href=&#34;https://r-spatial.github.io/sf/articles/sf1.html&#34;&gt;simple features&lt;/a&gt; package to test the properties of the resulting polygons:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#generate 3 random points
points &amp;lt;- data.frame(
  x = runif(3),
  y = runif(3)
)

#create a triangle from these points
triangle &amp;lt;- sf_polygon(points)

#randomly generate a fourth point within the bounding box of these points
new_point &amp;lt;- data.frame(
  x = runif(1, min = min(points$x), max = max(points$x)),
  y = runif(1, min = min(points$y), max = max(points$y))
)

#keep generate this point until it lies within the triangle of the previous 3
while(length(unlist(st_contains(triangle, sf_point(new_point)))) ==0) {
  new_point &amp;lt;- data.frame(
    x = runif(1, min = min(points$x), max = max(points$x)),
    y = runif(1, min = min(points$y), max = max(points$y))
  )
}

#bind the fourth point onto the previous 3
points &amp;lt;- rbind(points, new_point)

#plot the points
p2 &amp;lt;- ggplot() +
  #triangle
  geom_sf(data = triangle, alpha = 0.1) +
  geom_point(data = points, aes(x, y), 
             shape = 21, fill = &amp;quot;skyblue&amp;quot;, colour = &amp;quot;black&amp;quot;, size = 3) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/generate_four_points-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we need to brute force through every possible polygon. To do this we can use combinatorics again, this time with the permutations() function from the gtools package. We create every possible route of points, then take only the routes that start on the first point (to cut down our search space, as many routes will be the same just shifted to a different start node)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create all possible routes of 4 points
routes &amp;lt;- permutations(4, 4, 1:4) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  #filter those beginning with node 1
  filter(V1 == 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each route we then create the resulting polygon by ordering the points and creating a simple features polygon. These are then bound together and each given an id.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#cycle through routes to create polygons
for(r in seq(nrow(routes))) {
  nodes &amp;lt;- as.numeric(routes[r,])
  sf_points &amp;lt;- points[nodes,]
  sf &amp;lt;- sf_polygon(sf_points)
  
  if(r == 1) {
    polygons &amp;lt;- sf
  } else {
    polygons &amp;lt;- rbind(polygons, sf)
  }
}

polygons$id &amp;lt;- 1:nrow(polygons)

#plot the resulting polygons
p3 &amp;lt;- ggplot() +
  geom_sf(data = polygons, fill = &amp;quot;dodgerblue&amp;quot;) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/test_resulting_polygons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;However, we know that there are only 3 unique polygons for n = 4 points. Why have we found 6? From inspection it’s pretty clear that even though they all have unique paths, 3 of these are duplicates of 3 others. This occurs as for each starting node, there are two paths to create each polygon, a ‘clockwise’ path and an ‘anticlockwise’ one.&lt;/p&gt;
&lt;p&gt;We can easily test for this and remove half the polygons as such:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test for duplicate polygons
duplicates &amp;lt;- as.data.frame(st_equals(polygons, polygons)) %&amp;gt;%
  #ignore self matches
  filter(row.id != col.id) %&amp;gt;%
  mutate(id = 1:n()) %&amp;gt;%
  #remove the last 3 polygons
  top_frac(0.5, id)

polygons &amp;lt;- polygons[-duplicates$row.id,]

#replot
p4 &amp;lt;- ggplot() +
  geom_sf(data = polygons, fill = &amp;quot;dodgerblue&amp;quot;) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/remove_duplicate_polygons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And we have our 3 unique polygons. For a higher number n, we want to spin out and generalise two functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one to create points on a ‘page’&lt;/li&gt;
&lt;li&gt;one to build as many unique polygons as possible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To create points, we can pretty much verbatim take the previous code. I’ve added a second argument of how many points should lie within a perimeter triangle of points, though this will always be n-3 (where n &amp;gt; 3), as far as I can see.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#take our previous code for any n
create_points &amp;lt;- function(sides, within) {
  points &amp;lt;- data.frame(
    x = runif(sides - within),
    y = runif(sides - within)
  )
  perimeter &amp;lt;- sf_polygon(points)
  
  new_points &amp;lt;- data.frame(
    x = runif(within, min = min(points$x), max = max(points$x)),
    y = runif(within, min = min(points$y), max = max(points$y))
  )

  while(length(unlist(st_contains(perimeter, sf_point(new_points)))) != within) {
    new_points &amp;lt;- data.frame(
      x = runif(within, min = min(points$x), max = max(points$x)),
      y = runif(within, min = min(points$y), max = max(points$y))
    )
  }
  
  points &amp;lt;- rbind(points, new_points) %&amp;gt;%
    mutate(id = 1:n())
  return(points)
}

#run to create a pentagon
five_points &amp;lt;- create_points(5, 2)

#plot the five points
p5 &amp;lt;- ggplot() +
  geom_point(data = five_points, aes(x, y, fill = as.factor(id)),
             shape = 21, colour = &amp;quot;black&amp;quot;, size = 3) +
  scale_fill_discrete(guide = FALSE) +
  theme_minimal()

p5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/generalise_point_creation-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The second function (to test how many polygons can be drawn) needs two minor tweaks. Polygons are created as before, but to test for duplicates, we now take the smaller id each time, and also use st_is_valid() to check that the polygon does not contain any self-intersections (where lines cross each other).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create polygons for n points
get_unique_polygons &amp;lt;- function(points) {
  #create polygons as before
  sides &amp;lt;- nrow(points)
  routes &amp;lt;- permutations(sides, sides, 1:sides) %&amp;gt;%
    as.data.frame() %&amp;gt;%
    filter(V1 == 1)
  
  for(r in seq(nrow(routes))) {
    nodes &amp;lt;- as.numeric(routes[r,])
    sf_points &amp;lt;- points[nodes,]
    sf &amp;lt;- sf_polygon(sf_points)
    
    if(r == 1) {
      polygons &amp;lt;- sf
    } else {
      polygons &amp;lt;- rbind(polygons, sf)
    }
  }
  
  polygons$id &amp;lt;- 1:nrow(polygons)
  
  #find duplicate polygons
  duplicates &amp;lt;- as.data.frame(st_equals(polygons, polygons)) %&amp;gt;%
    filter(row.id != col.id) %&amp;gt;%
    mutate(smaller = case_when(
      row.id &amp;lt; col.id ~ row.id,
      col.id &amp;lt; row.id ~ col.id
    ))
  #always take the smaller id
  polygons &amp;lt;- polygons[polygons$id %in% duplicates$smaller,]
  #test for valid polygons
  #i.e. no self-intersections
  polygons &amp;lt;- polygons[st_is_valid(polygons),]
  
  return(polygons)
}

#create pentagons
pentagons &amp;lt;- get_unique_polygons(five_points)
#calculate and arrange by the area of each for aesthetics
pentagons$area &amp;lt;- st_area(pentagons)
pentagons &amp;lt;- pentagons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#plot the unique pentagons
p6 &amp;lt;- ggplot() +
  geom_sf(data = pentagons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id, nrow = 2)

p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/create_polygons_function-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So for 5 points, the answer seems to be 8 unique polygons that can be drawn.&lt;/p&gt;
&lt;p&gt;For higher n, I then ran these function repeatedly and found the largest number of polygons for any random allocation of points, I’ve used 6 here, but the number can be any. At n = 6 points it’s already struggling (my code here wasn’t written for efficiency) and at 7 is reaaalllly slow, so the loops can be arbitrarily large and run while you make dinner/watch TV etc.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#very dirty inefficient brute force code
all_n &amp;lt;- c()
n_points &amp;lt;- 6
for(i in 1:1){
  #randomly create points
  points &amp;lt;- create_points(n_points, n_points-3)
  #build polygons from these
  polygon &amp;lt;- get_unique_polygons(points)
  n &amp;lt;- nrow(polygon)
  all_n[i] &amp;lt;- n
  #report back from the loop
  print(paste(i, &amp;quot;loops run&amp;quot;))
  print(paste(&amp;quot;biggest n so far is&amp;quot;, max(all_n)))
  print(all_n)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1 loops run&amp;quot;
## [1] &amp;quot;biggest n so far is 24&amp;quot;
## [1] 24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While I was running this to check if I’d missed anything, I tried to solve the problem logically (but not analytically). It seemed clear that you want as many points within larger perimeter triangle of 3 points. It also seemed like you wanted to make sure that none of these points were on a straight line of 3 points (which would limit the number of possible connections of those 3 points). For n = 6 I settled on a slightly offset (by rounding errors) triangle-within-a-triangle&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#logic-created six points
six_points &amp;lt;- data.frame(
  x = c(0, 1, 0.55, 0.25, 0.75, 0.45),
  y = c(0, 0, sqrt(0.75), 0.22, 0.22, 0.65)
)


#plot the six points
p7 &amp;lt;- ggplot() +
  geom_point(data = six_points, aes(x, y),
             shape = 21, fill = &amp;quot;skyblue&amp;quot;, colour = &amp;quot;black&amp;quot;, size = 3) +
  theme_minimal()

p7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/six_points-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;if we pass these points through our function we find that it can create 29 unique polygons (the same number I found from ~100 loops of my brute force attack). Plotting them as before, these are:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test the six points and munge
heaxgons &amp;lt;- get_unique_polygons(six_points)
heaxgons$area &amp;lt;- st_area(heaxgons)
heaxgons &amp;lt;- heaxgons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#plot
p8 &amp;lt;- ggplot() +
  geom_sf(data = heaxgons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)
  
p8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/create_hexagons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This isn’t a proof, but I feel reasonably confident in this as the answer for the classic&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;extra-credit-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extra Credit&lt;/h2&gt;
&lt;p&gt;As mentioned, now we want to find this for 7 points creating heptagons. Given we can now fit 4 spare points inside our original triangle, I decided to see what would happen if you stretched the triangle-within-a-triangle and point the final point inside this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#logic-created seven points
#stretched y axis on point six
#point seven lies within new triangle
seven_points &amp;lt;- data.frame(
  x = c(0, 1, 0.55, 0.25, 0.75, 0.5, 0.45),
  y = c(0, 0, sqrt(0.75), 0.22, 0.22, 0.75, 0.65)
)

#munge our heptagons
heptagons &amp;lt;- get_unique_polygons(seven_points)
heptagons$area &amp;lt;- st_area(heptagons)
heptagons &amp;lt;- heptagons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#aaaaand plot
p9 &amp;lt;- ggplot() +
  geom_sf(data = heptagons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)
  
p9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/test_heptagon-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Again, running a brute force (though for few iterations as seven really stretches the inefficient code here), 91 polygons seems a common end point, which is pretty close. I think there’s probably a very limited error on the difference between 91 and 92 polygons, so I maybe got lucky. But who knows?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;final-answers&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Final Answers&lt;/h1&gt;
&lt;div id=&#34;express&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Express&lt;/h2&gt;
&lt;div id=&#34;section&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;0.5&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&#34;extra-credit-0.27-recurring&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;extra credit: 0.27 recurring&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;classic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Classic&lt;/h2&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;29&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;92&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Riddler 1st February 2019</title>
      <link>/post/riddler-1st-feb-2019/</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler-1st-feb-2019/</guid>
      <description>


&lt;div id=&#34;riddler-classic&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Riddler Classic&lt;/h1&gt;
&lt;p&gt;In my spare time &lt;a href=&#34;http://www.robert-hickman.eu/post/riddler-27th-april-2018/&#34;&gt;I enjoy solving&lt;/a&gt; &lt;a href=&#34;https://fivethirtyeight.com/tag/the-riddler/&#34;&gt;538’s The Riddler column&lt;/a&gt;. This week I had a spare few hours waiting for the Superbowl to start and decided to code up a solution to the latest problem to keep me busy.&lt;/p&gt;
&lt;p&gt;The question revolves around a card game in which whatever choice a player makes, they are likely to lose to a con artist. Formally this is phrased as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You meet someone on a street corner who’s standing at a table on which there are three decks of playing cards. He tells you his name is “Three Deck Monte.” Knowing this will surely end well, you inspect the decks. Each deck contains 12 cards …&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Red Deck: four aces, four 9s, four 7s Blue Deck: four kings, four jacks, four 6s Black Deck: four queens, four 10s, four 8s The man offers you a bet: You pick one of the decks, he then picks a different one. You both shuffle your decks, and you compete in a short game similar to War. You each turn over cards one at a time, the one with a higher card wins that turn (aces are high), and the first to win five turns wins the bet. (There can’t be ties, as no deck contains any of the same cards as any other deck.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Should you take the bet? After all, you can pick any of the decks, which seems like it should give you an advantage against the dealer. If you take the bet, and the dealer picks the best possible counter deck each time, how often will you win?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Obviously if you’ve ever seen a trick like this you’ll know you shouldn’t. But what is the probability you lose?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(Rcpp)

#set up the parameters
deck_names &amp;lt;- c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;black&amp;quot;)
decks &amp;lt;- list(
  c(rep(14, 4), rep(9, 4), rep(7, 4)),
  c(rep(13, 4), rep(11, 4), rep(6, 4)),
  c(rep(12, 4), rep(10, 4), rep(8, 4))
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;in tidy R we can easily simulate a game using a quickly written function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;play_game &amp;lt;- function(deck_player, deck_grifter) {
  #shuffle the decks
  deck_player &amp;lt;- sample(decks[[grep(deck_player, deck_names)]])
  deck_grifter &amp;lt;- sample(decks[[grep(deck_grifter, deck_names)]])
  
  #set the point to zero
  points_player &amp;lt;- 0
  points_grifter &amp;lt;- 0
  
  #set the turn to 0
  n &amp;lt;- 1
  
  #keep drawing cards until one player wins 5 times
  while(points_grifter &amp;lt; 5 &amp;amp; points_player &amp;lt; 5) {
    if(deck_player[n] &amp;gt; deck_grifter[n]) {
      points_player &amp;lt;- points_player + 1
    } else {
      points_grifter &amp;lt;- points_grifter + 1
    }
    
    #and update the turn 
    n &amp;lt;- n + 1
  }
  
  if(points_player &amp;gt; points_grifter) {
    return(1)
  } else {
    return(0)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, there’s not much learnt from just answering these question as easily/quickly as possible, so I frequently try and write out my solutions using the &lt;a href=&#34;https://cran.r-project.org/web/packages/Rcpp/index.html&#34;&gt;Rcpp package&lt;/a&gt; from Dirk Edelbuettel which allows for C++ integration into R.&lt;/p&gt;
&lt;p&gt;For problems like this it isn’t reaaalllly necessary, but it’s good practice nonetheless.&lt;/p&gt;
&lt;p&gt;The equivalent Rcpp function looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#first declare the type_of_output function_name(type_of_input argument) up top
cppFunction(&amp;#39;int play_gameC(NumericVector player_deck, NumericVector grifter_deck) {
  //shuffle the decks
  std::random_shuffle(player_deck.begin(), player_deck.end());
  std::random_shuffle(grifter_deck.begin(), grifter_deck.end());
  
  //initialise
  int turn = 0;
  int points_player = 0;
  int points_grifter = 0;

  //play each round
  while(points_player &amp;lt; 5 &amp;amp;&amp;amp; points_grifter &amp;lt; 5) {
    int player_card = player_deck(turn);
    int grifter_card = grifter_deck(turn);

    if(player_card &amp;gt; grifter_card)
    {
      points_player = points_player + 1;
    } 
    else 
    {
      points_grifter = points_grifter + 1;
    }

    turn = turn + 1;
  }
  
  //say default result =0 and update when player wins
  int result = 0;

  if(points_player &amp;gt; points_grifter) {
    result = result + 1;
  }

//return the game result
  return result;
}&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;all that’s left is to rerun this a load of times. Fortunately purrr makes this super easy&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create a df of all deck combinations
combinations &amp;lt;- data.frame(player_choice = deck_names,
                           grifter_choice = deck_names) %&amp;gt;%
    expand(player_choice, grifter_choice) %&amp;gt;%
    filter(player_choice != grifter_choice)

#choose how many games to play
number_of_games &amp;lt;- 10000

#find how often the player wins for each deck choice
results &amp;lt;- rerun(number_of_games,
                 map2(combinations$player_choice,
                      combinations$grifter_choice,
                      play_game)
                 ) %&amp;gt;%
  unlist(.) %&amp;gt;%
  matrix(ncol = number_of_games) %&amp;gt;%
  #as a proportion of games
  rowSums() / number_of_games 

#mutate this back onto the combinations
combinations &amp;lt;- combinations %&amp;gt;%
  mutate(win_chance = results) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 3
##   player_choice grifter_choice win_chance
##   &amp;lt;fct&amp;gt;         &amp;lt;fct&amp;gt;               &amp;lt;dbl&amp;gt;
## 1 black         blue                0.299
## 2 black         red                 0.701
## 3 blue          black               0.704
## 4 blue          red                 0.306
## 5 red           black               0.295
## 6 red           blue                0.709&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So whatever deck you pick you have a 70% chance of losing providing the grifter has memorized the winning counter-deck. What an unfortunate state of affairs.&lt;/p&gt;
&lt;p&gt;Giving we’ve written the C++ code (which I didn’t use in the end to run my model), it’s worth seeing what the speed advantage would have been. If you’re eagle-eyed you might notice that play_game and play_gameC have a slightly different way to defining the decks (the R function selects based on name in the first line) so I also wrote a play_gameR function that functions the same as the C++ one for a fairer comparison.&lt;/p&gt;
&lt;p&gt;We can benchmark these using the microbenchmark&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbenchmark)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Warning: package &amp;#39;microbenchmark&amp;#39; was built under R version 3.5.2&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#we&amp;#39;ll just use deck1 vs deck2 for the example
deck1 &amp;lt;- decks[[1]]
deck2 &amp;lt;- decks[[2]]

microbenchmark(
  play_gameR(deck1, deck2),
  play_gameC(deck1, deck2),
  times = 10000
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: microseconds
##                      expr   min    lq      mean median     uq      max
##  play_gameR(deck1, deck2) 8.388 9.847 14.202272 10.576 13.858 7745.265
##  play_gameC(deck1, deck2) 1.094 1.459  2.333585  1.824  2.553  815.771
##  neval
##  10000
##  10000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can see that despite being very similar, the C++ code is much faster. For problems like this it makes no difference (a mean of 13 vs. 2ms isn’t going to be noticeable to a human except on very large numbers of reruns), but it’s fun to know how to get some free speed out of code in any case.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=8nTFjVm9sTQ&#34;&gt;Radiohead - House of Cards&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;riddler-express---can-you-escape-a-maze-without-walls&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Riddler Express - Can You Escape a Maze Without Walls&lt;/h1&gt;
&lt;p&gt;I also completed the riddler express which involves a maze. Obviously look away if you don’t want it spoiled, but the key is to work backwards and see there’s 1 clear fastest path. You can complete the maze in 42 moves. I’ve tried to show my messy working&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/img/riddler_maze.png&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
