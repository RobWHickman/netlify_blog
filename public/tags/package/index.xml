<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>package on Robert Hickman</title>
    <link>/tags/package/</link>
    <description>Recent content in package on Robert Hickman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Sun, 09 Sep 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/package/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>sf.chlorodot mini-package</title>
      <link>/post/sf.schlorodot/</link>
      <pubDate>Sun, 09 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/sf.schlorodot/</guid>
      <description>


&lt;p&gt;Recently, I’d seen two tweets with stunning examples of maps by Paul Campbell &lt;a href=&#34;https://twitter.com/PaulCampbell91/status/992043182996193280&#34;&gt;here&lt;/a&gt; and (taken inspiration from the first) by Imer Muhović &lt;a href=&#34;https://twitter.com/ImerM1/status/1037358973807210498&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The basic idea of the dot chloropleths is to visualise not only the location clustering of each variable but the number of observations (something traditional ‘filled’ chloropleths don’t do). More importantly than this, the maps also just look really really cool.&lt;/p&gt;
&lt;p&gt;I had a spare few minutes during work on Friday which I tidied up into a package to calculate the random position of dots for such maps which can be found &lt;a href=&#34;https://github.com/RobWHickman/sf.chlorodot&#34;&gt;on my github&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Below, I’ll outline the code for the South African example used in the package README. Data comes from Adrian Frith’s &lt;a href=&#34;https://census2011.adrianfrith.com/&#34;&gt;very good 2011 census site&lt;/a&gt; and &lt;a href=&#34;https://gadm.org/download_country_v3.html&#34;&gt;gadm&lt;/a&gt; for the shapefiles.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(sf)
library(ggplot2)
library(tidyverse)
library(data.table)
library(rvest)

devtools::install_github(&amp;#39;RobWHickman/sf.chlorodot&amp;#39;)
library(sf.chlordot)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next, download and scrape the data for the map&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#download the South African shapefile fom gadm
admin_url &amp;lt;- &amp;quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_ZAF_3_sf.rds&amp;quot;
download.file(admin_url, destfile = &amp;quot;shapefiles.rds&amp;quot;, mode = &amp;quot;wb&amp;quot;)
south_africa &amp;lt;- readRDS(&amp;quot;shapefiles.rds&amp;quot;) %&amp;gt;%
  #convert to sf
  st_as_sf() %&amp;gt;%
  select(region = NAME_3) %&amp;gt;%
  #merge geometries that have two rows
  group_by(region) %&amp;gt;%
  summarise()

#get the links to the data from Adrian Frith&amp;#39;s site
sa_data_url &amp;lt;- &amp;quot;https://census2011.adrianfrith.com&amp;quot;
south_africa_data &amp;lt;- sa_data_url %&amp;gt;%
  read_html() %&amp;gt;% html_nodes(&amp;quot;.namecell a&amp;quot;) %&amp;gt;% html_attr(&amp;quot;href&amp;quot;) %&amp;gt;% paste0(sa_data_url, .) %&amp;gt;%
  lapply(., function(x) read_html(x) %&amp;gt;% html_nodes(&amp;quot;.namecell a&amp;quot;) %&amp;gt;% html_attr(&amp;quot;href&amp;quot;) %&amp;gt;% paste0(sa_data_url, .)) %&amp;gt;% unlist() %&amp;gt;%
   lapply(., function(x) read_html(x) %&amp;gt;% html_nodes(&amp;quot;.namecell a&amp;quot;) %&amp;gt;% html_attr(&amp;quot;href&amp;quot;) %&amp;gt;% paste0(sa_data_url, .)) %&amp;gt;% unlist()

#scrape the data on primary language from the 2011 South African census
language_data &amp;lt;- rbindlist(lapply(south_africa_data, function(x) {
  read &amp;lt;- read_html(x)
  language_nos &amp;lt;- read %&amp;gt;% html_nodes(&amp;quot;.datacell&amp;quot;) %&amp;gt;% html_text()
  start &amp;lt;- grep(&amp;quot;Percentage&amp;quot;, language_nos)[3] + 1
  stop &amp;lt;- grep(&amp;quot;Population&amp;quot;, language_nos) - 1
  #some areas have no data
  if(!is.na(start) &amp;amp; !is.na(stop)) {
    language_nos &amp;lt;- language_nos[start:stop]
    language_nos &amp;lt;- language_nos[seq(1, length(language_nos), 2)]
  } else {
    language_nos &amp;lt;- NA
  }
  
  languages &amp;lt;- read %&amp;gt;% html_nodes(&amp;quot;tr &amp;gt; :nth-child(1)&amp;quot;) %&amp;gt;% html_text()
  start &amp;lt;- grep(&amp;quot;First language&amp;quot;, languages) + 1
  stop &amp;lt;- grep(&amp;quot;Name&amp;quot;, languages) - 1
  if(length(start) &amp;gt; 0 &amp;amp; !is.na(stop)) {
    languages &amp;lt;- languages[start:stop]
  } else {
    languages &amp;lt;- NA
  }
  
  region_names &amp;lt;- read %&amp;gt;% html_nodes(&amp;quot;.topname&amp;quot;) %&amp;gt;% html_text()
  
  #combine into a df
  df &amp;lt;- data.frame(language = languages, primary_speakers = language_nos, region = region_names)
  return(df)
}))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;the lanaguage data then needs to be transformed before the dot position is calculated. It must be in ‘short’ format with variables as column names. At the same time we can do some cleaning in order to match the shape areas with the region names from the census and remove data we don’t want to plot&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;language_data %&amp;lt;&amp;gt;%
  #convert number of speakers to numeric
  mutate(primary_speakers = as.numeric(as.character(primary_speakers))) %&amp;gt;%
  #matching of area names with South African shapefile
  mutate(region = gsub(&amp;quot; NU&amp;quot;, &amp;quot;&amp;quot;, region)) %&amp;gt;%
  mutate(region = gsub(&amp;quot;Tshwane&amp;quot;, &amp;quot;City of Tshwane&amp;quot;, region)) %&amp;gt;%
  #filter only the data we want to merge
  filter(region %in% south_africa$region) %&amp;gt;%
  filter(!is.na(language)) %&amp;gt;%
  filter(language != &amp;quot;Not applicable&amp;quot;) %&amp;gt;%
  #spread the data
  dcast(., region ~ language, value.var = &amp;quot;primary_speakers&amp;quot;, fun.aggregate = sum) %&amp;gt;%
  #join in the spatial geometry
  left_join(., south_africa) %&amp;gt;%
  #convert to sf
  st_as_sf()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then we can calculate the random dot position using calc_dots() from the sf.chlorodot package. This takes three arguments. The first is the df to take the data from (language_data). The second is which variables to calculate positions for. The easiest way to do this is to use names(df) and select from there, though a character vector can also be passed. Finally, n_per_dot is the number of observations (speakers of language x) for each dot on the map. This will affect the look of the map, but also the processing time (lower n_per_dot = greater time) so play around with it a bit.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate the dot positions using calc_dots from the sf.chlorodot package
sf_dots &amp;lt;- calc_dots(df = language_data, col_names = names(language_data)[2:14], n_per_dot = 1000)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can plot the output of this&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#stolen the background colour scheme from Paul Campbell&amp;#39;s blog
#original inspiration for this package
p &amp;lt;- ggplot() +
  geom_sf(data = south_africa, fill = &amp;quot;transparent&amp;quot;,colour = &amp;quot;white&amp;quot;) +
  geom_point(data = sf_dots, aes(lon, lat, colour = variable), size = 0.1) +
  scale_colour_discrete(name = &amp;quot;Primary Language&amp;quot;) +
  ggtitle(&amp;quot;Language Diversity in South Africa&amp;quot;) +
  theme_void() +
  guides(colour = guide_legend(override.aes = list(size = 10))) +
  theme(plot.background = element_rect(fill = &amp;quot;#212121&amp;quot;, color = NA), 
        panel.background = element_rect(fill = &amp;quot;#212121&amp;quot;, color = NA),
        legend.background = element_rect(fill = &amp;quot;#212121&amp;quot;, color = NA),
        text =  element_text(color = &amp;quot;white&amp;quot;),
        title =  element_text(color = &amp;quot;white&amp;quot;),
        legend.text=element_text(size=12),
        plot.title = element_text(size = 20),
        plot.margin = margin(1, 1, 1, 1, &amp;quot;cm&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;../../img/south_africa.png&#34; alt=&#34;chlorodot map of South African languages&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Enjoy!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Riddler 27th April 2018</title>
      <link>/post/riddler-27th-april-2018/</link>
      <pubDate>Tue, 01 May 2018 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler-27th-april-2018/</guid>
      <description>


&lt;p&gt;I’ve been looking for small programming problems to practice on while running experiments. One such source is &lt;a href=&#34;https://fivethirtyeight.com/features/how-fast-can-you-type-a-million-letters/&#34;&gt;Fivethirtyeight’s Riddler&lt;/a&gt; column which posts conundrums weekly. This week one problem focus on one of life’s universal problems: how many urinals are needed in any bathroom for all patrons to use it without awkwardness.&lt;/p&gt;
&lt;p&gt;Formally this is phrased as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Some number, N, of people need to pee, and there is some number, M, of urinals in a row in a men’s room. The people always follow a rule for which urinal they select: The first person goes to one on either far end of the row, and the rest try to maximize the number of urinals between them and any other person. So the second person will go on the other far end, the third person in the middle, and so on. They continue to occupy the urinals until one person would have to go directly next to another person, at which point that person decides not to go at all.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;What’s the minimum number, M, of urinals required to accommodate all the N people at the same time?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Which is perhaps easiest explained using the ‘urinal etiquette’ meme:&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/urinal_etiquette.png&#34; /&gt;

&lt;/div&gt;
&lt;p&gt;Luckily, this sort of problem is extremely tractable in R to get an estimate of the function for any 1:N people with a few simple loops:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#just going to use dplyr and purr
#data.table might be faster but not too worried- verbose programming anyway
library(dplyr)
library(purrr)

#a tip from colin fay
#https://tinyurl.com/colin-fay-purrr
`%not_in%` &amp;lt;- negate(`%in%`)

#start with n = 1 and with a bathroom with 1 urinal
n &amp;lt;- 1
urinal_number &amp;lt;- 1

#create a df with 1 urinal which is unoccupied
urinals_df &amp;lt;- data.frame(urinal = 1:urinal_number,
                         occupied = rep(NA, urinal_number))

#for how many n do we want to solve
while(n &amp;lt; 101) {
  #whilst not all n have a urinal to use loop through
  while(sum(urinals_df$occupied, na.rm = TRUE) &amp;lt; n) {
    #when all are unoccupied take the first urinal
    if(sum(urinals_df$occupied, na.rm = TRUE) == 0) {
      urinals_df$occupied[1] &amp;lt;- 1
    #when all but 1 are unoccupied and there are more than 2 urinals
    #take the opposite end one next
    } else if(sum(urinals_df$occupied, na.rm = TRUE) == 1 &amp;amp;
              nrow(urinals_df) &amp;gt; 2) {
      urinals_df$occupied[nrow(urinals_df)] &amp;lt;- 1
    #otherwise work out the most isolated free urinal
    } else {
      #get the distances from each urinal to all the occupied urinals
      urinal_distances &amp;lt;- abs(1:nrow(urinals_df) - 
                                rep(which(!is.na(urinals_df$occupied)), each = nrow(urinals_df))) %&amp;gt;%
        matrix(., nrow = length(!is.na(urinals_df$occupied)))
      #index
      rownames(urinal_distances) &amp;lt;- 1:nrow(urinal_distances)  
      
      #awkward urinals are ones that are either taken or next to taken urinals
      #don&amp;#39;t want to urinate there
      awkward &amp;lt;- c(which(urinal_distances == 1, arr.ind = TRUE)[,1], 
                   which(urinal_distances == 0, arr.ind = TRUE)[,1]) %&amp;gt;%
        unique()
      
      #use %not_in% to find free urinals that aren&amp;#39;t in an awkward position
      possible_urinals &amp;lt;- which(rownames(urinal_distances) %not_in% awkward)
      
      #if only one remains use this urinal
      if(length(possible_urinals) == 1) {
        taken_urinal &amp;lt;- possible_urinals
      } else if(length(possible_urinals) &amp;gt; 1) {
        #for the remaining possible urinals find how far the closest taken urinal is
        #initialise a small nameless func
        closest_distance &amp;lt;- lapply(seq(nrow(urinal_distances)), function(x){
          row &amp;lt;- urinal_distances[x,]
          min &amp;lt;- min(row)
          }) %&amp;gt;%
          unlist()
        
        #use the urinal that has the maximum distance to its closest urinal
        taken_urinal &amp;lt;- as.numeric(rownames(urinal_distances)[which.max(closest_distance)])
      } else if(length(possible_urinals) == 0) {
        #if there are no free urinals break the loop
        #and add one to the urinal number in the hypothetical bathroom
        urinal_number &amp;lt;- urinal_number + 1
        break
      }
      #occupy the chosen urinal
      urinals_df$occupied[taken_urinal] &amp;lt;- 1
    }
  }
  
  #if completed
  #i.e. if all users have found a satisfactory free urinal
  if(sum(urinals_df$occupied, na.rm = TRUE) == n) {
    if(n == 1) {
      #when n = 1 initial a df to hold the results per n
      results_df &amp;lt;- data.frame(n = 1,
                               urinals_required = urinal_number)
    } else {
      #otherwise add in a new row to results_df
      results_df &amp;lt;- rbind(results_df, data.frame(n = n, urinals_required = urinal_number))
    }
      #increase n to the next number of patrons
      n &amp;lt;- n + 1
      #start with at least n urinals in the next bathroom
      #this is the bare minimum we would need
      urinal_number &amp;lt;- n
  }
  
  #reintialise the bathroom to see if it is big enough for the n patrons
  urinals_df &amp;lt;- data.frame(urinal = 1:urinal_number,
                           occupied = rep(NA, urinal_number))
  
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then plot this. I decided to add a little flair to the plot using annotate_custom which is a nice little trick to spice up ggplots&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#load the libraries for plotting
library(ggplot2)
library(png)
library(grid)

#a nice png of a urinal I found online
urinal_image &amp;lt;- readPNG(&amp;quot;../../static/img/urinal.png&amp;quot;) %&amp;gt;%
  rasterGrob()

#plot the number of urinals needed for any n number of patrons
urinals_plot &amp;lt;- ggplot(data = results_df, aes(x = n, y = urinals_required)) + 
  geom_point() +
  #mapply a function to paste the urinal image as an annotation to the graph
  #takes the x and y arguments from the ggplot aesthetic
  mapply(function(x, y, size) {
    annotation_custom(urinal_image,
                      xmin = x - size, xmax = x + size, 
                      ymin = y - size, ymax = y + size) },
    x = results_df$n, y = results_df$urinals_required, size = 7) +
  #labelling and etc.
  ylab(&amp;quot;Urinals Required&amp;quot;) +
  xlab(&amp;quot;Number of Patrons&amp;quot;) +
  ggtitle(&amp;quot;How many urinals are needed for any n number of socially awkward urinators&amp;quot;,
          subtitle = &amp;quot;answer to The Riddler 27/04/2018&amp;quot;) +
  theme(panel.background = element_rect(fill = &amp;#39;lightblue&amp;#39;))

urinals_plot&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2018-05-01-riddler-27th-april-2018_files/figure-html/unnamed-chunk-2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;which gives a surprisingly complex function! I had assume it would be some simple function of x but clearly something more complex is going on.&lt;/p&gt;
&lt;p&gt;Why this happens become clear if you plot out why M urinals are needed for N people. Optimally each person would be separated by 1 urinal, but as the number of urinals increases they become less efficiently packed, with 2 urinals (neither of which can be used without standing next to someone) between each urinating person. This eventually reaches a breaking point and the number of urinals necessary jumps upward.&lt;/p&gt;
&lt;p&gt;The formula is known as ‘The Pay Phone Packing Sequence’ (where users of pay phones don’t want to be overheard) and is summarised at &lt;a href=&#34;https://oeis.org/A185456&#34; class=&#34;uri&#34;&gt;https://oeis.org/A185456&lt;/a&gt; (where packing occurs/ n &amp;gt; 2). The formula itself is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[f(n) = n + 2 ^ {(1 + floor(log(n - 2)))}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;That’s all for this weeks riddler.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=l3V4KfeJBCQ&#34;&gt;Franz Ferdinand and Sparks - Piss Off&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
