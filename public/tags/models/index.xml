<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>models on Robert Hickman</title>
    <link>/tags/models/</link>
    <description>Recent content in models on Robert Hickman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Thu, 30 May 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/tags/models/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>An Introduction to Modelling Soccer Matches in R (part 1)</title>
      <link>/post/dixon_coles_1/</link>
      <pubDate>Thu, 30 May 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/dixon_coles_1/</guid>
      <description>


&lt;p&gt;For anyone watching football, being able to predict matches is a key aspect of the hobby. Whether explicitly (e.g. when betting on matches, or deciding on recruitment for an upcoming season), or more implicitly when discussing favourites to win the league in the pub, almost all discussion of the sport on some level require predictions about some set of upcoming games.&lt;/p&gt;
&lt;p&gt;The first step of prediction is some form of quantification of ability. We’d expect a better team to have a better chance of winning than a worse team. For an example of a more sophisticated set of rankings, see &lt;a href=&#34;https://projects.fivethirtyeight.com/soccer-predictions/&#34;&gt;fivethirtyeight’s Soccer Power Index&lt;/a&gt; which is explicitly used to predict the results of various football competitions.&lt;/p&gt;
&lt;p&gt;The accuracy of our predictions therefore relies on the accuracy of our judgement on team’s ability. When discussing football with friends, we might use half-remembered match highlights to form some impression of how strong a team is. When programming however, we have free access to the results of teams thus far in a campaign and should be able to produce a model more grounded in truth.&lt;/p&gt;
&lt;p&gt;Two seminal papers for using recent football results to assess the abilities of football teams (and then use this assessment to predict matches) are &lt;a href=&#34;https://onlinelibrary.wiley.com/doi/abs/10.1111/j.1467-9574.1982.tb00782.x&#34;&gt;Maher’s 1982 paper&lt;/a&gt; on modelling football scores, which is complimented by &lt;a href=&#34;https://www.jstor.org/stable/pdf/2986290.pdf?casa_token=9deLgF7xOaEAAAAA:fGGfUQKOsezrWBvbmphK56HddtiaohxaUNPdkDBoTApL_beghKXFlru5USztLt7dDVEMSdhAfkg8yzubZsAs7eeyZvp307iAGwqAtVSMMhwk6xhUleM&#34;&gt;Mark Dixon and Stuart Coles’ 1997 paper&lt;/a&gt;. For R various packages to use the methods outlined in these papers exist including &lt;a href=&#34;https://github.com/Torvaney/regista&#34;&gt;Ben Torvaney’s regista&lt;/a&gt;, &lt;a href=&#34;https://github.com/opisthokonta/goalmodel&#34;&gt;opisthokonta’s goalmodel&lt;/a&gt;&lt;sup&gt;1&lt;/sup&gt;, and &lt;a href=&#34;https://cran.r-project.org/web/packages/fbRanks/index.html&#34;&gt;Eli Holmes’ fbRanks&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;However, the overlap between people obsessed enough with football to read mathematical papers on the sport, and those with the formal training in reading math notation to understand these models is fairly low, and I wasn’t able to find&lt;sup&gt;2&lt;/sup&gt; a good intuitive explanation for these models. Hopefully, building up these models from the most basic entry steps to a fully sophisticated model for predicting football matches might help some who want to start modelling football but don’t have the privilege of formal stats/modelling/coding training. As I want to start from pretty much zero, in this first post I make at least one or two claims that are not strictly true (indeed, this post does not actually implement some of the main points of the 1997 Dixon &amp;amp; Coles paper), but will try to point these out as I go, and correct them in later posts.&lt;/p&gt;
&lt;p&gt;First, let’s load libraries and also set a seed for the reproducibility of this document&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# munging
library(tidyverse)

# seed for reproducibility
set.seed(3459)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;##Set up&lt;/p&gt;
&lt;p&gt;In reality, we’d probably want to model a whole league or cup. However, these can generally contain 20+ teams, many of which will have similar abilities. For simplicity here, lets instead imagine a summer league between 6 English football clubs where each team plays each other twice (once at home and once away)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;teams &amp;lt;- c(&amp;quot;Arsenal&amp;quot;, # 5th in the 1st tier
           &amp;quot;Blackburn_Rovers&amp;quot;, # 15th in 2nd tier
           &amp;quot;Coventry_City&amp;quot;, # 8th in 3rd tier
           &amp;quot;Dover_Athletic&amp;quot;, # 14th 5th tier 
           &amp;quot;Enfield_Town&amp;quot;, # 10th in 7th tier
           &amp;quot;Frimley_Green&amp;quot;) # 2nd in 9th tier&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve managed to arrange a league that has a nice stratification between teams, so we’d expect each to be comfortably better than the next best (which will make sanity checking our results easier). Lucky for us, the teams are also in alphabetical order of strength so in case you don’t have any prior on a team, take the first letter of it’s name (A-F).&lt;/p&gt;
&lt;p&gt;Each week each team play one game, so we’ll have a fixture list that looks like:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(fixtures, 8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               home             away gameweek
## 1    Frimley_Green          Arsenal        1
## 2     Enfield_Town Blackburn_Rovers        1
## 3   Dover_Athletic    Coventry_City        1
## 4          Arsenal     Enfield_Town        2
## 5    Frimley_Green   Dover_Athletic        2
## 6 Blackburn_Rovers    Coventry_City        2
## 7   Dover_Athletic          Arsenal        3
## 8    Coventry_City     Enfield_Town        3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Obviously for this we’re going to have to make up our data. For the code used to generate it, see the bottom of the post.&lt;/p&gt;
&lt;p&gt;Let’s say that we’ve had 8 weeks of games played so far, and the results have been as follows&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(results,8)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               home             away hgoal agoal gameweek
## 1   Dover_Athletic    Coventry_City     0     3        1
## 2     Enfield_Town Blackburn_Rovers     0     3        1
## 3    Frimley_Green          Arsenal     0     8        1
## 4          Arsenal     Enfield_Town     5     0        2
## 5 Blackburn_Rovers    Coventry_City     1     1        2
## 6    Frimley_Green   Dover_Athletic     1     2        2
## 7 Blackburn_Rovers    Frimley_Green     6     0        3
## 8    Coventry_City     Enfield_Town     2     1        3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A better way to show this is to generate a matrix of home (y axis) vs. away (x axis) and show the goals scored in each match between them:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- results %&amp;gt;%
  # remove unplayed games
  filter(!is.na(hgoal)) %&amp;gt;%
  ggplot(., aes(x = away, y = home, fill = hgoal-agoal)) +
  geom_tile() +
  # add the scorelines
  geom_label(aes(label = paste(hgoal, agoal, sep = &amp;quot;-&amp;quot;)), fill = &amp;quot;white&amp;quot;) +
  # colour where green shows home win and red an away win
  scale_fill_gradient2(low = &amp;quot;darkred&amp;quot;, high = &amp;quot;green&amp;quot;, midpoint = 0, guide = FALSE) +
  scale_x_discrete(limits = levels(results$home), position = &amp;quot;top&amp;quot;) +
  scale_y_discrete(limits = rev(levels(results$away))) +
  theme_minimal()

# plot
p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-1_files/figure-html/plot_results-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;As the colour gradient (from bottom right to top left) shows, the teams we’d expect to do better are. Given the stochastic nature of football though, there are some surprises. E.g. Blackburn only managing to draw at home to Coventry.&lt;/p&gt;
&lt;p&gt;A good sense of teams relative abilities can be seen in the league table of results so far (assuming 3 points for a win, and 1 for a draw):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# function to melt results
# returns df with team and goals for and against for each match
melt_results &amp;lt;- function(results_df) {
  results_df %&amp;gt;%
    # select only relevant columns
    select(home, away, hgoal, agoal) %&amp;gt;%
    gather(location, team,  -hgoal, -agoal) %&amp;gt;%
    # calculate goals for/against the team
    mutate(g_for = case_when(
      location == &amp;quot;home&amp;quot; ~ hgoal,
      location == &amp;quot;away&amp;quot; ~ agoal
    )) %&amp;gt;%
    mutate(g_ag = case_when(
      location == &amp;quot;home&amp;quot; ~ agoal,
      location == &amp;quot;away&amp;quot; ~ hgoal
    )) 
}

# function to calculate points won and gd for each team
results_to_table &amp;lt;- function(results_df) {
  results_df %&amp;gt;%
    # use above melting function
    melt_results(.) %&amp;gt;%
    # 3 points for a win, 1 for a draw
    mutate(points = case_when(
      g_for &amp;gt; g_ag ~ 3,
      g_ag &amp;gt; g_for ~ 0,
      g_for == g_ag ~ 1
    )) %&amp;gt;%
    # calculate goal difference for each match
    mutate(gd = g_for - g_ag) %&amp;gt;%
    group_by(team) %&amp;gt;%
    # get the final statistics per team
    summarise(games_played = n(),
              gf = sum(g_for),
              ga = sum(g_ag),
              gd = sum(gd),
              points = sum(points)) %&amp;gt;%
    arrange(-points, -gd, -gf)
}

# calculate league table for our played fixtures
league_table &amp;lt;- results  %&amp;gt;%
  filter(!is.na(hgoal)) %&amp;gt;%
  select(-gameweek) %&amp;gt;%
  results_to_table(.) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##   team             games_played    gf    ga    gd points
##   &amp;lt;chr&amp;gt;                   &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1 Arsenal                     8    39     4    35     24
## 2 Blackburn_Rovers            8    23     6    17     19
## 3 Coventry_City               8    14     8     6     16
## 4 Dover_Athletic              8     8    15    -7      9
## 5 Enfield_Town                8     6    22   -16      3
## 6 Frimley_Green               8     2    37   -35      0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where teams positions are nicely rank ordered (the data for this example is fairly curated so it’s not that surprising).&lt;/p&gt;
&lt;p&gt;##Predictions&lt;/p&gt;
&lt;p&gt;With two rounds to go, there’s still 6 fixtures we might want to predict (to try and judge which team will end up where, or just to bet on the remaining games).&lt;/p&gt;
&lt;p&gt;This are:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# get the yet to be played matches
unplayed_games &amp;lt;- fixtures %&amp;gt;%
  filter(gameweek &amp;gt; 8) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               home             away gameweek
## 1    Coventry_City          Arsenal        9
## 2 Blackburn_Rovers   Dover_Athletic        9
## 3    Frimley_Green     Enfield_Town        9
## 4          Arsenal Blackburn_Rovers       10
## 5    Coventry_City    Frimley_Green       10
## 6   Dover_Athletic     Enfield_Town       10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we want to predict these results, we need to have data on the strength of the teams above, but also, a good prior on what sort of scores we should expect.&lt;/p&gt;
&lt;p&gt;Using real data from the engsoccerdata package we can get the results of all 48840 English football league games between August 1992 and May 2016. If we melt this to get the goals scored by each team by their location we get a data.frame of 97680 records of a teams performance in a game:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# load real data from the english league
real_data &amp;lt;- engsoccerdata::england %&amp;gt;%
  # filter out &amp;#39;premier league era&amp;#39; matches
  filter(Season &amp;gt; 1991) %&amp;gt;%
  # select only relevant columns
  select(home, away = visitor, hgoal, agoal = vgoal) %&amp;gt;%
  # munge
  melt_results() %&amp;gt;%
  select(-hgoal, -agoal) %&amp;gt;%
  mutate(data = &amp;quot;real&amp;quot;)

head(real_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   location           team g_for g_ag data
## 1     home        Arsenal     2    4 real
## 2     home        Chelsea     1    1 real
## 3     home  Coventry City     2    1 real
## 4     home Crystal Palace     3    3 real
## 5     home        Everton     1    1 real
## 6     home   Ipswich Town     1    1 real&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Here every row shows a team that played a match (as it’s sorted by league then alphabetically, the first 6 records are all for Arsenal). It also shows if the team played home or away. The data also shows the goals scored by (e.g.) Arsenal in g_for, and the goals they conceded in g_ag.&lt;/p&gt;
&lt;p&gt;If we plot the goals scored for each game, we get a nice humped distribution with slightly offset peaks for home and away. That is to say, in most games teams will score 0, 1, or 2 goals, and that scoring more than 6 goals in a match is incredibly rare. The difference between the home and away distributions mean that teams are slightly more likely to score more if playing at home, compared to play away from home.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# plot goals scored home/away for real english football matches
p2 &amp;lt;- real_data %&amp;gt;%
  ggplot(., aes(x = g_for, fill = location)) +
  # smooth densities
  geom_density(adjust = 8, alpha = 0.5) +
  scale_fill_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;)) +
  scale_x_continuous(breaks = 0:6) +
  labs(title = &amp;quot;Goals scored at home and away in English football&amp;quot;,
       subtitle = &amp;quot;data from 48.8k matches 1992-2016&amp;quot;,
       x = &amp;quot;goals scored&amp;quot;,
       y = &amp;quot;density&amp;quot;) +
  theme_minimal()

# plot
p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-1_files/figure-html/plot_real_goal_distributions-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can work out what the average difference between playing at home and away is by taking the means of goals scored at home, and when playing away:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calculate mean home and away goals
real_data_means &amp;lt;- real_data %&amp;gt;%
    group_by(location) %&amp;gt;%
    summarise(mean_scored = mean(g_for)) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
##   location mean_scored
##   &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 away            1.12
## 2 home            1.47&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Goals in games are both relatively sparse, and relatively stochastic; football is a low scoring game where goals are evenly distributed throughout the game. In theory any attack made by a team i has a probability of being scored dependent upon the strength of team i’s attack (α&lt;sub&gt;i&lt;/sub&gt;) which is independent of all the other attacks that team has made.&lt;/p&gt;
&lt;p&gt;(there is some reason to doubt this may be the case&lt;sup&gt;3&lt;/sup&gt;, but for now this is a fine generalisation)&lt;/p&gt;
&lt;p&gt;By grouping all teams together into “home” and “away” categories (in a league setting each team will play each other home and away so this should average out) and taking the average number of goals scored per match as the Poisson mean (λ) we can see how well our above graph fits a simulated Poisson process.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# generate Poisson distributed vector with mean = real world mean
simulated_poisson &amp;lt;- real_data_means %&amp;gt;%
  split(f = .$location) %&amp;gt;%
  lapply(., function(x) df = data.frame(dist = rpois(100000, x$mean_scored),
                                        location = x$location)) %&amp;gt;%
  # map it all together and label
  map_df(I) %&amp;gt;%
  mutate(data = &amp;quot;simulated&amp;quot;) 

# add these distributions to the plot
p2 + geom_density(data = simulated_poisson, aes(x = dist),
                  fill = NA, adjust = 8, alpha = 0.2) +
  scale_fill_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;), guide = FALSE) +
  facet_wrap(~location)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-1_files/figure-html/simulated_poisson-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It’s not perfect, but it’s not a bad fit either. In actuality, a Chi-squared test will show that goals scored &lt;em&gt;does not&lt;/em&gt; follow a Poisson distribution given the number of matches we have as data. But for the sake of this post, put that out of mind.&lt;/p&gt;
&lt;p&gt;If we think that goals scored represents some Poisson process, it can be modeled using the equation which underlies the Poisson distribution. For a given interval (one match), the probability of x events (goals scored) in that interval will be:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[P(x) = \frac{\lambda^{x}e^{-\lambda}}{x!}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The simplest model we can produce is to estimate λ as each team’s attack rating (henceforth α&lt;sub&gt;i&lt;/sub&gt;) which is equal to observed mean rate of goals for that team.&lt;/p&gt;
&lt;p&gt;That is the say the probability of team i scoring x goals against team j is:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[P(x_{i,j} = x) = \frac{\alpha_{i}^{x}e^{-\alpha_{i}}}{x!}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where α&lt;sub&gt;i&lt;/sub&gt; is the sum of all goals scored divided by the total number of matches:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\alpha_{i} = \frac{1}{N}\sum_{n=1}^{N} x\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;grouping by teams makes this easy to calculate:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;basic_model &amp;lt;- results %&amp;gt;%
  melt_results() %&amp;gt;%
  group_by(team) %&amp;gt;%
  # we&amp;#39;ll use the goals scored to model the attack
  # and goals conceeded to measure defence rating
  summarise(alpha = mean(g_for),
            beta = mean(g_ag)) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 3
##   team             alpha  beta
##   &amp;lt;chr&amp;gt;            &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 Arsenal           4.88  0.5 
## 2 Blackburn_Rovers  2.88  0.75
## 3 Coventry_City     1.75  1   
## 4 Dover_Athletic    1     1.88
## 5 Enfield_Town      0.75  2.75
## 6 Frimley_Green     0.25  4.62&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(we’ll come on to the beta parameter in a bit- where alpha is the average scoring rate, beta is the average conceding rate).&lt;/p&gt;
&lt;p&gt;If we take Coventry’s remaining two games as examples we can see that they are yet to play Arsenal and Frimley Green at home&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;coventry_games &amp;lt;- unplayed_games %&amp;gt;%
  # filter out Coventry City&amp;#39;s remaining fixtures
  filter(grepl(&amp;quot;Coventry_City&amp;quot;, home)) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##            home          away gameweek
## 1 Coventry_City       Arsenal        9
## 2 Coventry_City Frimley_Green       10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can take the attack rating (α) of each team and use it to estimate the results&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# get the attack ratings of all teams
team_alphas &amp;lt;- basic_model$alpha %&amp;gt;% `names&amp;lt;-`(basic_model$team)

# assume goals scored for each team will be it&amp;#39;s attack rating
e_results &amp;lt;- paste(team_alphas[coventry_games$home],
                   team_alphas[coventry_games$away],
                   sep = &amp;quot;-&amp;quot;) %&amp;gt;%
  # name each match with the teams competing
  `names&amp;lt;-`(c(paste(coventry_games$home, coventry_games$away, sep = &amp;quot;-&amp;quot;))) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       Coventry_City-Arsenal Coventry_City-Frimley_Green 
##                &amp;quot;1.75-4.875&amp;quot;                 &amp;quot;1.75-0.25&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;These aren’t ridiculous estimates by any stretch but it’s clear something is up. It’s pretty intuitive that Coventry City would be expected to score more goals at home to Frimley Green than at home to Arsenal.&lt;/p&gt;
&lt;p&gt;We can account for this by introducing an opposing team defence parameter β&lt;sub&gt;j&lt;/sub&gt;. In our very simple model this will be estimating by taking the average rate a team concedes goals. As with the attack rating, this is the calculated as the sum of all goals conceded divided by number of matches. We’ll then multiply α&lt;sub&gt;i&lt;/sub&gt; and β&lt;sub&gt;j&lt;/sub&gt; together to get the score estimate:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# get and name the defence rating for each team
team_betas &amp;lt;- basic_model$beta %&amp;gt;% `names&amp;lt;-`(basic_model$team)

# assume the goals scored will be the attack rating of the team times 
# the defence rating of it&amp;#39;s opponent
e_results &amp;lt;- paste(round(team_alphas[coventry_games$home]*
                           team_betas[coventry_games$away], 3),
                   round(team_alphas[coventry_games$away]*
                           team_betas[coventry_games$home], 3),
                   sep = &amp;quot;-&amp;quot;) %&amp;gt;%
  `names&amp;lt;-`(c(paste(coventry_games$home, coventry_games$away, sep = &amp;quot;-&amp;quot;))) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       Coventry_City-Arsenal Coventry_City-Frimley_Green 
##               &amp;quot;0.875-4.875&amp;quot;                &amp;quot;8.094-0.25&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The opposition scores remain the same because Coventry have on average conceded 1 goal per game.&lt;/p&gt;
&lt;p&gt;Coventry’s predicted goals though has diverged with them now predicted to score less than a goal against Arsenal and to score 8(!) against Frimley Green, both of which sound reasonable (when you consider that Frimley Green are a team of amateurs).&lt;/p&gt;
&lt;p&gt;However, we’re also missing one final piece of the model we’ll finish with today. Recall modelling the English football data from 1992 onwards, we were left with a difference between the home scoring rate and the away scoring rate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# reprint what we calculated earlier
real_data_means&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 2
##   location mean_scored
##   &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 away            1.12
## 2 home            1.47&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s pretty common knowledge that football teams do better at home, so we’ll want to factor that in. A simple estimate is to divide the mean home goals/game by the mean away goals/game.&lt;/p&gt;
&lt;p&gt;We’ll call this parameter γ and can be formalised as the sum of home goals (which we’ll refer to as x from now on) divided by the sum of away goals (y)&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\gamma = \frac{\sum{x}}{\sum{y}}\]&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# the home advantage is how much easier it is to score at home
home_advantage_gamma &amp;lt;- sum(results$hgoal) / sum(results$agoal)

e_results &amp;lt;- paste(round(team_alphas[coventry_games$home]*
                           team_betas[coventry_games$away] * 
                           # add in home advantage for home team
                           home_advantage_gamma, 3),
                   round(team_alphas[coventry_games$away]*
                           team_betas[coventry_games$home], 3),
                   sep = &amp;quot;-&amp;quot;) %&amp;gt;%
  `names&amp;lt;-`(c(paste(coventry_games$home, coventry_games$away, sep = &amp;quot;-&amp;quot;))) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##       Coventry_City-Arsenal Coventry_City-Frimley_Green 
##               &amp;quot;0.955-4.875&amp;quot;                 &amp;quot;8.83-0.25&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which tilts the scales a little towards Coventry’s favour but (as we’d expect- home advantage can only go so far) doesn’t affect the results too much.&lt;/p&gt;
&lt;p&gt;Now we have a method to predict matches, we can use this on the remaining 6 nice and easily:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# simplify to just gamma
gamma &amp;lt;- home_advantage_gamma

# wrap the above into a function for home and away teams
predict_results &amp;lt;- function(home, away, parameters) {
  e_goals_home &amp;lt;- parameters$alpha[home]*parameters$beta[away] * gamma
  e_goals_away &amp;lt;- parameters$alpha[away]*parameters$beta[home]
  
  # output a df of expected goals for home and away teams
  df &amp;lt;- data.frame(home = home, away = away,
                   e_hgoal = e_goals_home, e_agoal = e_goals_away)
  return(df)
}

# convert the basic_model df into a list with $attack and $defence parameters
# for each team
basic_parameters &amp;lt;- basic_model %&amp;gt;%
  # rename scored/conceeded to attack/defence
  select(-team) %&amp;gt;%
  # convert to a list and name each element
  as.list() %&amp;gt;%
  lapply(., function(x){names(x) &amp;lt;- teams;return(x)})

# predict results using the function defined above and the list of parameters
# could use e.g. mapply here but I prefer the map2 grammar
# run the predict results function over each game consisting of $home and $away
predicted_fixtures &amp;lt;- map2_df(unplayed_games$home, unplayed_games$away, 
                    predict_results,
                    # parameters forms an extra argument that does not vary
                    basic_parameters) %&amp;gt;%
  # round the outputs
  mutate_if(is.numeric, round, digits = 2) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               home             away e_hgoal e_agoal
## 1    Coventry_City          Arsenal    0.95    4.88
## 2 Blackburn_Rovers   Dover_Athletic    5.88    0.75
## 3    Frimley_Green     Enfield_Town    0.75    3.47
## 4          Arsenal Blackburn_Rovers    3.99    1.44
## 5    Coventry_City    Frimley_Green    8.83    0.25
## 6   Dover_Athletic     Enfield_Town    3.00    1.41&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All of which look reasonable, if maybe a little bullish on the ‘better’ teams prospects.&lt;/p&gt;
&lt;p&gt;However, while this is good for back of the envelope predictions, we know that this is a very basic model. If we want to improve it, first we must quantify how good it is.&lt;/p&gt;
&lt;p&gt;In order to do this we can use the results we have from the first 8 weeks of matches as training data. We know what the ‘correct’ scores are for these matches, so if our model is good, it will predict similar scores to those observed.&lt;/p&gt;
&lt;p&gt;Remember that for the Poisson distribution, the probability of x goals in one match is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[P(x) = \frac{\lambda^{x}e^{-\lambda}}{x!}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The expected value of the Poisson distribution is equal to λ, so we can plug λ as our predicted goals, and x as the actual goals, and calculate the probability of that results occurring &lt;em&gt;given&lt;/em&gt; the attack/defence/home advantage parameters that we think are correct.&lt;/p&gt;
&lt;p&gt;We then do this for all the matches played and get the likelihood for the home and away teams scores given the model:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# &amp;#39;predict&amp;#39; the already played matches using our function
predicted_results &amp;lt;- map2_df(results$home, results$away, 
                    predict_results,
                    basic_parameters) %&amp;gt;%
  mutate_if(is.numeric, round, digits = 2) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                home             away e_hgoal e_agoal
## 1    Dover_Athletic    Coventry_City    1.09    3.28
## 2      Enfield_Town Blackburn_Rovers    0.61    7.91
## 3     Frimley_Green          Arsenal    0.14   22.55
## 4           Arsenal     Enfield_Town   14.62    0.38
## 5  Blackburn_Rovers    Coventry_City    3.14    1.31
## 6     Frimley_Green   Dover_Athletic    0.51    4.62
## 7  Blackburn_Rovers    Frimley_Green   14.51    0.19
## 8     Coventry_City     Enfield_Town    5.25    0.75
## 9    Dover_Athletic          Arsenal    0.55    9.14
## 10          Arsenal    Coventry_City    5.32    0.88
## 11   Dover_Athletic Blackburn_Rovers    0.82    5.39
## 12     Enfield_Town    Frimley_Green    3.78    0.69
## 13 Blackburn_Rovers          Arsenal    1.57    3.66
## 14     Enfield_Town   Dover_Athletic    1.53    2.75
## 15    Frimley_Green    Coventry_City    0.27    8.09
## 16          Arsenal    Frimley_Green   24.60    0.12
## 17 Blackburn_Rovers     Enfield_Town    8.62    0.56
## 18    Coventry_City   Dover_Athletic    3.58    1.00
## 19    Coventry_City Blackburn_Rovers    1.43    2.88
## 20   Dover_Athletic    Frimley_Green    5.05    0.47
## 21     Enfield_Town          Arsenal    0.41   13.41
## 22          Arsenal   Dover_Athletic    9.97    0.50
## 23     Enfield_Town    Coventry_City    0.82    4.81
## 24    Frimley_Green Blackburn_Rovers    0.20   13.30&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# calculate the likelihood of each home/away team actually scoring that many goals
# given the parameters for attack/defence supplied
likelihoods &amp;lt;- data.frame(lik_hgoal = dpois(results$hgoal,
                                            predicted_results$e_hgoal),
                          lik_agoal = dpois(results$agoal,
                                            predicted_results$e_agoal)) %&amp;gt;%
  # round the probabilities
  mutate_all(round, 4) %&amp;gt;%
  # bind likelihoods to results
  cbind(results, . ) %&amp;gt;%
  # bind in predictions
  left_join(., predicted_results, by = c(&amp;quot;home&amp;quot;, &amp;quot;away&amp;quot;)) %&amp;gt;%
  # select useful parameters
  select(home, away, hgoal, e_hgoal, lik_hgoal, agoal, e_agoal, lik_agoal) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                home             away hgoal e_hgoal lik_hgoal agoal e_agoal
## 1    Dover_Athletic    Coventry_City     0    1.09    0.3362     3    3.28
## 2      Enfield_Town Blackburn_Rovers     0    0.61    0.5434     3    7.91
## 3     Frimley_Green          Arsenal     0    0.14    0.8694     8   22.55
## 4           Arsenal     Enfield_Town     5   14.62    0.0025     0    0.38
## 5  Blackburn_Rovers    Coventry_City     1    3.14    0.1359     1    1.31
## 6     Frimley_Green   Dover_Athletic     1    0.51    0.3063     2    4.62
## 7  Blackburn_Rovers    Frimley_Green     6   14.51    0.0065     0    0.19
## 8     Coventry_City     Enfield_Town     2    5.25    0.0723     1    0.75
## 9    Dover_Athletic          Arsenal     1    0.55    0.3173     3    9.14
## 10          Arsenal    Coventry_City     3    5.32    0.1228     1    0.88
## 11   Dover_Athletic Blackburn_Rovers     1    0.82    0.3612     2    5.39
## 12     Enfield_Town    Frimley_Green     1    3.78    0.0863     0    0.69
## 13 Blackburn_Rovers          Arsenal     0    1.57    0.2080     2    3.66
## 14     Enfield_Town   Dover_Athletic     1    1.53    0.3313     2    2.75
## 15    Frimley_Green    Coventry_City     0    0.27    0.7634     3    8.09
## 16          Arsenal    Frimley_Green    10   24.60    0.0005     0    0.12
## 17 Blackburn_Rovers     Enfield_Town     4    8.62    0.0415     0    0.56
## 18    Coventry_City   Dover_Athletic     1    3.58    0.0998     0    1.00
## 19    Coventry_City Blackburn_Rovers     1    1.43    0.3422     2    2.88
## 20   Dover_Athletic    Frimley_Green     2    5.05    0.0817     0    0.47
## 21     Enfield_Town          Arsenal     2    0.41    0.0558     4   13.41
## 22          Arsenal   Dover_Athletic     4    9.97    0.0193     0    0.50
## 23     Enfield_Town    Coventry_City     1    0.82    0.3612     2    4.81
## 24    Frimley_Green Blackburn_Rovers     1    0.20    0.1637     5   13.30
##    lik_agoal
## 1     0.2213
## 2     0.0303
## 3     0.0003
## 4     0.6839
## 5     0.3535
## 6     0.1052
## 7     0.8270
## 8     0.3543
## 9     0.0137
## 10    0.3650
## 11    0.0663
## 12    0.5016
## 13    0.1724
## 14    0.2417
## 15    0.0271
## 16    0.8869
## 17    0.5712
## 18    0.3679
## 19    0.2328
## 20    0.6250
## 21    0.0020
## 22    0.6065
## 23    0.0943
## 24    0.0058&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we sum the log of those likelihood values we get a measure of how wrong overall our predictions are:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log_likehood &amp;lt;- sum(log(likelihoods$lik_hgoal), log(likelihoods$lik_agoal)) * -1

log_likehood&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 105.995&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(n.b. there will be some rounding errors- especially on the pre-log probabilities, but this will suffice for now)&lt;/p&gt;
&lt;p&gt;To get an idea of whether or not this is good, let’s quickly run the model with all the parameters set to zero. Given that we’re pretty sure that at least Arsenal will be a lot better than Frimley Green, this model should do worse than our basic model above.&lt;/p&gt;
&lt;p&gt;If it indeed does fit the results worse we will get a greater error term- the log likelihood sum&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# do the same but set each teams attack and defence to 1
# expect model to be worse as assumes all teams are equal
equal_parameters &amp;lt;- list(
  alpha = rep(1, length(teams)) %&amp;gt;% `names&amp;lt;-`(teams),
  beta = rep(1, length(teams)) %&amp;gt;% `names&amp;lt;-`(teams)
)

# predict results and munge through to find sum of log likelihoods
worse_log_likelihood &amp;lt;- map2_df(results$home, results$away, 
                    predict_results,
                    equal_parameters) %&amp;gt;%
  mutate_if(is.numeric, round, digits = 2) %&amp;gt;%
  # take the log probability straight away this time
  mutate(lik_hgoal = dpois(results$hgoal, e_hgoal, log = TRUE),
         lik_agoal = dpois(results$agoal, e_agoal, log = TRUE)) %&amp;gt;%
  select(lik_hgoal, lik_agoal) %&amp;gt;%
  map_dbl(sum) %&amp;gt;%
  sum(.) * -1 

worse_log_likelihood&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 112.618&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The worse log likelihood (112.6) is worse (only a bit though) than the 106.0 we previously. This suggests that either the teams are actually quite equal, or that our basic model wasn’t all that good.&lt;/p&gt;
&lt;div id=&#34;parameter-optimisation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Parameter Optimisation&lt;/h2&gt;
&lt;p&gt;There will exist some parameters (α and β for each team, and γ for the home field advantage) that will minimise this negative log likelihood. That is to say, they will predict the results of the already played games most accurately.&lt;/p&gt;
&lt;p&gt;If we want to find those we can use the optim() function in the stats package. This will take a vector of parameters and iterate while slightly changing their values until it gets the lowest value it can find as the output for a supplied function. It also takes a data.frame of results between teams. The results of these games are predicted and then checked against this actually observed data.&lt;/p&gt;
&lt;p&gt;At the end, I’ve also set the function to pass some information from each iteration into the global environment, namely, the iteration number (i), the parameter values the optim() function has chosen for this iteration, and the negative log likelihood of those parameters- the likelihood of the observed scores if those parameters are correct.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;optimise_params &amp;lt;- function(parameters, results) {
  # form the parameters back into a list
  # parameters names alpha (attack), beta (defense), and gamma (hfa)
  param_list &amp;lt;- relist_params(parameters)
  
  # predict the expected results for the games that have been played
  e_results &amp;lt;- map2_df(results$home, results$away, 
                      predict_results,
                      param_list)
  
  # calculate the negative log likelihood of those predictions
  # given the parameters how likely are those scores
  neg_log_likelihood &amp;lt;- calculate_log_likelihood(results, e_results)
  
  # capture the parameters and likelihood at each loop
  # only do it if i is initialised
  if(exists(&amp;quot;i&amp;quot;)) {
    i &amp;lt;&amp;lt;- i + 1
    current_parameters[[i]] &amp;lt;&amp;lt;- parameters
    current_nll[[i]] &amp;lt;&amp;lt;- neg_log_likelihood
  }
  
  # return the value to be minimised
  # in this case the negative log likelihood
  return(neg_log_likelihood)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The three separate functions are coded out separately so we can tinker with them shortly:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;to predict our results we have been supplying a list of two elements: alpha and beta, each of which are numeric vectors. optim() can only take one vector to optimise over but we can trick it by supplying unlist(&lt;code&gt;list_of_parameters&lt;/code&gt;). If we do this we then first want to convert this unlisted numeric vector back into our two element list*&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;*it isn’t vital to have the parameters arranged like this, but I think it leads to neater indexing when predicting the results&lt;/p&gt;
&lt;ol start=&#34;2&#34; style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;we then need to use these parameters to predict the results of past games. For each home and away team in a data.frame of results we can predict the expected home and expected away goals. These are then bound into a data.frame of home and away teams and these predicted goals for each&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;finally, we need to calculate the negative log likelihood by calculating the log probability of the observed goals given the predicted goals and summing these. We then multiply this by -1 as the sum of the log probabilities will be negative and we want to minimise this number as close to zero as possible. The transformation of prod(neg_log_likelihood, -1) is a quick hack for this&lt;sup&gt;4&lt;/sup&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hopefully this is at least bearable to follow. Formalised, this can be written for teams i and matches k as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mathcal L(\alpha_{i},\beta_{i},\gamma;i = 1 ... n) = \prod_{k = 1}^{K}{\frac{\lambda_{k}^{x_{k}}e^{-\lambda_{k}}}{x_{k}!}\frac{\mu_{k}^{y_{k}}e^{-\mu_{k}}}{y_{k}!}}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where for match k and teams i and j, home goals, x is defined by&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[x_{k} \sim Poisson(\lambda_{k} = \alpha_{i(k)}\beta_{j(k)}\gamma)\]&lt;/span&gt;
and away goals, y&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[y_{k} \sim Poisson(\mu_{k} = \alpha_{j(k)}\beta_{i(k)})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which seems daunting when you write it down, but we’ve already covered everything we need to do solve it. It’s just saying we want to minimise the result of the multiplication (the sum of logs in our case above) of the probability of scoring x and y goals in a game. The probability of goals scored assumed to be Poisson distributed, controlled by parameters α, β, and γ for home and away teams.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# optim requires parameters to be supplied as a vector
# we&amp;#39;ll unlist the parameters then relist in the function
relist_params &amp;lt;- function(parameters) {
  parameter_list &amp;lt;- list(
    # alpha = attack rating
    alpha = parameters %&amp;gt;%
      .[grepl(&amp;quot;alpha&amp;quot;, names(.))] %&amp;gt;%
      `names&amp;lt;-`(teams),
    # beta = defence rating
    beta = parameters %&amp;gt;%
      .[grepl(&amp;quot;beta&amp;quot;, names(.))] %&amp;gt;%
      `names&amp;lt;-`(teams),
    # gamma = home field advantage
    gamma = parameters[&amp;quot;gamma&amp;quot;]
  )
  
  return(parameter_list)
}

# use these parameters to predict results for supplied matches
predict_results &amp;lt;- function(home, away, param_list) {
  # expected home goals
  e_goals_home &amp;lt;- param_list$alpha[home] * param_list$beta[away] * param_list$gamma
  # expected away goals
  e_goals_away &amp;lt;- (param_list$alpha[away] * param_list$beta[home])
  
  # bind to df
  df &amp;lt;- data.frame(home = home, away = away,
                   e_hgoal = e_goals_home, e_agoal = e_goals_away)
  
  return(df)
}

# calculate the log likelihood of predict results vs supplied results
calculate_log_likelihood &amp;lt;- function(results, e_results) {
  home_likelihoods = dpois(results$hgoal, lambda = e_results$e_hgoal, log = TRUE)
  away_likelihoods = dpois(results$agoal, lambda = e_results$e_agoal, log = TRUE)
  
  # sum log likelihood and multiply by -1 so we&amp;#39;re minimising neg log likelihood
  likelihood_sum &amp;lt;- sum(home_likelihoods, away_likelihoods)
  neg_log_likelihood &amp;lt;- prod(likelihood_sum, -1)
  
  return(neg_log_likelihood)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll supply parameters that are all equal to 1 to optim to stop it falling into local minima that might affect the ‘optimal’ parameters it finds. The unlisted parameters are then supplied to optim along with the optimise_parameters() function.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# start with all parameters equal
equal_parameters &amp;lt;- list(
  alpha = rep(1, length(teams)) %&amp;gt;% `names&amp;lt;-`(teams),
  beta = rep(1, length(teams)) %&amp;gt;% `names&amp;lt;-`(teams),
  gamma = 1
)

# run optim over the functions with these initial parameters
optimised_parameters &amp;lt;- optim(
  # the equal initial parameters
  par = unlist(equal_parameters),
  # run over the function to optimise parameters
  fn = optimise_params,
  # extra arguments to function
  results = results,
  # Nelder-Mead equation with 10k iterations max
  method = &amp;quot;Nelder-Mead&amp;quot;,
  control = list(maxit = 10000)
  )&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can take the $par element of the output of this to find the parameters for which the negative log likelihood is minimised&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# display the parameters found to minimise
# the negative log likelihood
optimised_parameters$par&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          alpha.Arsenal alpha.Blackburn_Rovers    alpha.Coventry_City 
##              2.9858302              1.8014838              1.2995271 
##   alpha.Dover_Athletic     alpha.Enfield_Town    alpha.Frimley_Green 
##              0.8192267              0.7762002              0.2748448 
##           beta.Arsenal  beta.Blackburn_Rovers     beta.Coventry_City 
##              0.4738011              0.6346112              0.7503864 
##    beta.Dover_Athletic      beta.Enfield_Town     beta.Frimley_Green 
##              1.2208768              1.5180931              2.5535961 
##                  gamma 
##              1.1663125&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, alpha decreases as teams get worse, and beta increases. The found gamma (1.166) is only marginally higher than the 1.091 for our simple model.&lt;/p&gt;
&lt;p&gt;The $value element gives the negative log likelihood calculated for these parameters&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;optimised_parameters$value&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 57.5175&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which is much smaller than the ~100 we got from our very basic model.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;tinkering&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Tinkering&lt;/h2&gt;
&lt;p&gt;This is all very well but there’s still some small improvements we can make.&lt;/p&gt;
&lt;p&gt;For starters, I always think it’s simpler to have both scales of α and β to increase as a teams becomes more skillful in attack or defence. In our original equation the expected home and away goals follow the formula&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[x_{ij} \sim Poisson(α_{i}β_{j}γ)\]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[y_{ij} \sim Poisson(α_{j}β_{i})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;if instead of multiplying by β, we divide instead, a stronger defence will reduce the value of x&lt;sub&gt;ij&lt;/sub&gt;/y&lt;sub&gt;ij&lt;/sub&gt; (reducing the number of expected goals for the opposing team).&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[x_{ij} \sim Poisson(\frac{α_{i}γ}{β_{j}})\]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[y_{ij} \sim Poisson(\frac{α_{j}}{β_{i}})\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;To achieve this we just have to flip two lines of the predict_results function. Instead of multiplying α and β, we divide them instead.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# change prediction to inverse defence parameters
predict_results &amp;lt;- function(home, away, param_list) {
  e_goals_home &amp;lt;- (param_list$alpha[home] / param_list$beta[away]) * param_list$gamma
  e_goals_away &amp;lt;- (param_list$alpha[away] / param_list$beta[home])
  
  df &amp;lt;- data.frame(home = home, away = away,
                   e_hgoal = e_goals_home, e_agoal = e_goals_away)
  
  return(df)
}

# re run using new subfunction
optimised_parameters2 &amp;lt;- optim(
  par = unlist(equal_parameters),
  fn = optimise_params,
  results = results,
  method = &amp;quot;Nelder-Mead&amp;quot;,
  control = list(maxit = 10000))

# check this does what we want
optimised_parameters2$par&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(n.b. I won’t print out the results of all these steps as this post is long enough, but you can run and see the gradual improvements for yourself)&lt;/p&gt;
&lt;p&gt;Next we want to subtly change how the expected goals are calculated.&lt;/p&gt;
&lt;p&gt;Given that&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ A = \frac{B \cdot C}{D}\]&lt;/span&gt;
is exactly the same as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ A = e ^{log(B) + log(C) - log(D)}\]&lt;/span&gt;
we can convert the parameters we are looking for into log(parameters) and take the exponent of their sum as the predicted goals. This might seem like a minor change, but prevents an important exception. Using home goals as an example, remember that&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[x_{ij} \sim Poisson(\frac{α_{i}γ}{β_{j}})\]&lt;/span&gt;
if any of the three parameters become negative then we’re left with a Poisson distribution with a negative mean, which is is absurd: events cannot unhappen. For instance, imagine a football game where one team scores negative goals.&lt;/p&gt;
&lt;p&gt;If we take the log parameters instead we have&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[x_{ij} \sim Poisson(e ^ {α_{i} - β_{j} + γ})\]&lt;/span&gt;
where no matter what values α, β, or γ take, the exponent of their sum will never be negative. When playing a very strong away teams, the mean goals will tend towards 0 (though will never actually reach it).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# change prediction to use log parameters
# exp(log(x) + log(y)) = x * y
predict_results &amp;lt;- function(home, away, param_list) {
  e_goals_home &amp;lt;- exp(param_list$alpha[home] - param_list$beta[away] + param_list$gamma)
  e_goals_away &amp;lt;- exp(param_list$alpha[away] - param_list$beta[home])
  
  df &amp;lt;- data.frame(home = home, away = away,
                   e_hgoal = e_goals_home, e_agoal = e_goals_away)
  
  return(df)
}

# initialise parameters as all 0
# log(1) = 0
equal_parameters &amp;lt;- list(
  alpha = rep(0, length(teams)) %&amp;gt;% `names&amp;lt;-`(teams),
  beta = rep(0, length(teams)) %&amp;gt;% `names&amp;lt;-`(teams),
  gamma = 0
)

# re run using new subfunction
optimised_parameters3 &amp;lt;- optim(
  par = unlist(equal_parameters), 
  fn = optimise_params,
  results = results,
  # using log will avoid non-finite differences 
  # so can use BFGS model
  method = &amp;quot;BFGS&amp;quot;,
  control = list(maxit = 10000))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ve also switched optimisation algorithm from Nelder-Mead to BFGS. BFGS is &lt;a href=&#34;https://docs.mantidproject.org/v3.7.1/concepts/FittingMinimizersComparisonDetailed.html#minimizers-unweighted-comparison-in-terms-of-accuracy&#34;&gt;quicker&lt;/a&gt; than Nelder-Mead but requires the minimisation function (i.e. the negative log likelihood we calculate) to be finite. Before, we could get infinite negative log likelihoods, as it was possible to calculate a negative mean (expected goals for a team). Running dpois() for a negative lambda will return NaN so it becomes impossible to calculate the final negative log likelihood.&lt;/p&gt;
&lt;p&gt;Finally, we want to constrain the final optimised parameters by fixing the sum of all attack parameters, and the sum of all defence parameters, to equal 0. In practice, this basically means that above average attacking/defending teams will have parameters above 0, and below average teams will have parameters below 0. This is handy, but also the main advantage is this prevents &lt;a href=&#34;https://en.wikipedia.org/wiki/Overfitting&#34;&gt;overfitting&lt;/a&gt; of the parameters by the optimisation algorithm.&lt;/p&gt;
&lt;p&gt;To do this, we can simply drop the first (or last, or any, it doesn’t matter) parameter from attack or defence (the parameters for Arsenal) and then calculate Arsenal’s parameters as the sum of the remaining parameters multiplied by minus 1.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\alpha_{n} = -\sum_{i = 1}^{n-1} \alpha_{i} \]&lt;/span&gt;
and also&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\beta_{n} = -\sum_{i = 1}^{n-1} \beta_{i} \]&lt;/span&gt;
In terms of code this just requires adding one line to the relist_params() function to append the value back. We also then need to remove this parameter that we will add back in from the initial parameters which is done below.&lt;/p&gt;
&lt;p&gt;Our output will now be missing the parameters for Arsenal (as they will only exist within the function), but we can easily calculate it from the parameters we do get out.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# introduce sum to zero constraint by calculating
# first teams parameters as minus sum of the rest
relist_params &amp;lt;- function(parameters) {
  parameter_list &amp;lt;- list(
    alpha = parameters %&amp;gt;%
      .[grepl(&amp;quot;alpha&amp;quot;, names(.))] %&amp;gt;%
      append(prod(sum(.), -1), .) %&amp;gt;%
      `names&amp;lt;-`(teams),
    beta = parameters %&amp;gt;%
      .[grepl(&amp;quot;beta&amp;quot;, names(.))] %&amp;gt;%
      append(prod(sum(.), -1), .) %&amp;gt;%
      `names&amp;lt;-`(teams),
    gamma = parameters[&amp;quot;gamma&amp;quot;]
  )
  
  return(parameter_list)
}

# remove the first team from the attack and defence ratings
equal_parameters &amp;lt;- list(
  alpha = rep(0, length(teams)-1) %&amp;gt;% `names&amp;lt;-`(teams[2:length(teams)]),
  beta = rep(0, length(teams)-1) %&amp;gt;% `names&amp;lt;-`(teams[2:length(teams)]),
  gamma = 0
)

# initialise i to collect data about the optimisation process at each iteration
i &amp;lt;- 0
# collect current parameter values and neg log likelihood at each iteration
current_parameters &amp;lt;- list()
current_nll &amp;lt;- list()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then final the optim() function one final time to get our final optimised parameters&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# run our final calculation
optimised_parameters4 &amp;lt;- optim(
  par = unlist(equal_parameters), 
  fn = optimise_params,
  results = results,
  method = &amp;quot;BFGS&amp;quot;,
  control = list(maxit = 10000))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can plot the log likelihood at each iteration. Notice how it starts around &amp;lt;120, which is pretty close what our worse_log_likelihood returned. For these optimisations, the original parameters we are supplying are similar to the zeroed parameters for that example.&lt;/p&gt;
&lt;p&gt;As the optim() function plays with the parameters you can see the log likelihood jumps around quite violently, but over time tend towards zero.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p3 &amp;lt;- data.frame(likelihood = unlist(current_nll),
                iteration = seq(length(current_nll))) %&amp;gt;%
  ggplot(aes(x = iteration, y = likelihood)) +
  geom_line(colour = &amp;quot;red&amp;quot;) +
  # cut out some cases where optim() has been a bit ambitious
  coord_cartesian(ylim = c(0, 250)) +
  labs(title = &amp;quot;Negative log likelihood of parameters over iterations&amp;quot;,
       y = &amp;quot;negative log likelihood&amp;quot;,
       x = &amp;quot;iteration&amp;quot;) +
  theme_minimal()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-1_files/figure-html/plot_log_liks-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The final parameters can also be extracted from the output from optim() and plotted:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p4 &amp;lt;- optimised_parameters4$par %&amp;gt;%
  # relist to add in first team
  relist_params() %&amp;gt;%
  unlist() %&amp;gt;%
  # select team parameters
  .[grepl(&amp;quot;beta|alpha&amp;quot;, names(.))] %&amp;gt;%
  data.frame(value = .,
             parameter = names(.)) %&amp;gt;%
  separate(parameter, into = c(&amp;quot;parameter&amp;quot;, &amp;quot;team&amp;quot;), &amp;quot;\\.&amp;quot;) %&amp;gt;%
  # spread into wide format
  spread(parameter, value) %&amp;gt;%
  # pipe into a plot
  ggplot(aes(x = alpha, y = beta)) +
  geom_point() +
  ggrepel::geom_text_repel(aes(label = team)) +
  stat_smooth(method = &amp;quot;lm&amp;quot;, se = FALSE) +
  labs(title = &amp;quot;Optimal parameters for teams&amp;quot;,
       subtitle = &amp;quot;given first 8 weeks of results&amp;quot;,
       x = &amp;quot;alpha (more likely to score -&amp;gt;)&amp;quot;,
       y = &amp;quot;beta (less likely to concede -&amp;gt;)&amp;quot;) +
  theme_minimal()

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-1_files/figure-html/plot_parameters-1.png&#34; width=&#34;672&#34; /&gt;
Notice how the teams monotonically increase in both attack and defensive ability. This is by design on how the results were created (see the bottom of this post). With only 8 games per team however, there is quite a lot of noise in the signal. Hitting the crossbar instead of scoring in one game could make a fairly large difference in how the function rates a team.&lt;/p&gt;
&lt;p&gt;Also note how the regression line passes through the origin- this is a result of us constraining the parameters to sum to zero.&lt;/p&gt;
&lt;p&gt;If we want to see how optim() selects these, we can plot how they change over iterations. You can see how it jumps around then settles on incremental improvements to the model.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p5 &amp;lt;- current_parameters %&amp;gt;%
  # get the parameters for arsenal for each iteration
  lapply(., function(x){ unlist(relist_params(x))}) %&amp;gt;%
  map_df(bind_rows, .id = &amp;quot;iteration&amp;quot;) %&amp;gt;%
  # melt data and split parameters into team and parameter
  gather(&amp;quot;parameter&amp;quot;, &amp;quot;value&amp;quot;, -iteration) %&amp;gt;%
  # get rid of the gamma parameter
  filter(parameter != &amp;quot;gamma.gamma&amp;quot;) %&amp;gt;%
  separate(parameter, into = c(&amp;quot;parameter&amp;quot;, &amp;quot;team&amp;quot;), sep = &amp;quot;\\.&amp;quot;) %&amp;gt;%
  # spread data back by parameter
  spread(parameter, value) %&amp;gt;%
  mutate(iteration = as.numeric(iteration)) %&amp;gt;%
  # plot alpha against beta for each iteration
  ggplot(aes(x = alpha, y = beta)) +
  geom_text(aes(label = team)) +
  labs(title = &amp;#39;Parameters for Iteration {floor(frame_time)}&amp;#39;,
       subtitle = &amp;quot;given first 8 weeks of results&amp;quot;,
       x = &amp;quot;alpha (more likely to score -&amp;gt;)&amp;quot;,
       y = &amp;quot;beta (less likely to concede -&amp;gt;)&amp;quot;) +
  # using gganimate package
  gganimate::transition_time(iteration) +
  gganimate::ease_aes(&amp;#39;linear&amp;#39;) +
  gganimate::view_follow()

# animate the plot
gganimate::animate(p5, nframes = i)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-1_files/figure-html/plot_optimisation_animation-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;predict-remaining-matches&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Predict Remaining Matches&lt;/h2&gt;
&lt;p&gt;Now we have rated each teams attack/defense, and the advantage to a team to play at home, we can predict the remaining matches between the teams.&lt;/p&gt;
&lt;p&gt;For this, we just have to use the predict_results() function we defined earlier, except this time the output will be the expected goals per team. Earlier we were measuring the deviance from expectation, but not we assume the most likely result is exactly equal to the expected results. If we wanted to we could work out how likely this result is, and what the most likely results are.&lt;/p&gt;
&lt;p&gt;This post is long enough however, so for now, we’ll just detail the most likely results.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;predicted_results &amp;lt;- predict_results(unplayed_games$home,
                      unplayed_games$away, 
                      relist_params(optimised_parameters4$par)) %&amp;gt;%
  mutate_if(is.numeric, round, 2) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               home             away e_hgoal e_agoal
## 1    Coventry_City          Arsenal    0.86    2.11
## 2 Blackburn_Rovers   Dover_Athletic    2.62    0.49
## 3    Frimley_Green     Enfield_Town    0.44    1.72
## 4          Arsenal Blackburn_Rovers    2.39    0.99
## 5    Coventry_City    Frimley_Green    4.09    0.17
## 6   Dover_Athletic     Enfield_Town    1.33    0.79&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All of these look reasonable, with better teams beating worse ones. The only match that the model thinks might well end in a draw is Dover at home to Enfield, which is not entirely unreasonable.&lt;/p&gt;
&lt;p&gt;We can add these predictions to our earlier matrix of results to get a sense if these fit in with the trend from the observed matches:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p6 &amp;lt;- rbind(
  predicted_results %&amp;gt;%
    rename_if(is.numeric, gsub, pattern = &amp;quot;e_&amp;quot;, replacement = &amp;quot;&amp;quot;) %&amp;gt;%
    mutate(type = &amp;quot;predicted&amp;quot;),
  results %&amp;gt;%
    select(-gameweek) %&amp;gt;%
    mutate(type = &amp;quot;result&amp;quot;)
) %&amp;gt;%
  ggplot(., aes(x = away, y = home, fill = hgoal-agoal)) +
  geom_tile() +
  # add the scorelines
  geom_label(aes(label = paste(hgoal, agoal, sep = &amp;quot;-&amp;quot;), colour = type), fill = &amp;quot;white&amp;quot;) +
  # colour where black for actual results and red for predictions
  scale_colour_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;black&amp;quot;)) +
  # colour where green shows home win and red an away win
  scale_fill_gradient2(low = &amp;quot;darkred&amp;quot;, high = &amp;quot;green&amp;quot;, midpoint = 0, guide = FALSE) +
  scale_x_discrete(limits = levels(results$home), position = &amp;quot;top&amp;quot;) +
  scale_y_discrete(limits = rev(levels(results$away))) +
  theme_minimal()

p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-1_files/figure-html/plot_all_games-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Which they do! The predicted results fit in with the gradient of heavier defeats for home teams towards the bottom left, progressing to easy home victories in the top right.&lt;/p&gt;
&lt;p&gt;That’s all for this post. Hopefully using the Poisson distribution to model football matches is a little clearer now. Feel free to email me any questions and check out the packages I stole all the codes/idea from.&lt;/p&gt;
&lt;p&gt;Next time, I’ll go over how to quantify the probability of a range of results for any single match in (hopefully) a shorter post; until then!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;notes&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Notes&lt;/h2&gt;
&lt;p&gt;&lt;sup&gt;1&lt;/sup&gt; much of the code I use here is stolen/reworked from the code shared on this repo&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;2&lt;/sup&gt; towards the end of writing this post I came across &lt;a href=&#34;https://dashee87.github.io/football/python/predicting-football-results-with-statistical-modelling-dixon-coles-and-time-weighting/&#34;&gt;David Sheehan’s blog&lt;/a&gt; which actually does a pretty good job, but I felt still didn’t quite go through how/why the model uses the maths it does&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;3&lt;/sup&gt; see &lt;a href=&#34;https://arxiv.org/pdf/cond-mat/0110605.pdf&#34; class=&#34;uri&#34;&gt;https://arxiv.org/pdf/cond-mat/0110605.pdf&lt;/a&gt; and also the conclusion of &lt;a href=&#34;https://dashee87.github.io/football/python/predicting-football-results-with-statistical-modelling/&#34;&gt;David Sheehan’s blog on Dixon-Coles processes&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;sup&gt;4&lt;/sup&gt; *we could instead &lt;em&gt;maximise&lt;/em&gt; the sum of the log likelihoods and then the error will converge towards 0 from a negative number. Either is fine.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;results-generation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Results Generation&lt;/h2&gt;
&lt;p&gt;First we need to create a data.frame of fixtures for each team&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# https://stackoverflow.com/questions/54099990/is-there-an-efficient-algorithm-to-create-this-type-of-schedule
create_fixtures &amp;lt;- function(teams) {
  # keep team 1 in place
  team1 &amp;lt;- as.character(teams[1])
  #rotate other teams around team 1
  other_teams &amp;lt;- as.character(teams[!teams %in% team1])
  length &amp;lt;- length(other_teams)
  
  # generate fixtures each week
  for(week in seq((length(teams)-1)*2)) {
    
    if(week %% 2 == 0) {
      fixtures &amp;lt;- data.frame(home = c(team1, other_teams[1:2]),
                             away = other_teams[length:3],
                             gameweek = week)
    } else {
      fixtures &amp;lt;- data.frame(home = other_teams[length:3],
                             away = c(team1, other_teams[1:2]),
                             gameweek = week)
      
    }
    
    if(week == 1) {
      fixtures_df &amp;lt;- fixtures 
    } else {
      fixtures_df &amp;lt;- rbind(fixtures_df, fixtures)
    }
    
    # rotate other teams around
    other_teams &amp;lt;- c(other_teams[length], other_teams[1:length-1])
  }
  
  return(fixtures_df)
}

# create the fixtures
fixtures &amp;lt;- create_fixtures(teams) %&amp;gt;%
  mutate_if(is.factor, as.character)

# print the fixture list
fixtures&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                home             away gameweek
## 1     Frimley_Green          Arsenal        1
## 2      Enfield_Town Blackburn_Rovers        1
## 3    Dover_Athletic    Coventry_City        1
## 4           Arsenal     Enfield_Town        2
## 5     Frimley_Green   Dover_Athletic        2
## 6  Blackburn_Rovers    Coventry_City        2
## 7    Dover_Athletic          Arsenal        3
## 8     Coventry_City     Enfield_Town        3
## 9  Blackburn_Rovers    Frimley_Green        3
## 10          Arsenal    Coventry_City        4
## 11   Dover_Athletic Blackburn_Rovers        4
## 12     Enfield_Town    Frimley_Green        4
## 13 Blackburn_Rovers          Arsenal        5
## 14    Frimley_Green    Coventry_City        5
## 15     Enfield_Town   Dover_Athletic        5
## 16          Arsenal    Frimley_Green        6
## 17 Blackburn_Rovers     Enfield_Town        6
## 18    Coventry_City   Dover_Athletic        6
## 19     Enfield_Town          Arsenal        7
## 20   Dover_Athletic    Frimley_Green        7
## 21    Coventry_City Blackburn_Rovers        7
## 22          Arsenal   Dover_Athletic        8
## 23     Enfield_Town    Coventry_City        8
## 24    Frimley_Green Blackburn_Rovers        8
## 25    Coventry_City          Arsenal        9
## 26 Blackburn_Rovers   Dover_Athletic        9
## 27    Frimley_Green     Enfield_Town        9
## 28          Arsenal Blackburn_Rovers       10
## 29    Coventry_City    Frimley_Green       10
## 30   Dover_Athletic     Enfield_Town       10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and then create the results&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# using goalmodel package 
# https://github.com/opisthokonta/goalmodel
library(goalmodel)

# have to manually create a list of parameters
model &amp;lt;- list()
# stratify teams abilities in attack and defense
model$parameters &amp;lt;- list(attack = seq(1, -1 + 2/length(teams), by = -2/(length(teams)-1)) %&amp;gt;%
                           append(-sum(.)) %&amp;gt;%
                           `names&amp;lt;-`(teams), 
                         defense = seq(1, -1 + 2/length(teams), by = -2/(length(teams)-1)) %&amp;gt;%
                           append(-sum(.)) %&amp;gt;%
                           `names&amp;lt;-`(teams), 
                         # no base rate of goals
                         intercept = 0, 
                         # roughly accurate hfa for English professional football
                         hfa = 0.3)

# add in teams
model$all_teams &amp;lt;- teams
# use a simple Poisson model with 8 goals max
model$model &amp;lt;- &amp;quot;poisson&amp;quot;
model$maxgoal &amp;lt;- 8

# use the model to predict results using regista package
results &amp;lt;- predict_expg(model, fixtures$home, fixtures$away, return_df = TRUE) %&amp;gt;%
  # add some noise
  mutate(noise1 = rnorm(nrow(.), 0, 0.5),
         noise2 = rnorm(nrow(.), 0, 0.5)) %&amp;gt;%
  mutate(hgoal = round(expg1 + noise1,0 ),
         agoal = round(expg2 + noise2,0),
         home = as.factor(team1),
         away = as.factor(team2)) %&amp;gt;%
  # merge to fixtures
  merge(., fixtures, by = c(&amp;quot;home&amp;quot;, &amp;quot;away&amp;quot;)) %&amp;gt;%
  # cant score less than zero goals
  mutate_at(vars(hgoal:agoal), funs(replace(., .&amp;lt;0, 0))) %&amp;gt;%
  select(home, away, hgoal, agoal, gameweek) %&amp;gt;%
  arrange(gameweek, home) %&amp;gt;%
  # treat only first 8 weeks as played
  filter(gameweek &amp;lt;= 8)

# print results
results&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                home             away hgoal agoal gameweek
## 1    Dover_Athletic    Coventry_City     0     2        1
## 2      Enfield_Town Blackburn_Rovers     1     3        1
## 3     Frimley_Green          Arsenal     0     6        1
## 4           Arsenal     Enfield_Town     6     0        2
## 5  Blackburn_Rovers    Coventry_City     2     0        2
## 6     Frimley_Green   Dover_Athletic     0     3        2
## 7  Blackburn_Rovers    Frimley_Green     8     0        3
## 8     Coventry_City     Enfield_Town     3     1        3
## 9    Dover_Athletic          Arsenal     1     3        3
## 10          Arsenal    Coventry_City     3     0        4
## 11   Dover_Athletic Blackburn_Rovers     1     2        4
## 12     Enfield_Town    Frimley_Green     2     1        4
## 13 Blackburn_Rovers          Arsenal     2     2        5
## 14     Enfield_Town   Dover_Athletic     0     2        5
## 15    Frimley_Green    Coventry_City     1     3        5
## 16          Arsenal    Frimley_Green     9     0        6
## 17 Blackburn_Rovers     Enfield_Town     5     0        6
## 18    Coventry_City   Dover_Athletic     1     2        6
## 19    Coventry_City Blackburn_Rovers     0     2        7
## 20   Dover_Athletic    Frimley_Green     3     1        7
## 21     Enfield_Town          Arsenal     0     5        7
## 22          Arsenal   Dover_Athletic     4     1        8
## 23     Enfield_Town    Coventry_City     1     2        8
## 24    Frimley_Green Blackburn_Rovers     1     4        8&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>An Introduction to Discrete Choice Analysis in R</title>
      <link>/post/dca_1/</link>
      <pubDate>Wed, 24 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/dca_1/</guid>
      <description>


&lt;p&gt;When studying why people make the economic choices they do, we need some way of quantifying the value to the person of the offered choices. For instance, when deciding whether to ride to my office by bike or instead catch the bus, there are myriad factors that my brain feeds into an equation to get two values:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;the utility of taking the bus&lt;/li&gt;
&lt;li&gt;the utility of riding my bike&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;For instance, if it looks like it might rain, I’m more likely to take the bus as getting soaked reduces the utility of cycling to work. Conversely, if I glance at my watch and see that I’ve just missed a bus, the utility of taking the bus decreases as I don’t want to have to wait at the bus stop.&lt;/p&gt;
&lt;p&gt;A frequent criticism of economics is that it assumes some &lt;em&gt;homo economicus&lt;/em&gt; who will always choose that which maximizes this utility. Lets say the utilities of the two commute choices were only governed by p(rain) and e(wait time) respectively, then for a set probability of rain and expected wait time for the bus, I should always choose the same mode of transport. This is clearly not how humans (or any other animal) work and so for the last 50 years &lt;a href=&#34;https://eml.berkeley.edu/~mcfadden/discrete/ch5.pdf&#34;&gt;models of probabilistic choice&lt;/a&gt; have been used instead.&lt;/p&gt;
&lt;p&gt;The advantage to this is that by studying the % of times I decide to ride my bike into work vs catching the bus, for any set of parameters, it’s possible to derive the relative utility of that method of transportation. Then if a novel combination of rain/waiting comes up, it’s possible to predict the chance I will choose to ride my bike and the chance I will take the bus.&lt;/p&gt;
&lt;p&gt;However, many of these models are fairly dense to approach without formal economic training, so I wanted to write a guide to deriving and using them in R. For the first post, I’ll consider a toy problem with a simple binary choice paradigm to get some of the basic ideas of random utility modelling down and hopefully build from that in later posts.&lt;/p&gt;
&lt;div id=&#34;example-problem&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Example Problem&lt;/h1&gt;
&lt;p&gt;Summer is here and it’s time for the annual Behavioural Economics departmental picnic! Due to the collapsing global climate, this year is the hottest yet and you are eagerly anticipating sitting in &lt;a href=&#34;https://en.wikipedia.org/wiki/Grantchester_Meadows&#34;&gt;Granchester Meadows&lt;/a&gt; with your favourite chilled soft drink and discussing your research.&lt;/p&gt;
&lt;p&gt;Unfortunately, you’ve been stuck in the office for most of the afternoon coding up your latest model and will arrive late. Due to the hot weather, most of the drinks have already been consumed and what’s left needs to be rationed. Luckily, you are all very rational behavioural economists who know that if you can find everyone’s utility for the two remaining drinks flavours, you can apportion them appropriately.&lt;/p&gt;
&lt;p&gt;The two remaining drinks are &lt;a href=&#34;https://media2.giphy.com/media/3oriffxcqE2syOd5Ty/giphy.gif&#34;&gt;buzz cola&lt;/a&gt; which comes in cans of 330ml which is very tasty, and &lt;a href=&#34;https://comb.io/qbzoUv.gif&#34;&gt;slurm&lt;/a&gt; which comes in 2 litre bottles (which can be poured into any amount).&lt;/p&gt;
&lt;p&gt;Someone quickly codes up a binary choice task where PhD students have to choose between 1,2, or 3 330ml cans of the desirable Buzz Cola, or some amount between 0 and 2000ml of the slightly less valued Slurm.&lt;/p&gt;
&lt;p&gt;Having spent 10 minutes and 1800 trials doing the task your data looks like&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#show the first ten trials
head(trial_data, 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      buzz_cola slurm    choice
## 1446         3   800 buzz_cola
## 227          1   800     slurm
## 209          1   800 buzz_cola
## 1497         3   800 buzz_cola
## 1542         3  1200 buzz_cola
## 34           1     0 buzz_cola
## 1493         3   800 buzz_cola
## 1028         2  1600     slurm
## 656          2     0 buzz_cola
## 266          1   800     slurm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we group by each combination of n(buzz cola cans),ml(slurm) we can work out the proportion of buzz cola choices&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;choice_data &amp;lt;- trial_data %&amp;gt;%
  #code buzz cola choice as a binary variable
  mutate(buzz_cola_choice = case_when(
    choice == &amp;quot;buzz_cola&amp;quot; ~ 1,
    choice == &amp;quot;slurm&amp;quot; ~ 0
  )) %&amp;gt;%
  #group by combinations and find the proportion of buzz cola choices
  group_by(buzz_cola, slurm) %&amp;gt;%
  summarise(fraction_choose_cola = mean(buzz_cola_choice))

#show the grouped choice data
choice_data&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 18 x 3
## # Groups:   buzz_cola [3]
##    buzz_cola slurm fraction_choose_cola
##        &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;                &amp;lt;dbl&amp;gt;
##  1         1    0                 0.94 
##  2         1  400                 0.580
##  3         1  800                 0.13 
##  4         1 1200.                0.01 
##  5         1 1600                 0    
##  6         1 2000                 0    
##  7         2    0                 1    
##  8         2  400                 0.96 
##  9         2  800                 0.72 
## 10         2 1200.                0.28 
## 11         2 1600                 0.04 
## 12         2 2000                 0    
## 13         3    0                 1    
## 14         3  400                 1    
## 15         3  800                 1    
## 16         3 1200.                0.88 
## 17         3 1600                 0.34 
## 18         3 2000                 0.02&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and we can plot a logistic regression of this data to see how much x cans of buzz cola are worth in y ml of slurm&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#quick binomial smoothing function
#from https://ggplot2.tidyverse.org/reference/geom_smooth.html
binomial_smooth &amp;lt;- function(...) {
  geom_smooth(method = &amp;quot;glm&amp;quot;, method.args = list(family = &amp;quot;binomial&amp;quot;), ...)
}

#plot the logistic regression on the entire choice data
p1 &amp;lt;- choice_data %&amp;gt;%
  ggplot(., aes(x = slurm, y = fraction_choose_cola, colour = factor(buzz_cola))) +
  geom_point() +
  binomial_smooth(se = FALSE) +
  #add in some aesthetics
  scale_colour_discrete(name = &amp;quot;buzz cola cans \n(x * 330ml)&amp;quot;) +
  labs(title = &amp;quot;what drink do you want for the departmental picnic?&amp;quot;,
       subtitle = &amp;quot;simulated data&amp;quot;,
       x = &amp;quot;slurm (/ml)&amp;quot;,
       y = &amp;quot;fraction of buzz cola choices&amp;quot;) +
  theme_minimal()

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-24-introduction-to-discrete-choice-analysis_files/figure-html/plot_data-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We then need to solve your utilities of buzz cola and slurm. To do this we need to maximize the sum of the log likelihood of each choice you make.&lt;/p&gt;
&lt;p&gt;Basically, for each trial when you are presented with x ml of buzz cola (the number of cans multiplied by 330ml per can) or y ml of slurm there are utility parameters (rho) for both of these which mean you have some total utility of offered buzz cola and total utility of offered slurm.&lt;/p&gt;
&lt;p&gt;As a rational econ PhD student, you are pretty much always going to choose whichever of these utilities is greater. E.g:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#make up some utility parameters
buzz_cola_rho &amp;lt;- 2
slurm_rho &amp;lt;- 1

trial_utilities &amp;lt;- trial_data %&amp;gt;%
  #total utility of each offer is the amount * utility_parameter
  mutate(buzz_cola_utility = buzz_cola * 330 * buzz_cola_rho,
         slurm_utility = slurm * slurm_rho) %&amp;gt;%
  #which utility is greater
  mutate(greater_utility = case_when(
    buzz_cola_utility &amp;gt;= slurm_utility ~ &amp;quot;buzz_cola&amp;quot;,
    slurm_utility &amp;gt; buzz_cola_utility ~ &amp;quot;slurm&amp;quot;
  )) %&amp;gt;%
  #organise columns
  select(buzz_cola, buzz_cola_utility, 
         slurm, slurm_utility,
         greater_utility, choice)

#print first 10 trials
trial_utilities[1:10,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    buzz_cola buzz_cola_utility slurm slurm_utility greater_utility
## 1          3              1980   800           800       buzz_cola
## 2          1               660   800           800           slurm
## 3          1               660   800           800           slurm
## 4          3              1980   800           800       buzz_cola
## 5          3              1980  1200          1200       buzz_cola
## 6          1               660     0             0       buzz_cola
## 7          3              1980   800           800       buzz_cola
## 8          2              1320  1600          1600           slurm
## 9          2              1320     0             0       buzz_cola
## 10         1               660   800           800           slurm
##       choice
## 1  buzz_cola
## 2      slurm
## 3  buzz_cola
## 4  buzz_cola
## 5  buzz_cola
## 6  buzz_cola
## 7  buzz_cola
## 8      slurm
## 9  buzz_cola
## 10     slurm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s clear to see that mostly the choices fall in line with these made up parameters. The two unexpected choices could be because of random participant mistakes, but is more likely due to our parameters not yet being optimized (more on that in a sec), or because even rational actors may sometimes choose something which seems to have less utility (e.g. when sampling, or as utilities change e.g. via satiety).&lt;/p&gt;
&lt;p&gt;In the above example, given the relative utilities of the two offered drinks, it’s possible to work out the probability that the participant will choose either of them using a simple logit model. (for these formulae I’m copying the notation from &lt;a href=&#34;https://imai.fas.harvard.edu/teaching/files/discrete.pdf&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;we have a binary model such that the choice of buzz cola can be represented by Y: &lt;span class=&#34;math display&#34;&gt;\[Y_{i} \in {0,1}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Where X is the difference in utility between the choices A (buzz cola) and B (slurm) on each trial, i&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[X_{i} = u(A_{i}) - u(B_{i})\]&lt;/span&gt; using a logit model such that&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\phi_{i} = \frac{1}{1 + e^{-\beta X_{i})}}\]&lt;/span&gt; where beta is the temperature of the logit curve (i.e. the steepness).&lt;/p&gt;
&lt;p&gt;The log probability of choosing A (buzz cola) is therefore the log(phi) when A is chosen, and log(1-phi) when B (slurm) is chosen. The Y/1-Y cancel the other term out as Y can either equal 1 (buzz cola choice) or 0 (slurm chosen).&lt;/p&gt;
&lt;p&gt;We want to sum this over every trial and find the parameters for beta and the rho for both goods A (buzz cola) and B (slurm) which maximize this total sum&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mathcal l_{n}(\beta|Y,X) = \sum_{i=1}^{n} Y_{i} log(\phi_{i}) + (1-Y_{i})log(1-\phi_{i})\]&lt;/span&gt; In R this can be expressed as&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to calulate the log likelihood per trial over data
#parameters is a vector of beta,rho_a,rho_b
#(a = buzz cola, b = slurm)
#data is our trial data
log_likelihood_func &amp;lt;- function(parameters, data) {
  #I want to plot how optim works so will gather the parameters
  #it selects for each iteration
  i &amp;lt;&amp;lt;- i + 1
  vals[[i]] &amp;lt;&amp;lt;- parameters
  
  #pull the individual parameters out of the vector
  beta &amp;lt;- parameters[&amp;quot;beta&amp;quot;]
  buzz_cola_rho &amp;lt;- parameters[&amp;quot;rho_a&amp;quot;]
  slurm_rho &amp;lt;- parameters[&amp;quot;rho_b&amp;quot;]
  
  #find the trial utility of the offered buzz cola and slurm
  trial_bc_utility &amp;lt;- (data$buzz_cola * 330) / 1000 * buzz_cola_rho
  trial_s_utility &amp;lt;- (data$slurm/ 1000) * slurm_rho
  #find the difference in utility between the two offered goods
  delta_utility &amp;lt;- trial_bc_utility - trial_s_utility
  
  #find the phi term for this trial
  #using the logit model
  phi &amp;lt;- 1 / (1 + exp(-beta*delta_utility))
  
  #find the log likelihood for the choice made in each trial
  log_likelihood &amp;lt;- (data$buzz_cola_choice * log(phi)) + ((1-data$buzz_cola_choice) * log(1-phi))
  
  sumloglik[[i]] &amp;lt;&amp;lt;- sum(log_likelihood)
  
  #return the sum over every trial of these log likelihoods
  #we want to vary the parameters to maximise this sum
  return(sum(log_likelihood))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can start out with a parameter assuming the two utilities are equal&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#make up initial parameters
#1, 1, 1 is unlikely but a reasonable starting point
initial_parameters &amp;lt;- c(1, 1, 1) %&amp;gt;%
  `names&amp;lt;-`(c(&amp;quot;beta&amp;quot;, &amp;quot;rho_a&amp;quot;, &amp;quot;rho_b&amp;quot;))

initial_parameters&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  beta rho_a rho_b 
##     1     1     1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;then we can use the optim function which will pass the parameter vector into the log likelihood function and iteratively change the values in the parameter vector until the greatest sum is returned. We’re looking for the greatest sum as the log likelihood per trial boils down to log(phi / 1-phi) where phi is between 0 and 1 and is greatest where the utility parameters make the post-hoc choice most clear. E.g. when choosing the buzz cola the log likelihood = log(phi) and we want to maximize phi.&lt;/p&gt;
&lt;p&gt;Taking the log of x between 0 and 1 will give a negative number that approaches 0 as x approaches 1. So the total sum of log likelihood terms will approach 0 as the parameters maximize the phi term.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#add a binary variable for the choice of buzz_cola
trial_data_binary &amp;lt;- trial_data %&amp;gt;%
  mutate(buzz_cola_choice = case_when(
    choice == &amp;quot;buzz_cola&amp;quot; ~ 1,
    choice == &amp;quot;slurm&amp;quot; ~ 0
  ))

#initialise a list to store the parameters over iterations
i &amp;lt;- 0
vals &amp;lt;- list()
sumloglik &amp;lt;- list()

optim_params &amp;lt;- optim(par = initial_parameters,
                      #the functionise to optimise these over
                      fn = log_likelihood_func,
                      #other arguments to the function
                      data = trial_data_binary,
                      #optimisation algorithm to use
                      method = &amp;quot;Nelder-Mead&amp;quot;,
                      #we are looking to maximise the sum
                      #so fnscale set to -1
                      control = list(fnscale = -1))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;optim() works by taking a vector of parameters and slightly adjusting them every iteration until the output from fn = … is minimized via an algorithm (in this case &lt;a href=&#34;https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method&#34;&gt;Nelder-Mead&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;By collecting the parameter values it selects and the subsequent log likelihood sum for each iteration we can get a sense of how it works&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#load gganimate
library(gganimate)

#rbind the values per iteration
p2 &amp;lt;- vals %&amp;gt;%
  do.call(rbind, .) %&amp;gt;%
  #add a column for iteration number
  as.data.frame() %&amp;gt;%
  mutate(iteration = 1:n()) %&amp;gt;%
  #gather for plotting
  gather(&amp;quot;parameter&amp;quot;, &amp;quot;value&amp;quot;, -iteration) %&amp;gt;%
  #plt a bar chart of parameters over iterations
  ggplot(., aes(x = parameter, y = value)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  #show the iteration in the title
  labs(title = &amp;#39;iteration: {frame_time}&amp;#39;) +
  #aesthetics
  theme_minimal() +
  #gganimate
  transition_time(iteration) +
  ease_aes(&amp;#39;cubic-in-out&amp;#39;)

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-24-introduction-to-discrete-choice-analysis_files/figure-html/plot_parameter_optimisation-1.gif&#34; /&gt;&lt;!-- --&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#unlist the log likelihood sum per iteration
p3 &amp;lt;- unlist(sumloglik) %&amp;gt;%
  #add the iteration number as a variable
  data.frame(sum = .,
             iteration = 1:length(.)) %&amp;gt;%
  #plot it
  ggplot(., aes(x = iteration, y = sum)) +
  geom_line() +
  labs(title = &amp;quot;how optim maximises the sum of the log likelihood&amp;quot;,
       x = &amp;quot;iteration&amp;quot;,
       y = &amp;quot;sum of the log likelihoods per trial&amp;quot;) +
  theme_minimal()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-24-introduction-to-discrete-choice-analysis_files/figure-html/plot_optimisation_errors-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The final maximized value of -400 is still some way off 0 but seems to be the highest it will go. Looking at p1, we can see that the curves are some way off a step function that would mean that no ‘sub-optimal’ choices would be made (there’s some threshold of slurm vs buzz cola that means only one or the other is chosen).&lt;/p&gt;
&lt;p&gt;We can then get the optimized parameters from the object returned from optimization function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#print the optimised parameters
optim_params$par&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     beta    rho_a    rho_b 
## 3.520318 2.563380 1.702415&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and there we have it! you &lt;em&gt;do&lt;/em&gt; prefer buzz cola (rho_a) to slurm (rho_b). For every unit ml of both drinks you are offered, you prefer buzz cola ~1.5x as much.&lt;/p&gt;
&lt;p&gt;We can plot your likelihood to choose the offered ml of buzz cola over the offered ml of slurm for ratios of slurm:buzz cola by changing around a few terms in our logit model&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to calculate likelihood of choosing good A given ratio B/A
calc_likelihood &amp;lt;- function(beta = optim_params$par[&amp;quot;beta&amp;quot;],
                            rho_a = optim_params$par[&amp;quot;rho_a&amp;quot;],
                            rho_b = optim_params$par[&amp;quot;rho_b&amp;quot;],
                            ratio_ba) {
  #instead of working out the difference in utility by comparing offered amounts
  #use the ratio of good b:good a
  utility_term &amp;lt;- rho_a/rho_b - ratio_ba
  
  #calculate as before
  phi &amp;lt;- 1 / (1 + exp(-beta* utility_term))
}

#plot this data for the rations 1:3 to 3:1
p4 &amp;lt;- seq(1/3, 3, by = 0.1) %&amp;gt;%
  data.frame(ratio_ba = .,
             likelihood_a = calc_likelihood(ratio_ba = .)) %&amp;gt;%
  ggplot(., aes(x = ratio_ba, y = likelihood_a)) +
  geom_point() +
  #show the indifference point ratio of B:A
  geom_segment(aes(x = optim_params$par[&amp;quot;rho_a&amp;quot;]/optim_params$par[&amp;quot;rho_b&amp;quot;],
                   xend = optim_params$par[&amp;quot;rho_a&amp;quot;]/optim_params$par[&amp;quot;rho_b&amp;quot;],
                   y = 0.5,
                   yend = 0)) +
  geom_text(label = &amp;quot;50% likelihood at rho_a/rho_b&amp;quot;, x = 1, y = 0.2) +
  #aesthetics
  labs(title = &amp;quot;Utility curve for Buzz Cola vs Slurm&amp;quot;,
       x = &amp;quot;ratio of ml slurm:buzz cola&amp;quot;,
       y = &amp;quot;likelihood of choosing buzz cola&amp;quot;) +
  theme_minimal()

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-24-introduction-to-discrete-choice-analysis_files/figure-html/plot_utility_curve-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;how-parameters-vary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;How Parameters Vary&lt;/h2&gt;
&lt;p&gt;Imagine that two of your colleagues, Andreas and Béatrice also arrive at the picnic and take part in the utility measurement.&lt;/p&gt;
&lt;p&gt;Béatrice is entirely indifferent between the two soft drinks, they both taste the same as far as she is concerned so 1ml of slurm == 1ml of buzz cola.&lt;/p&gt;
&lt;p&gt;Andreas, on the other hand, also prefers buzz cola to slurm, but is hyper-rational. Once the utility of one option exceeds the utility of another he will pretty much always choose the former and samples the lower utility option very rarely.&lt;/p&gt;
&lt;p&gt;If we plot their choice proportions we get similar curves as before, but with slightly different shapes:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p5 &amp;lt;- colleagues_choice_data %&amp;gt;%
  ggplot(., aes(x = slurm, y = fraction_choose_cola, colour = factor(buzz_cola))) +
  geom_point() +
  binomial_smooth(se = FALSE) +
  #add in some aesthetics
  scale_colour_discrete(name = &amp;quot;buzz cola cans \n(x * 330ml)&amp;quot;) +
  labs(title = &amp;quot;what drink do you want for the departmental picnic?&amp;quot;,
       subtitle = &amp;quot;simulated data&amp;quot;,
       x = &amp;quot;slurm (/ml)&amp;quot;,
       y = &amp;quot;fraction of buzz cola choices&amp;quot;) +
  theme_minimal() +
  facet_wrap(~person)

p5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-24-introduction-to-discrete-choice-analysis_files/figure-html/plot_colleagues_choices-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Andreas shows a step function in choosing between buzz cola and slurm, whereas Béatrice show much more linearity, with lines that pass 0.5 where ml slurm == ml buzz cola.&lt;/p&gt;
&lt;p&gt;I won’t show the code for calculating the optimal parameters for these two as it’s much the same as before, but upon calculation we get&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#the optimal parameters for Andreas and Béatrice
lapply(colleague_parameters, function(x) x$par)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $Andreas
##     beta    rho_a    rho_b 
## 6.208545 5.976904 3.501038 
## 
## $Béatrice
##     beta    rho_a    rho_b 
## 2.806346 1.321279 1.330345&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we can see that Andreas has a much higher temperature (steepness) of his utility curve (beta), whereas Béatrice has a lower calculated beta.&lt;/p&gt;
&lt;p&gt;In contrast, while Andreas has a similar preference for buzz cola to you (rho_a / rho_b ~ 1.5, see below to refresh on your calculated optimal parameters from earlier), the relative utilities of the two sodas are equal (~1.3) for Béatrice, who is indifferent between them.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#your optimal parameters for refreshing memory
optim_params$par&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     beta    rho_a    rho_b 
## 3.520318 2.563380 1.702415&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Plotting the utility curves for these two also shows this&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plot the utility curves per colleague
p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-04-24-introduction-to-discrete-choice-analysis_files/figure-html/plot_colleague_utility_curves-1.png&#34; width=&#34;672&#34; /&gt; Where I’ve used geom_line to link between the points. Andreas’ curve is much steeper than yours which we plotted previously, but passes the indifference point (0.5 on the y axis) at roughly the same place.&lt;/p&gt;
&lt;p&gt;Béatrice’s is less steep but her indifference point is where the ml of the two sodas are equal (x == 1).&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;data-creation&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Data Creation&lt;/h2&gt;
&lt;p&gt;All data in this post is generation using the normal distribution and is fake. However, it approximates what you’d expect real data to look like pretty well so is fine for a tutorial and saves the need to have to upload real lab data.&lt;/p&gt;
&lt;p&gt;I haven’t included the data generation for Andreas and Béatrice’s data, but it follows almost identical steps. Set the sd in pnorm = 0 to achieve the step function.&lt;/p&gt;
&lt;p&gt;The code used to generate the data is provided below&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#set up
library(tidyverse)
set.seed(220892)

#generally cumulative normal distribution curves
#stand in for real choice curve data

#seq over the range of 0-1 of slurm
choice_data &amp;lt;- seq(0, 1, 0.2) %&amp;gt;%
  #generate distributions
  data.frame(x = .,
             y1 = 1-pnorm(., 0.23, 0.15),
             y2 = 1-pnorm(., 0.5, 0.175),
             y3 = 1-pnorm(., 0.75, 0.125)) %&amp;gt;%
  #melt data
  gather(&amp;quot;group&amp;quot;, &amp;quot;dist&amp;quot;, - x) %&amp;gt;%
  #rename data with our variables
  #buzz cola and slurm
  mutate(buzz_cola = case_when(
    group == &amp;quot;y1&amp;quot; ~ 1,
    group == &amp;quot;y2&amp;quot; ~ 2,
    group == &amp;quot;y3&amp;quot; ~ 3
  )) %&amp;gt;%
  mutate(slurm = x * 2000) %&amp;gt;%
  #round dist data
  mutate(fraction_choose_cola = round(dist, 2))  %&amp;gt;%
  select(buzz_cola, slurm, fraction_choose_cola)


#create some fake trial data by stretching this choice data
generate_trial_data &amp;lt;- function(combination_row) {
  #for this combination how many times in cola chosen
  cola_choice &amp;lt;- round(combination_row$fraction_choose_cola*100)
  
  #create a df of 100 trials for this combination
  data.frame(buzz_cola = rep(combination_row$buzz_cola, 100),
             slurm = rep(combination_row$slurm, 100),
             choice = c(rep(&amp;quot;buzz_cola&amp;quot;, cola_choice),
                        rep(&amp;quot;slurm&amp;quot;, 100 - cola_choice))
             )
}

#split choice data by combination (row)
trial_data &amp;lt;- choice_data %&amp;gt;%
  split(f = seq(nrow(.))) %&amp;gt;%
  #apply the stretching function
  lapply(., generate_trial_data) %&amp;gt;%
  #map together the data
  map_df(I) %&amp;gt;%
  #randomly shuffle the data
  .[sample(nrow(.)),]&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
