<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.55.6" />
  <meta name="author" content="Robert Hickman">

  
  
  
  
    
      
    
  
  <meta name="description" content="One of the most consistent fonts of posts on this blog is The Guardian’s football trivia page The Knowledge. A particular reason for this is that the small contained questions lend themselves to small blogposts that I can turn around in an hour or two, as opposed to being endlessly redrafted until I lose interest.
However, I still sometimes don’t quite get round to finishing some of these posts, or have trouble justifying a blog post on a very small and ‘trivial’ answer to a question.">

  
  <link rel="alternate" hreflang="en-us" href="/post/advent_calendar_trivia/">

  


  

  
  
  <meta name="theme-color" content="#0095eb">
  
  
  
  
    
  
  
    
    
      
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
      
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.1/css/academicons.min.css" integrity="sha512-NThgw3XKQ1absAahW6to7Ey42uycrVvfNfyjqcFNgCmOCQ5AR4AO0SiXrN+8ZtYeappp56lk1WtvjVmEa+VR6A==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700%7cRoboto:400,400italic,700%7cRoboto&#43;Mono">
  
  <link rel="stylesheet" href="/styles.css">
  

  

  
  <link rel="alternate" href="/index.xml" type="application/rss+xml" title="Robert Hickman">
  <link rel="feed" href="/index.xml" type="application/rss+xml" title="Robert Hickman">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="/post/advent_calendar_trivia/">

  <meta property="twitter:card" content="summary_large_image">
  
  <meta property="twitter:site" content="@robert_squared">
  <meta property="twitter:creator" content="@robert_squared">
  
  <meta property="og:site_name" content="Robert Hickman">
  <meta property="og:url" content="/post/advent_calendar_trivia/">
  <meta property="og:title" content="Advent Calendar of Football Trivia Analyses | Robert Hickman">
  <meta property="og:description" content="One of the most consistent fonts of posts on this blog is The Guardian’s football trivia page The Knowledge. A particular reason for this is that the small contained questions lend themselves to small blogposts that I can turn around in an hour or two, as opposed to being endlessly redrafted until I lose interest.
However, I still sometimes don’t quite get round to finishing some of these posts, or have trouble justifying a blog post on a very small and ‘trivial’ answer to a question.">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2019-12-01T00:00:00&#43;00:00">
  
  <meta property="article:modified_time" content="2019-12-01T00:00:00&#43;00:00">
  

  <script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
  }
});
</script>
<script async type="text/javascript"
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <title>Advent Calendar of Football Trivia Analyses | Robert Hickman</title>

</head>
<body id="top" data-spy="scroll" data-target="#toc" data-offset="71" >

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      
      <a class="navbar-brand" href="/">Robert Hickman</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      
      <ul class="nav navbar-nav navbar-right">
        

        

        
          
        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="/#publications_selected">
            
            <span>Publications</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="/#projects">
            
            <span>Projects</span>
            
          </a>
        </li>

        
        

        

        
          
        

        <li class="nav-item">
          <a href="/files/cv/cv.pdf">
            
            <span>CV</span>
            
          </a>
        </li>

        
        
      

      
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <div class="article-inner">
      <h1 itemprop="name">Advent Calendar of Football Trivia Analyses</h1>

      

<div class="article-metadata">

  <span class="article-date">
    
    <time datetime="2019-12-01 00:00:00 &#43;0000 UTC" itemprop="datePublished dateModified">
      Dec 1, 2019
    </time>
  </span>
  <span itemscope itemprop="author publisher" itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Robert Hickman">
  </span>

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    28 min read
  </span>
  

  
  

  
  
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Advent%20Calendar%20of%20Football%20Trivia%20Analyses&amp;url=%2fpost%2fadvent_calendar_trivia%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=%2fpost%2fadvent_calendar_trivia%2f"
         target="_blank" rel="noopener">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=%2fpost%2fadvent_calendar_trivia%2f&amp;title=Advent%20Calendar%20of%20Football%20Trivia%20Analyses"
         target="_blank" rel="noopener">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=%2fpost%2fadvent_calendar_trivia%2f&amp;title=Advent%20Calendar%20of%20Football%20Trivia%20Analyses"
         target="_blank" rel="noopener">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Advent%20Calendar%20of%20Football%20Trivia%20Analyses&amp;body=%2fpost%2fadvent_calendar_trivia%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>


      <div class="article-style" itemprop="articleBody">
        


<p>One of the most consistent <a href="https://www.robert-hickman.eu/project/guardian_knowledge/">fonts of posts on this blog</a> is The Guardian’s football trivia page <a href="https://www.theguardian.com/football/series/theknowledge">The Knowledge</a>. A particular reason for this is that the small contained questions lend themselves to small blogposts that I can turn around in an hour or two, as opposed to being endlessly redrafted until I lose interest.</p>
<p>However, I still sometimes don’t quite get round to finishing some of these posts, or have trouble justifying a blog post on a very small and ‘trivial’ answer to a question. Therefore, as a sort of end-of-year round up, and a Christmas present to myself, I wanted to push out answers to questions I found particularly interesting over the last year and hadn’t quite got round to <sup>1</sup>. I’ll probably add them all to this post as I finish them up.</p>
<div id="nd-december---everything-in-its-right-place" class="section level1">
<h1>2nd December - Everything in its right place</h1>
<blockquote class="twitter-tweet">
<p lang="en" dir="ltr">
I wonder if any of any sporting leagues have ever ended in alphabetical order? <a href="https://t.co/you6u8Uzwz">pic.twitter.com/you6u8Uzwz</a>
</p>
— P A Hunt (<span class="citation">@TeachFMaths</span>) <a href="https://twitter.com/TeachFMaths/status/1139832761295024128?ref_src=twsrc%5Etfw">June 15, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<div id="answer---yes-kind-of.-but-also-no." class="section level2">
<h2>Answer - yes, kind of. But also no.</h2>
<p>This question has actually <a href="https://www.theguardian.com/football/2011/mar/09/has-league-ever-finished-alphabetical-order">been answered</a> (as many of these will have been). For a league of 20 teams (like the English Premier League), we might imagine if would have happened over the last ~150 years, but it’s almost certain from some basic maths that it won’t have, and moreover, will never happen.</p>
<p>Let’s load some data and see why.</p>
<pre class="r"><code>#as per usual, going to heavily rely on tidyverse 
#and engsoccerdata throughout these posts
library(tidyverse)
library(engsoccerdata)</code></pre>
<pre class="r"><code>#load English league data
league_data &lt;- engsoccerdata::england %&gt;%
  #select and gather match results
  select(season = Season, division, home, visitor, hgoal, vgoal) %&gt;%
  gather(&quot;location&quot;, &quot;team&quot;, -season, -division, -hgoal, -vgoal) %&gt;%
  mutate(
    g_for = case_when(
      location == &quot;home&quot; ~ hgoal,
      location == &quot;visitor&quot; ~ vgoal
    ),
    g_ag = case_when(
      location == &quot;home&quot; ~ vgoal,
      location == &quot;visitor&quot; ~ hgoal
    )) %&gt;%
  #get correct point for a win/loss
  mutate(
    points = case_when(
      g_for &gt; g_ag &amp; season &lt; 1981 ~ 2,
      g_for &gt; g_ag &amp; season &gt; 1980 ~ 3,
      g_for == g_ag ~ 1,
      g_for &lt; g_ag ~ 0
    ),
    gd = g_for - g_ag
  ) %&gt;%
  #group by season and league and get final tables
  group_by(season, division, team) %&gt;%
  summarise(points = sum(points),
            gd = sum(gd),
            g_for = sum(g_for)) %&gt;%
  arrange(-points, -gd, -g_for) %&gt;%
  #rank league order and alphabetical order
  mutate(league_pos = rank(-points, ties.method = &quot;first&quot;),
         alph_order = rank(team, ties.method = &quot;first&quot;)) %&gt;%
  select(season, division, team, league_pos, alph_order) %&gt;%
  #split by league and season
  split(., f = list(.$season, .$division)) %&gt;%
  keep(function(x) nrow(x) &gt; 0)

#print the top of the first league table
head(league_data[[1]])</code></pre>
<pre><code>## # A tibble: 6 x 5
## # Groups:   season, division [1]
##   season division team                    league_pos alph_order
##    &lt;int&gt;    &lt;int&gt; &lt;chr&gt;                        &lt;int&gt;      &lt;int&gt;
## 1   1888        1 Preston North End                1          9
## 2   1888        1 Aston Villa                      2          2
## 3   1888        1 Wolverhampton Wanderers          3         12
## 4   1888        1 Blackburn Rovers                 4          3
## 5   1888        1 Bolton Wanderers                 5          4
## 6   1888        1 West Bromwich Albion             6         11</code></pre>
<p>We can then run a load of Spearman’s rank correlation tests on the data to see which ones are perfectly correlated or anti-correlated in both league and alphabetical ranking. We’ll use the very handy <a href="https://cran.r-project.org/web/packages/broom/vignettes/broom.html">broom</a> package to tidy the results of our many tests into one data.frame (remove the filter at the end of the pipe chain to see what gets output).</p>
<pre class="r"><code>#use broom to tidily do stats
library(broom)

#correlate league and alphabetical order by year
exact_correlations &lt;- league_data %&gt;%
  map_df(., function(data) {
    cor.test(
      data$league_pos,
      data$alph_order,
      method = &quot;spearman&quot;
    ) %&gt;%
      tidy() %&gt;%
      mutate(season = unique(data$season),
             division = unique(data$division))
  }) %&gt;%
  #take only significantly 
  filter(abs(statistic) == 1)

print(exact_correlations)</code></pre>
<pre><code>## # A tibble: 0 x 7
## # ... with 7 variables: estimate &lt;dbl&gt;, statistic &lt;dbl&gt;, p.value &lt;dbl&gt;,
## #   method &lt;chr&gt;, alternative &lt;chr&gt;, season &lt;int&gt;, division &lt;int&gt;</code></pre>
<p>And so we find no exact correlations. There are no instances in 363 separate seasons of English league football where teams line up in either alphabetical, or anti-alphabetical order.</p>
<p>Let’s see why this is. To make things simpler, I’m going to imagine a cutdown league of only 6 teams using teams starting with each of the first 6 letter of the alphabet:</p>
<pre class="r"><code>first_letter_names &lt;- league_data %&gt;%
  bind_rows() %&gt;%
  ungroup() %&gt;%
  #get first letter of a team name
  mutate(first_letter = gsub(&quot;(^.)(.*)&quot;, &quot;\\1&quot;, team)) %&gt;%
  filter(season &gt; 1992 &amp;
           division == 1 &amp;
           first_letter %in% toupper(letters[1:6])
         ) %&gt;%
  #get one team beginning with A, B, C...
  filter(!duplicated(first_letter)) %&gt;%
  select(team) %&gt;%
  arrange(team) %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 6 x 1
##   team            
##   &lt;chr&gt;           
## 1 Arsenal         
## 2 Blackburn Rovers
## 3 Coventry City   
## 4 Derby County    
## 5 Everton         
## 6 Fulham</code></pre>
<p>For the league to finish in alphabetical order, we first need the team that is first alphabetically (Arsenal) to finish in first position. Assuming all teams have an equal chance of winning the league, the chance of this is obviously</p>
<p><span class="math display">\[ p(Arsenal = 1) =  \frac{1}{n}\]</span></p>
<p>Then we need the second team (Blackburn Rovers), to finish in second. This is predicated on Arsenal already finishing in first position, so the chance becomes</p>
<p><span class="math display">\[ p(Blackburn = 2 | Arsenal = 1) = \frac{1}{n-1} \]</span></p>
<p>and so on until the last team (Fulham) just have to slot into the only position left (n, 6th in our example)</p>
<p>Thus the total chance becomes</p>
<p><span class="math display">\[ \frac{1}{n} \cdot \frac{1}{n-1} ... \cdot \frac{1}{1} \]</span></p>
<p>which can also be written</p>
<p><span class="math display">\[ p(ordered) = \prod_{n = 1}^{N} \frac{1}{n}\]</span></p>
<p>which multiplies out to</p>
<p><span class="math display">\[ p(ordered) = \frac{1}{n!} \]</span></p>
<p>so for our very small league the chance of n (assumed equally strong teams)</p>
<pre class="r"><code>factorial(nrow(first_letter_names))</code></pre>
<pre><code>## [1] 720</code></pre>
<p>so we have a 1/720 chance that this league ends perfectly in alphabetical order. For bigger leagues (for reference most large European leagues contain 18-24 teams) this denominator grows <em>super-exponentially</em> and becomes tiny.</p>
<p>For the English Premier League (20 teams) for instance the chance becomes</p>
<pre class="r"><code>league_data %&gt;%
  bind_rows() %&gt;%
  ungroup() %&gt;%
  filter(season == max(season) &amp; division == 1) %&gt;% 
  nrow() %&gt;%
  factorial()</code></pre>
<pre><code>## [1] 2.432902e+18</code></pre>
<p>or 1 in 2.4 <a href="https://en.wikipedia.org/wiki/Order_of_magnitude">quintillion</a>. In short, if it’s assumed that there’s no relation between order of names and team strength, we might expect the universe to end before all 20 teams finish in perfect order.</p>
<p>We can test if our predictions bear out by looking at tiny leagues with small numbers of teams, e.g. <a href="https://en.wikipedia.org/wiki/2018%E2%80%9319_UEFA_Champions_League_group_stage">the group stages of the Champions/Europa Leagues</a>.</p>
<p>First we need to scrape the final tables for the last 8 years of data from both competitions:</p>
<pre class="r"><code>library(rvest)

#website to scrape group stage data from
fb_data &lt;- &quot;https://footballdatabase.com&quot;
ucl_links &lt;- sprintf(
  &quot;/league-scores-tables/uefa-champions-league-20%s-%s&quot;,
  10:18, 11:19
)
europa_links &lt;- sprintf(
  &quot;/league-scores-tables/uefa-europa-league-20%s-%s&quot;,
  10:18, 11:19
)
#function to scrape the data from these links
get_competition_data &lt;- function(competition, links) {
  data &lt;- links %&gt;%
    paste0(fb_data, .) %&gt;%
    map_df(., function(year) {
      page_read &lt;- read_html(year)
      
      groups &lt;- letters[1:8] %&gt;%
        map_df(., function(group) {
          page_read %&gt;% 
            html_nodes(sprintf(&quot;#total-group-%s &gt; div &gt; table&quot;, group)) %&gt;% 
            html_table(fill = TRUE) %&gt;% 
            as.data.frame() %&gt;%
            mutate(group)
        }) %&gt;%
        mutate(year = gsub(&quot;(.*-)([0-9]{4}-[0-9]{2})&quot;, &quot;\\2&quot;, year))
    }) %&gt;%
    mutate(competition)
}
#scrape and bind the data
uefa_data &lt;- bind_rows(
  get_competition_data(&quot;champions&quot;, ucl_links),
  get_competition_data(&quot;europa&quot;, europa_links)
)
#print a cutdown version of the scraped data
head(uefa_data %&gt;% select(club = Club, points = P, year, competition))</code></pre>
<pre><code>##                club points    year competition
## 1 Tottenham Hotspur     11 2010-11   champions
## 2       Inter Milan     10 2010-11   champions
## 3         FC Twente      6 2010-11   champions
## 4     Werder Bremen      5 2010-11   champions
## 5        Schalke 04     13 2010-11   champions
## 6              Lyon     10 2010-11   champions</code></pre>
<p>So now we have 128 (8 groups x 8 years x 2 competitions) ‘mini-leagues’ each of 4 teams.</p>
<p>We can then munge this data to find all the groups where the teams finish in alphabetical order. We’d expect 128/4! leagues to finish in alphabetical order (or 5.33 to be exact).</p>
<pre class="r"><code>ordered_groups &lt;- uefa_data %&gt;%
  #select relevant informatiob
  select(team = Club, league_pos = X., group, year, competition) %&gt;%
  #by group find where teams finish in alphabetical order
  group_by(year, group, competition) %&gt;%
  mutate(alph_order = rank(team, ties.method = &quot;first&quot;)) %&gt;%
  filter(league_pos == alph_order) %&gt;%
  #keep only group where all (4) teams finish in order
  summarise(n = n()) %&gt;%
  filter(n == 4) %&gt;%
  #join and filter back data
  left_join(uefa_data, ., by = c(&quot;group&quot;, &quot;year&quot;, &quot;competition&quot;)) %&gt;%
  filter(!is.na(n)) %&gt;%
  #select useful information
  select(team = Club, points = P, gd = X..., league_pos = X.,
         group, year, competition) %&gt;%
  #split groups up
  split(., list(.$year, .$group, .$competition)) %&gt;%
  keep(function(x) nrow(x) &gt; 0)</code></pre>
<p>which leaves us with 5 leagues that have finished in order! almost exactly what we’d predict by chance if the first letter of a teams name had no effect on the outcome.</p>
<pre class="r"><code>ordered_groups</code></pre>
<pre><code>## $`2011-12.c.champions`
##                team points gd league_pos group    year competition
## 5           Benfica     12  4          1     c 2011-12   champions
## 6          FC Basel     11  1          2     c 2011-12   champions
## 7 Manchester United      9  3          3     c 2011-12   champions
## 8     Otelul Galati      0 -8          4     c 2011-12   champions
## 
## $`2015-16.c.champions`
##                team points gd league_pos group    year competition
## 9   Atlético Madrid     13  8          1     c 2015-16   champions
## 10          Benfica     10  2          2     c 2015-16   champions
## 11      Galatasaray      5 -4          3     c 2015-16   champions
## 12 Lokomotiv Astana      4 -6          4     c 2015-16   champions
## 
## $`2010-11.f.champions`
##             team points  gd league_pos group    year competition
## 1     Chelsea FC     15  10          1     f 2010-11   champions
## 2      Marseille     12   9          2     f 2010-11   champions
## 3 Spartak Moskva      9  -3          3     f 2010-11   champions
## 4         Žilina      0 -16          4     f 2010-11   champions
## 
## $`2015-16.g.champions`
##                   team points  gd league_pos group    year competition
## 13          Chelsea FC     13  10          1     g 2015-16   champions
## 14         Dynamo Kyiv     11   4          2     g 2015-16   champions
## 15            FC Porto     10   1          3     g 2015-16   champions
## 16 Maccabi Tel Aviv FC      0 -15          4     g 2015-16   champions
## 
## $`2018-19.h.champions`
##                 team points gd league_pos group    year competition
## 17          Juventus     12  5          1     h 2018-19   champions
## 18 Manchester United     10  3          2     h 2018-19   champions
## 19          Valencia      8  0          3     h 2018-19   champions
## 20        Young Boys      4 -8          4     h 2018-19   champions
## 
## $`2012-13.h.europa`
##                      team points gd league_pos group    year competition
## 21         FC Rubin Kazan     14  7          1     h 2012-13      europa
## 22            Inter Milan     11  2          2     h 2012-13      europa
## 23                 Neftçi      3 -4          3     h 2012-13      europa
## 24 Partizan Beograd (SRB)      3 -5          4     h 2012-13      europa</code></pre>
<p>We can also do a larger test by randomly selecting teams out of the English league data we looked at earlier. To do this I need two quick functions: one to sample randomly from the data, and another to carry out the correlation test.</p>
<p>The first takes a number of samples (how many tests to run) and then selects a number of teams from each league sample. For instance, if I chose 3 teams, it might select Liverpool, Manchester United, and Watford, from the <a href="https://en.wikipedia.org/wiki/2018%E2%80%9319_Premier_League">last season of the Premier League</a>. These teams finished 2nd, 6th, and 11th respectively, so this ‘sampled league’ would fulfill the criteria of finishing in alphabetical order.</p>
<pre class="r"><code>set.seed(3459)

#take a random sample of leagues and teams withing those leagues
sample_cutdown_leagues &lt;- function(nteams, nsamples, data) {
  samples &lt;- sample(length(data), nsamples, replace = TRUE)
  
  sampled_league_data &lt;- data[samples]
  
  league_team_serials &lt;- sampled_league_data %&gt;%
    lapply(., nrow) %&gt;%
    lapply(., sample, size = nteams)
  
  #carry out the correlation test
  league_cor_test &lt;- map2_df(
    .x = sampled_league_data,
    .y = league_team_serials,
    .f = cor_test_data
  )
}
  
#function for correlation test
cor_test_data &lt;- function(full_league_data, sampled_teams) {
  sampled_league &lt;- full_league_data[sampled_teams,] %&gt;%
    arrange(league_pos)
  cor_test &lt;- cor.test(
    sampled_league$league_pos,
    sampled_league$alph_order,
    method = &quot;spearman&quot;
  ) %&gt;%
    tidy() %&gt;%
    #mutate on information about that season and teams chosen
    mutate(teams = paste(sampled_league$team, collapse = &quot;, &quot;),
           season = unique(sampled_league$season),
           division = unique(sampled_league$division))
}</code></pre>
<p>So for instance if I just run it once, randomly selecting 4 teams:</p>
<pre class="r"><code>test &lt;- sample_cutdown_leagues(4, 1, league_data)
#print the teams selected
test$teams</code></pre>
<pre><code>## [1] &quot;Brentford, Bristol Rovers, Brighton &amp; Hove Albion, Chester&quot;</code></pre>
<pre class="r"><code>test</code></pre>
<pre><code>## # A tibble: 1 x 8
##   estimate statistic p.value method   alternative teams     season division
##      &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;      &lt;int&gt;    &lt;int&gt;
## 1      0.8      2.00   0.333 Spearma~ two.sided   Brentfor~   1994        3</code></pre>
<p>It gives me 4 teams from the 1994 division 3 who didn’t finish in alphabetical order (though, amusingly, all have a very similar starting letter).</p>
<p>We can then carry this out with 10000 samples for n_team numbers of 2:6 to see if we get roughly the expected numbers of exactly correlated league finish positions (this will take 1-2mins) by finding out how many tests give an estimate of 1 (finished exactly correlated with alphabetical order) or -1 (finished exactly anti-correlated with alphabetical order).</p>
<p>Both these numbers should be roughly equal to the number of samples (10000) divided by the factorial of the number of teams selected.</p>
<pre class="r"><code>test_n_numbers &lt;- function(nteams) {
  #run sampling function n times
  #10k should do
  sampling &lt;- sample_cutdown_leagues(nteams, 10000, league_data)
  
  #find exactly correlated and anti-correlated examples
  #where teams are in exact alphabetical order ascending or descending
  correlated &lt;- length(which(sampling$estimate == max(sampling$estimate)))
  anti_correlated &lt;- length(which(sampling$estimate == min(sampling$estimate)))
  expected &lt;- nrow(sampling) / factorial(nteams)
  
  df &lt;- data.frame(n = nteams,
                   sample_cor = correlated,
                   sample_anticor = anti_correlated,
                   sample_expected = expected)
}
#run the function
testing &lt;- map_df(2:6, test_n_numbers)
#print results
print(testing)</code></pre>
<pre><code>##   n sample_cor sample_anticor sample_expected
## 1 2       5010           4990      5000.00000
## 2 3       1676           1665      1666.66667
## 3 4        367            398       416.66667
## 4 5        101             81        83.33333
## 5 6         14             15        13.88889</code></pre>
<p>And the numbers line up, as we would expect if there is no effect of the first letter of a team’s name upon final league position.</p>
<p>Finally, we can do a Kendall’s correlation test to really see if there is any relationship between alphabetical team name order and final league finish for all out our English league data. We use Kendall instead of a Spearman test here because we grouping all the data together we’re going to have a lot of ties (one team has to finish 1st in every league each year).</p>
<pre class="r"><code>all_data &lt;- league_data %&gt;%
  bind_rows()

#do a big correlation test
kendall_test &lt;- cor.test(all_data$alph_order,
                         all_data$league_pos,
                         alternative = &quot;two.sided&quot;,
                         method = &quot;kendall&quot;) %&gt;%
  tidy() %&gt;%
  print()</code></pre>
<pre><code>## # A tibble: 1 x 5
##   estimate statistic p.value method                         alternative
##      &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;                          &lt;chr&gt;      
## 1   0.0135      1.74  0.0826 Kendall&#39;s rank correlation tau two.sided</code></pre>
<p>And we can see that, even though our p-value is <a href="https://mchankins.wordpress.com/2013/04/21/still-not-significant-2/">‘approaching significance’</a>, it’s not significant at our fairly liberal threshold of 0.05. Even then, the effect size (0.013) is tiny, so there’s no need for Watford to start worrying <a href="https://www.bbc.co.uk/sport/football/50619972">just yet</a>.</p>
<ol style="list-style-type: decimal">
<li>SMALL DIGRESSION: I love blogging on this site and it also has been a great help to me in numerous ways (practice coding/writing, feeling like a “programmer”, for job interviews), but quite a lot of the time feel posts are not quite where I want them (I’m sure this feeling isn’t restricted to me) and so won’t put them up and so that time (sometimes quite a few hours!) I put into them in my spare time feels wasted and makes me feel worse about myself. I’m hoping that pushing out fairly rushed/half formed ideas like this will help with this.</li>
</ol>
</div>
</div>
<div id="rd-december---groan-rangers" class="section level1">
<h1>3rd December - Groan Rangers</h1>
<p><a href="https://www.theguardian.com/football/2019/jul/24/which-teams-were-managed-by-their-all-time-leading-goalscorer">“Berwick Rangers have conceded 42 goals in competitive matches – Scottish League 2, relegation play-off, Scottish League – since last scoring themselves, against Peterhead, on March 19th. Is this a record for a league club (I know they’ve now lost that status, but all of these matches are league level competition)?” asks Huw Richards.</a></p>
<div id="answer---it-beats-any-team-in-the-english-league.-reproducible-code-below-if-you-want-to-check-for-other-leagues." class="section level2">
<h2>Answer - It beats any team in the English league. Reproducible code below if you want to check for other leagues.</h2>
<p>(I did check for most of them in the dataset, although this doesn’t include foreign cup competitions. Nothing seems to get close)</p>
<p>This is quite a nice question from a data munging point of view. It’s extremely quantifiable and only involves a little grouping by.</p>
<p>First we’ll load the libraries we’re relying on in this little project:</p>
<pre class="r"><code>library(engsoccerdata)
library(tidyverse)</code></pre>
<p>I’m going to focus on the English league as it has the most data and also has data on the concurrent cup competitions. It’s super easy to sub in whichever competitions in the engsoccerdata package you want.</p>
<p>We want to first bind the data from the league, league cup, fa cup, and league playoffs together with a little munging. Then we want to gather the data to get the goals scored and goals conceded in each game for each team.</p>
<pre class="r"><code>#bind all the match data together with relevant variables
scoring_data &lt;- bind_rows(
  engsoccerdata::england %&gt;%
    select(date = Date, tier, home, visitor, hgoal, vgoal) %&gt;%
    mutate(date = as.Date(date),
           competition = &quot;league&quot;),
  engsoccerdata::facup %&gt;%
    select(date = Date, home, visitor, hgoal, vgoal) %&gt;%
    mutate(date = as.Date(date),
           tier = NA, 
           competition = &quot;fa_cup&quot;),
  engsoccerdata::leaguecup %&gt;%
    select(date = Date, home, visitor, hgoal, vgoal) %&gt;%
    mutate(date = as.Date(date),
           tier = NA,
           competition = &quot;league_cup&quot;),
  engsoccerdata::englandplayoffs %&gt;%
    select(date = Date, home, visitor, hgoal, vgoal, htier, vtier) %&gt;%
    mutate(date = as.Date(date), 
           tier = (htier+vtier)/2, 
           competition = &quot;league_playoffs&quot;) %&gt;%
    select(-htier, -vtier),
) %&gt;%
  #gather and find matches for each team
  gather(&quot;location&quot;, &quot;team&quot;, -date, -hgoal, -vgoal, -competition, -tier) %&gt;%
  split(f = .$location) %&gt;%
  map2_df(., rev(.), function(df, vs_data) 
    mutate(df, opponent = vs_data$team)
  ) %&gt;%
  #add in goals for and against
  mutate(goals_for = case_when(
    location == &quot;home&quot; ~ hgoal,
    TRUE ~ vgoal
  )) %&gt;%
  mutate(goals_against = case_when(
    location == &quot;visitor&quot; ~ hgoal,
    TRUE ~ vgoal
  )) %&gt;%
  arrange(team, date) %&gt;%
  group_by(team)

head(scoring_data)</code></pre>
<pre><code>## # A tibble: 6 x 10
## # Groups:   team [1]
##   date        tier hgoal vgoal competition location team  opponent
##   &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;   
## 1 1875-11-06    NA     0     0 fa_cup      home     105t~ Crystal~
## 2 1875-11-20    NA     3     0 fa_cup      visitor  105t~ Crystal~
## 3 1876-11-11    NA     3     0 fa_cup      home     105t~ 1st Sur~
## 4 1876-12-14    NA     6     1 fa_cup      visitor  105t~ Oxford ~
## 5 1877-11-07    NA     0     2 fa_cup      home     105t~ Old Har~
## 6 NA            NA    NA    NA fa_cup      visitor  105t~ Minerva 
## # ... with 2 more variables: goals_for &lt;dbl&gt;, goals_against &lt;dbl&gt;</code></pre>
<p>Next we need to find the start of each run of games where a team has failed to score. We can do this by finding the first instance of 0 goals scored using lag(). We’ll then give an id to each ‘run’ of finishing games without scoring.</p>
<p>(I’m aware that teams can also concede goals in a run having scored first in a match but there’s no way to factor that in with the data)</p>
<p>We then use the na.locf() function from the very useful <a href="https://cran.r-project.org/web/packages/zoo/zoo.pdf">zoo</a> package to fill in the runs where no goals have been scored.</p>
<p>We can then finish answering the question (already!) by grouping by run and summing the total number of goals conceded in that time.</p>
<pre class="r"><code>#load the zoo library for helping filling NA values
library(zoo)

dry_runs &lt;- scoring_data %&gt;%
  #find the start of runs
  mutate(run_start = case_when(
    goals_for == 0 &amp; lag(goals_for, default = 1) != 0 ~ 1:n()
  )) %&gt;%
  #only care about games where didn&#39;t score
  filter(goals_for == 0) %&gt;%
  #fill in NAs to get full runs
  mutate(run_id = na.locf(run_start, na.rm = FALSE)) 

longest_dry_runs &lt;- dry_runs %&gt;%
  #group runs by id
  group_by(run_id, team) %&gt;%
  #find total conceeded over n games
  mutate(total_conceeded = sum(goals_against),
         run_start_date = min(date),
         matches = n()) %&gt;%
  #take only the last instance
  filter(!duplicated(run_id, fromLast = TRUE)) %&gt;%
  select(run_start_date, run_end_date = date, team, run_id, total_conceeded, matches) %&gt;%
  #find the most &#39;impressive&#39; runs
  filter(total_conceeded &gt; 15) %&gt;%
  arrange(-total_conceeded)

head(longest_dry_runs)</code></pre>
<pre><code>## # A tibble: 6 x 6
## # Groups:   run_id, team [6]
##   run_start_date run_end_date team           run_id total_conceeded matches
##   &lt;date&gt;         &lt;date&gt;       &lt;chr&gt;           &lt;int&gt;           &lt;dbl&gt;   &lt;int&gt;
## 1 1899-01-14     1899-03-11   Darwen            273              38       7
## 2 1898-11-12     1898-12-26   Darwen            263              35       7
## 3 1891-12-12     1892-01-09   Darwen             60              31       5
## 4 2019-04-09     2019-08-31   Bolton Wander~   5447              29      11
## 5 1877-12-22     1886-10-23   1st Surrey Ri~      8              27       3
## 6 1880-12-18     1894-01-27   Reading             6              27       3</code></pre>
<p>And can see that two 7 game runs from the (now-defunct) <a href="https://en.wikipedia.org/wiki/Darwen_F.C.">Darwen FC</a> are top of the list. Around 1898/1899 the team conceded 35 and 38 goals without scoring themselves.</p>
<p>Manually <a href="https://www.11v11.com/teams/darwen/tab/matches/season/1899/">looking at the data</a>, we can see that these two streaks are broken only by a few losses over Christmas 1898, a losing run of 18 games! Indeed, Darwen only won 2 games that season and set the record for most goals conceded (141).</p>
<p>7 Years earlier, the same team managed an impressive run of letting in 31 goals in just 5 matches, without scoring. If we want to check out the game in this, we can do by left_join() ing our data together</p>
<pre class="r"><code>#joni data to inspect individual games
dry_run_matches &lt;- dry_runs %&gt;%
  left_join(longest_dry_runs, by = c(&quot;team&quot;, &quot;run_id&quot;)) %&gt;%
  filter(!is.na(total_conceeded)) %&gt;%
  select(date, team, opponent, goals_for, goals_against,
         competition, tier, total_conceeded, run_id) %&gt;%
  arrange(-total_conceeded)

#print this
print(filter(dry_run_matches, run_id == 60))</code></pre>
<pre><code>## # A tibble: 5 x 9
## # Groups:   team [1]
##   date       team  opponent goals_for goals_against competition  tier
##   &lt;date&gt;     &lt;chr&gt; &lt;chr&gt;        &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;
## 1 1891-12-12 Darw~ Sunderl~         0             7 league          1
## 2 1891-12-25 Darw~ Blackbu~         0             4 league          1
## 3 1891-12-26 Darw~ Aston V~         0             7 league          1
## 4 1892-01-01 Darw~ Preston~         0             4 league          1
## 5 1892-01-09 Darw~ Burnley          0             9 league          1
## # ... with 2 more variables: total_conceeded &lt;dbl&gt;, run_id &lt;int&gt;</code></pre>
<p>Also, congratulations to the <a href="https://www.boltonwanderers.news/news/efl-discinplinary-panels-decision-on-wanderers-delayed-again/">oft-trouble Bolton Wanderers</a> who have got closest to this in modern times, failing to score in 11 straight matches, while conceding 29 goals in the process.</p>
<p>I also wanted to find out the opposite: the team that has scored the most goals without conceding any. It’s super easy with our pipeline- just switch goals_against and goals_for in the chain.</p>
<pre class="r"><code>#do the inverse
scoring_runs &lt;- scoring_data %&gt;%
  mutate(run_start = case_when(
    goals_against == 0 &amp; lag(goals_against, default = 1) != 0 ~ 1:n()
  )) %&gt;%
  filter(goals_against == 0) %&gt;%
  mutate(run_id = na.locf(run_start, na.rm = FALSE)) 

longest_scoring_runs &lt;- scoring_runs %&gt;%
  group_by(run_id, team) %&gt;%
  mutate(total_scored = sum(goals_for),
         run_start_date = min(date),
         matches = n()) %&gt;%
  filter(!duplicated(run_id, fromLast = TRUE)) %&gt;%
  select(run_start_date, run_end_date = date, team, run_id, total_scored, matches) %&gt;%
  filter(total_scored &gt; 15) %&gt;%
  arrange(-total_scored)

head(longest_scoring_runs)</code></pre>
<pre><code>## # A tibble: 6 x 6
## # Groups:   run_id, team [6]
##   run_start_date run_end_date team            run_id total_scored matches
##   &lt;date&gt;         &lt;date&gt;       &lt;chr&gt;            &lt;int&gt;        &lt;dbl&gt;   &lt;int&gt;
## 1 2010-04-25     2010-08-28   Chelsea           4372           32       7
## 2 1929-03-06     1929-03-30   Bradford City      919           29       5
## 3 2019-01-06     2019-01-26   Manchester City   5194           28       6
## 4 1903-04-10     1903-10-03   Arsenal            328           26       8
## 5 1880-01-17     1880-11-13   Clapham Rovers      25           26       5
## 6 1885-10-24     1885-12-12   Notts County        32           26       3</code></pre>
<p>Where we can see that Chelsea’s impressive end to the 2009-2010 season puts them top, having scored 32 goals without reply. Almost all the other top examples are from pre-war football, except Manchester City coming close last year with 28 goals scored without conceding.</p>
<p>When we look at this run we can see it was greatly helped along by some demolitions in the cups, winning 5-0, 9-0 and 7-0 against Burnley, Burton Albion, and Rotherham United.</p>
<pre class="r"><code>scoring_run_matches &lt;- scoring_runs %&gt;%
  left_join(longest_scoring_runs, by = c(&quot;team&quot;, &quot;run_id&quot;)) %&gt;%
  filter(!is.na(total_scored)) %&gt;%
  select(date, team, opponent, goals_for, goals_against,
         competition, tier, total_scored, run_id) %&gt;%
  arrange(-total_scored)

#print this
print(filter(scoring_run_matches, run_id == 5194))</code></pre>
<pre><code>## # A tibble: 6 x 9
## # Groups:   team [1]
##   date       team  opponent goals_for goals_against competition  tier
##   &lt;date&gt;     &lt;chr&gt; &lt;chr&gt;        &lt;dbl&gt;         &lt;dbl&gt; &lt;chr&gt;       &lt;dbl&gt;
## 1 2019-01-06 Manc~ Rotherh~         7             0 fa_cup         NA
## 2 2019-01-09 Manc~ Burton ~         9             0 league_cup     NA
## 3 2019-01-14 Manc~ Wolverh~         3             0 league          1
## 4 2019-01-20 Manc~ Hudders~         3             0 league          1
## 5 2019-01-23 Manc~ Burton ~         1             0 league_cup     NA
## 6 2019-01-26 Manc~ Burnley          5             0 fa_cup         NA
## # ... with 2 more variables: total_scored &lt;dbl&gt;, run_id &lt;int&gt;</code></pre>
</div>
</div>
<div id="th-december---were-going-to-wembley" class="section level1">
<h1>5th December - We’re going to Wembley</h1>
<blockquote class="twitter-tweet">
<p lang="en" dir="ltr">
Which team has had to travel the shortest combined distance in a cup run? (excluding regional competitions, just to make it interesting)
</p>
— Chris van Thomas (<span class="citation">@chrisvanthomas</span>) <a href="https://twitter.com/chrisvanthomas/status/1148879896430731266?ref_src=twsrc%5Etfw">July 10, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<div id="answer---multiple-teams-have-played-5-fa-cup-matches-all-at-home.-to-answer-the-inverse-question-queens-park-in-18831884-and-18841885-have-had-the-farthest-to-travel" class="section level2">
<h2>Answer - Multiple teams have played 5 FA cup matches all at home. To answer the inverse question, Queen’s Park in 1883/1884 and 1884/1885 have had the farthest to travel</h2>
<p>For this question, I’m actually going to answer the opposite topic- which team have traveled the farthest in a cup run? The reason being is that multiple teams have had cup runs (of 5 matches in the FA cup) without travelling away from home at all. The code below could easily be changed to analyse other cup competitions, for simplicity, I’m sticking with the FA cup which has the most complete data in the engsoccerdata set.</p>
<p>Once again, we’ll start by loading libraries. We also want the <a href="https://r-spatial.github.io/sf/articles/sf1.html">sf</a> package that makes working with spatial data a bit cleaner.</p>
<pre class="r"><code>library(engsoccerdata)
library(tidyverse)
#also want sf to manipulate spatial features
library(sf)</code></pre>
<p>Then we want to grab the data. In a <a href="https://github.com/jalapic/engsoccerdata/commit/6133cf9f6fd77574a5a03097a6d2db4d213c508c">recent update of the engsoccerdata package</a> I added the location of grounds for teams in England which will let us find the distances teams have traveled to matches.</p>
<p>I also download a shapefile of the UK from <a href="https://gadm.org/">GADM</a> for plotting and to filter out any bad data in ground location (which still is very much in beta).</p>
<pre class="r"><code>#download a map of the uk to plot with
shape_url &lt;- &quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_GBR_0_sf.rds&quot;
temp_dir &lt;- tempdir()
download.file(shape_url, destfile = file.path(temp_dir, &quot;shapefiles.rds&quot;), mode = &quot;wb&quot;)
uk &lt;- st_as_sf(readRDS(file.path(temp_dir, &quot;shapefiles.rds&quot;)))

#the location of football grounds in the dataset
grounds &lt;- engsoccerdata::england_locations %&gt;%
  st_as_sf(coords = c(&quot;lon&quot;, &quot;lat&quot;), crs = st_crs(&quot;+init=epsg:4326&quot;)) %&gt;%
  st_transform(crs = st_crs(uk)) %&gt;%
  #remove those that are bad data-outside the uk
  .[seq(nrow(.)) %in% unlist(st_contains(uk, .)),]
#get the fa cup match data
matches &lt;- engsoccerdata::facup</code></pre>
<p>There’s some ambiguity in the question as to how the distance of a cup run should be measured. There’s really two ways we can do this, which I will henceforth refer to as a ‘routing’ as ‘spoking’. To illustrate the two different approaches, I’ll use Southampton’s 2017/2018 FA cup run</p>
<pre class="r"><code>#e.g. with Southampton&#39;s semi final run in 2017/2018
Southampton &lt;- matches %&gt;%
    filter(Season == 2017 &amp; 
             (home == &quot;Southampton&quot; | 
                visitor == &quot;Southampton&quot;)
           ) %&gt;%
  select(Venue, Date, home, visitor, neutral) %&gt;%
  gather(&quot;location&quot;, &quot;team&quot;, -Venue, -Date, -neutral) %&gt;%
  filter(location == &quot;home&quot; | neutral == &quot;yes&quot;) %&gt;%
  filter(!duplicated(Date)) %&gt;%
  mutate(location = case_when(
    neutral == &quot;yes&quot; ~ Venue,
    TRUE ~ team
  ))

#print matches
Southampton</code></pre>
<pre><code>## # A tibble: 5 x 5
##   Venue            Date       neutral location           team              
##   &lt;chr&gt;            &lt;date&gt;     &lt;chr&gt;   &lt;chr&gt;              &lt;chr&gt;             
## 1 Craven Cottage   2018-01-06 &lt;NA&gt;    Fulham             Fulham            
## 2 St Mary&#39;s Stadi~ 2018-01-27 &lt;NA&gt;    Southampton        Southampton       
## 3 The Hawthorns    2018-02-17 &lt;NA&gt;    West Bromwich Alb~ West Bromwich Alb~
## 4 DW Stadium       2018-03-18 &lt;NA&gt;    Wigan Athletic     Wigan Athletic    
## 5 Wembley Stadium  2018-04-22 yes     Wembley Stadium    Chelsea</code></pre>
<p>We’ll join the ground geography data to this to figure out distances traveled</p>
<pre class="r"><code>#will need the location of southamptons ground
Southampton_home &lt;- grounds %&gt;%
  filter(location == &quot;Southampton&quot;)
#and the locations of all their matches
match_locations &lt;- Southampton %&gt;%
  left_join(., select(grounds, location, geometry), by = &quot;location&quot;)</code></pre>
<p>The first method of calculating distance traveled per match (‘spoking’) takes the location of each match, and finds the distance from that team’s home ground. E.g. for Southampton:</p>
<pre class="r"><code>#find the line from southampton&#39;s ground to the match location
spoke_lines &lt;- st_coordinates(match_locations$geometry) %&gt;%
  split(f = rownames(.)) %&gt;%
  #create line from geometry1 to geometry2
  lapply(function(x) {
    mat &lt;- rbind(x, st_coordinates(Southampton_home$geometry))
    line &lt;- st_linestring(mat)
    return(line)
  }) %&gt;%
  #cast to multiline and add projection
  st_multilinestring() %&gt;%
  st_sfc(crs = st_crs(&quot;+init=epsg:4326&quot;))

#plot over uk
p &lt;- ggplot() +
  geom_sf(data = uk) +
  geom_sf(data = spoke_lines, colour = &quot;blue&quot;, size = 1.5) +
  theme_minimal()

plot(p)</code></pre>
<p><img src="/post/2019-12-01-advent_calendar_knowledge_files/figure-html/southampton_spokes-1.png" width="672" /></p>
<pre class="r"><code>#get the total length in metres
st_length(spoke_lines)</code></pre>
<pre><code>## 698614.6 [m]</code></pre>
<p>For any home games, the distance traveled is taken to be 0m.</p>
<p>The second method of calculating distance traveled takes the distance from each match <em>to</em> the next match in run. I.e. it assumes a team stays in their past location until the next round (obviously not true in real life) and finds the distance to the ground for the next round game:</p>
<pre class="r"><code>#need coords separate
coords &lt;- st_coordinates(match_locations$geometry) %&gt;%
  split(f = rownames(.))

#find distance from one coords to next
travel_lines &lt;- mapply(coords, lead(coords), FUN = function(x, y) {
  #for last match no further path
  if(is.na(y)) {
    return(NULL)
  } else {
    mat &lt;- rbind(x, y)
    line &lt;- st_linestring(mat)
    return(line)
  }
}) %&gt;%
  #filter null last element
  .[-which(lengths(.) == 0)] %&gt;%
  st_multilinestring() %&gt;%
  st_sfc(crs = st_crs(&quot;+init=epsg:4326&quot;))

#plot over uk
p &lt;- ggplot() +
  geom_sf(data = uk) +
  geom_sf(data = travel_lines, colour = &quot;blue&quot;, size = 1.5) +
  theme_minimal()

plot(p)</code></pre>
<p><img src="/post/2019-12-01-advent_calendar_knowledge_files/figure-html/southampton_travel-1.png" width="672" /></p>
<pre class="r"><code>#get the length
st_length(travel_lines)</code></pre>
<pre><code>## 684586.7 [m]</code></pre>
<p>So Southampton here begin in London away to Fulham, before travelling to their home in Southampton, then on to Birmingham (West Brom), Wigan, and back to London to play at Wembley.</p>
<p>Now we have the two methods, we need to prep the data we’re going to analyse. As before, this is done by gathering a df of match data so we have one row per match per team in the FA cup. We then group by team-season’s and find how many matches they played in the cup that year. For a ‘cup run’ we assume more than 3 matches have to played.</p>
<pre class="r"><code>#gather each match per team into a separate row
long_campaigns &lt;- matches %&gt;%
  filter(!is.na(Date)) %&gt;%
  select(Season, home, visitor) %&gt;%
  gather(&quot;location&quot;, &quot;team&quot;, -Season) %&gt;%
  #remove rows with missing teams
  filter(!is.na(team)) %&gt;%
  #get the number of fa cup matches per season per team
  group_by(team, Season) %&gt;%
  summarise(matches = n()) %&gt;%
  #assume you need at least 3 matches for a &#39;run&#39;
  filter(matches &gt; 3) %&gt;%
  ungroup() %&gt;%
  arrange(Season) %&gt;%
  mutate(id = 1:n())

long_campaign_matches &lt;- matches %&gt;%
  select(., Season, Date, round, 
         neutral, Venue,
         team = home, opponent = visitor) %&gt;%
  mutate(location = &quot;home&quot;) %&gt;%
  #bind in the opposite data for away teams
  bind_rows(., mutate(select(., Season, Date, round,
                             neutral, Venue,
                             team = opponent, opponent = team),
                      location = &quot;away&quot;)) %&gt;%
  filter(!is.na(team)) %&gt;%
  #left join the data for long campaigns
  left_join(., long_campaigns, by = c(&quot;Season&quot;, &quot;team&quot;)) %&gt;%
  #remove non-long campaigns
  filter(!is.na(matches)) %&gt;%
  #get the location of the match
  mutate(location = case_when(
    neutral == &quot;yes&quot; ~ Venue,
    location == &quot;home&quot; ~ team,
    location == &quot;away&quot; ~ opponent,
  )) %&gt;%
  #left join in the location for the corresponding ground
  left_join(grounds, c(&quot;location&quot;)) %&gt;%
  #select columns
  select(season = Season, date = Date, round, 
         neutral, team, opponent, 
         location, matches, id, geometry)

#print 
head(long_campaign_matches)</code></pre>
<pre><code>## # A tibble: 6 x 10
##   season date       round neutral team  opponent location matches    id
##    &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;      &lt;int&gt; &lt;int&gt;
## 1   1871 1871-12-16 2     &lt;NA&gt;    Crys~ Maidenh~ Crystal~       5     1
## 2   1871 1871-12-16 2     &lt;NA&gt;    Wand~ Clapham~ Wandere~       4     3
## 3   1871 1872-01-20 3     &lt;NA&gt;    Wand~ Crystal~ Wandere~       4     3
## 4   1871 1872-01-27 3     &lt;NA&gt;    Roya~ Hampste~ Royal E~       5     2
## 5   1871 1872-02-17 s     yes     Crys~ Royal E~ Kenning~       5     1
## 6   1871 1872-03-09 s     yes     Roya~ Crystal~ Kenning~       5     2
## # ... with 1 more variable: geometry &lt;POINT [°]&gt;</code></pre>
<p>We can then find the routing distance using a nice trick I found on <a href="https://github.com/r-spatial/sf/issues/799">Stack Overflow</a> to find the distance between each location and the next in the data.frame.</p>
<p>Finally, this is grouped by id and summed to get the total distance traveled in that cup campaign (when judging by the ‘routing’ metric).</p>
<pre class="r"><code>#taken from
#https://github.com/r-spatial/sf/issues/799
#init an empty sfc
empty &lt;- st_as_sfc(&quot;POINT(EMPTY)&quot;)
routing_distances &lt;- long_campaign_matches %&gt;%
  arrange(id, date) %&gt;%
  filter(!is.na(date)) %&gt;%
  group_by(id) %&gt;%
  #find the distance from one game to the next
  mutate(
    distance_to_next = sf::st_distance(
      geometry, 
      lag(geometry, default = empty), 
      by_element = TRUE)
    ) 

#sum the distances
grouped_routing_distances &lt;- routing_distances %&gt;%
  summarise(travel_distance = sum(distance_to_next, na.rm = TRUE)) %&gt;%
  merge(long_campaigns, by = &quot;id&quot;) %&gt;%
  #conver to km
  mutate(total_distance = travel_distance / 1000) %&gt;%
  select(id, team, matches, season = Season, total_distance) %&gt;%
  mutate(av_distance = total_distance / matches) %&gt;%
  arrange(-total_distance)

head(grouped_routing_distances)</code></pre>
<pre><code>##     id             team matches season total_distance av_distance
## 1  111      Queens Park       8   1884       2684.363    335.5454
## 2  668      Exeter City       8   1930       2362.073    295.2592
## 3  293 Newcastle United       8   1904       2316.524    289.5655
## 4  512 Newcastle United       9   1923       2112.232    234.6924
## 5 1182 Newcastle United      10   1954       2017.824    201.7824
## 6 1090        Gateshead       8   1951       2015.698    251.9623</code></pre>
<p>By functionalising our code from earlier, we can easily plot these well-traveled runs. Using the recently-added-to-CRAN <a href="https://github.com/thomasp85/patchwork">patchwork</a> package, we can make multiple plots and stitch them together, e.g. for the 6 FA cup runs with the longest distances traveled we get:</p>
<pre class="r"><code>#functionalise our code from earlier to plot travel routes easier
plot_travel_lines &lt;- function(run_team_year, plot_type) {
  run_matches &lt;- long_campaign_matches %&gt;%
    mutate(id = paste(team, season)) %&gt;%
    filter(id == run_team_year) %&gt;%
    arrange(date)
  coords &lt;- st_coordinates(run_matches$geometry) %&gt;%
    split(f = rownames(.))
  if(plot_type == &quot;travel&quot;) {
    lines &lt;- mapply(coords, lead(coords), FUN = function(x, y) {
    if(is.na(y)) {
      return(NULL)
    } else {
      mat &lt;- rbind(x, y)
      line &lt;- st_linestring(mat)
      return(line)
    }
    }) %&gt;%
    .[-which(lengths(.) == 0)] %&gt;%
    st_multilinestring() %&gt;%
    st_sfc(crs = st_crs(&quot;+init=epsg:4326&quot;))
  } else if(plot_type == &quot;spokes&quot;) {
    home &lt;- grounds %&gt;%
      filter(location == unique(run_matches$team)) %&gt;%
      st_coordinates()
    lines &lt;- lapply(coords, function(x) {
      mat &lt;- rbind(x, home)
      line &lt;- st_linestring(mat)
      return(line)
    }) %&gt;%
      #cast to multiline and add projection
      st_multilinestring() %&gt;%
      st_sfc(crs = st_crs(&quot;+init=epsg:4326&quot;))
  }
  plot &lt;- ggplot() +
    geom_sf(data = uk) +
    geom_sf(data = lines, colour = &quot;blue&quot;, size = 1.5) +
    labs(title = paste(run_team_year)) +
    theme_minimal()
  return(plot)
}

#plot the top six
library(patchwork)
paste(grouped_routing_distances$team[1:6],
      grouped_routing_distances$season[1:6]) %&gt;%
  lapply(., plot_travel_lines, plot_type = &quot;travel&quot;) %&gt;%
  wrap_plots(.)</code></pre>
<p><img src="/post/2019-12-01-advent_calendar_knowledge_files/figure-html/plot_run_travel-1.png" width="672" /></p>
<p>We then need to check this against our other method of evaluating distances in a cup run- the ‘spoking’ method. This is much easier to calculate- all we have to do is left_join() in the location for each team’s home ground, and find the distance between this and the match location.</p>
<p>Then we simply sum the total distances per campaign and plot the longest of these:</p>
<pre class="r"><code>spoke_distances &lt;- long_campaign_matches %&gt;%
  #left join in location data for each team
  left_join(grounds, by = c(&quot;team&quot; = &quot;location&quot;)) %&gt;%
  #calculate distance between each teams home ground and the match location
  mutate(distance = st_distance(geometry.x, geometry.y, by_element = TRUE))

#group by and sum the cup run distances
grouped_spoke_distances &lt;- spoke_distances %&gt;%
  group_by(team, season) %&gt;%
  summarise(total_distance = sum(distance/1000, na.rm = TRUE),
            av_distance = mean(distance/1000, na.rm = TRUE)) %&gt;%
  arrange(-total_distance)

#print
head(grouped_spoke_distances)</code></pre>
<pre><code>## # A tibble: 6 x 4
## # Groups:   team [3]
##   team             season total_distance av_distance
##   &lt;chr&gt;             &lt;dbl&gt;            [m]         [m]
## 1 Queens Park        1883       2150.504    307.2149
## 2 Newcastle United   1923       1974.430    219.3811
## 3 Newcastle United   1951       1957.196    279.5994
## 4 Fulham             1974       1810.676    150.8897
## 5 Newcastle United   1973       1781.279    178.1279
## 6 Queens Park        1884       1702.166    170.2166</code></pre>
<pre class="r"><code>#plot
paste(grouped_spoke_distances$team[1:6],
      grouped_spoke_distances$season[1:6]) %&gt;%
  lapply(., plot_travel_lines, plot_type = &quot;spokes&quot;) %&gt;%
  wrap_plots(.)</code></pre>
<p><img src="/post/2019-12-01-advent_calendar_knowledge_files/figure-html/find_spoke_distances-1.png" width="672" /></p>
</div>
</div>

      </div>

      


<div class="article-tags">
  
  <a class="btn btn-primary btn-outline" href="/tags/the_knowledge">the_knowledge</a>
  
  <a class="btn btn-primary btn-outline" href="/tags/football">football</a>
  
  <a class="btn btn-primary btn-outline" href="/tags/rstats">rstats</a>
  
</div>



    </div>
  </div>

</article>



<div class="article-container article-widget">
  <div class="hr-light"></div>
  <h3>Related</h3>
  <ul>
    
    <li><a href="/post/guardian_knowledge_june/">The Guardian Knowledge June 2019</a></li>
    
    <li><a href="/post/counties_league_points/">Which English County Has Won the Most Points</a></li>
    
    <li><a href="/post/the-knowledge-4th-august-2018/">The Knowledge 4th August 2018</a></li>
    
    <li><a href="/post/dynamic_web_scraping/">Scraping Dynamic Websites with PhantomJS</a></li>
    
    <li><a href="/post/the-knowledge-7th-february-2019/">The Knowledge 7th February 2019</a></li>
    
  </ul>
</div>




<div class="article-container">
  

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2018 &middot; 

      Powered by the
      <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
      <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close btn-large" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Cite</h4>
      </div>
      <div>
        <pre><code class="modal-body tex"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-primary btn-outline js-copy-cite" href="#" target="_blank">
          <i class="fa fa-copy"></i> Copy
        </a>
        <a class="btn btn-primary btn-outline js-download-cite" href="#" target="_blank">
          <i class="fa fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    

    

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js" integrity="sha512-3P8rXCuGJdNZOnUx/03c1jOTnMn3rP63nBip5gOP2qmUh5YAdVAvFZ1E+QLZZbC1rtMrQb+mah3AfYW11RUrWA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.3/imagesloaded.pkgd.min.js" integrity="sha512-umsR78NN0D23AzgoZ11K7raBD+R6hqKojyBZs1w8WvYlsI+QuKRGBx3LFCwhatzBunCjDuJpDHwxD13sLMbpRA==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
      

      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

