<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Robert Hickman on Robert Hickman</title>
    <link>/</link>
    <description>Recent content in Robert Hickman on Robert Hickman</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2018</copyright>
    <lastBuildDate>Fri, 05 Jan 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Slicing the onion 3 ways- Toy problems in R, python, and Julia</title>
      <link>/post/riddler_nba_tour_de_frace/</link>
      <pubDate>Sun, 27 Sep 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler_nba_tour_de_frace/</guid>
      <description>


&lt;p&gt;Between writing up my thesis, applying to jobs &lt;a href=&#34;&#34;&gt;hire me! I’m quite good at programming&lt;/a&gt;, and the ongoing pandemic, I don’t really have time to write full blogposts. I have however decided to brush up my python skills and dive headfirst into Julia. As such, I like to answer the toy problems posted at &lt;a href=&#34;https://fivethirtyeight.com/tag/the-riddler/&#34;&gt;fivethirtyeight’s riddler&lt;/a&gt; weekly. These will likely be even a few weeks late but it motivates me to tend to the blog and keep up my programming.&lt;/p&gt;
&lt;div id=&#34;express&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Express&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;From Zack Beamer comes a baffling brain teaser of basketball, just in time for the NBA playoffs:&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Once a week, folks from Blacksburg, Greensboro, and Silver Spring get together for a game of pickup basketball. Every week, anywhere from one to five individuals will show up from each town, with each outcome equally likely.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Using all the players that show up, they want to create exactly two teams of equal size. Being a prideful bunch, everyone wears a jersey that matches the color mentioned in the name of their city. However, since it might create confusion to have one jersey playing for both sides, they agree that the residents of two towns will combine forces to play against the third town’s residents.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is the probability that, on any given week, it’s possible to form two equal teams with everyone playing, where two towns are pitted against the third?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Extra credit: Suppose that, instead of anywhere from one to five individuals per town, anywhere from one to N individuals show up per town. Now what’s the probability that there will be two equal teams?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a nice little combinatorics problem, as such we can solve it by finding all combinations and then the combinations where the maximum value is equal to the sum of the remaining values:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create lists of possible values for all team a, b, or c
players &amp;lt;- list(a = 1:5, b = 1:5, c = 1:5)
#find all combinations
player_combinations &amp;lt;- do.call(expand.grid, players)

#get the value of the largest team in each combination
largest_team &amp;lt;- apply(player_combinations, 1, max)
#get the sum of the remaining teams in each combination
reamining_players &amp;lt;- apply(player_combinations, 1, function(x) sum(x) - max(x))

#check when these match
matched_teams &amp;lt;- nrow(player_combinations[which(largest_team == reamining_players),])
#find the fraction which match
fraction_even_teams &amp;lt;- matched_teams / nrow(player_combinations)

fraction_even_teams&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So the answer to the main express question is 0.24, or about 1 in 4 chance.&lt;/p&gt;
&lt;p&gt;It’s easy to expand this to multiple players by allowing the first line to take any value:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#rewrite previous chunk as function that takes max_players as an argument
find_matches_fraction &amp;lt;- function(max_players) {
  players &amp;lt;- list(a = seq(max_players), b = seq(max_players), c = seq(max_players))
  player_combinations &amp;lt;- do.call(expand.grid, players)
  
  largest_team &amp;lt;- apply(player_combinations, 1, max)
  reamining_players &amp;lt;- apply(player_combinations, 1, function(x) sum(x) - max(x))
  
  matched_teams &amp;lt;- nrow(player_combinations[which(largest_team == reamining_players),])
  fraction_even_teams &amp;lt;- matched_teams / nrow(player_combinations)
}

#run for n 1:50
fraction_even_teams &amp;lt;- lapply(seq(50), find_matches_fraction)

answers_df &amp;lt;- data.frame(
  townspeople = seq(50),
  chance = unlist(fraction_even_teams)
)

#for plotting
library(ggplot2)

#plot the answers for 1 to n players where max n is 50
p1 &amp;lt;- ggplot(answers_df, aes(x = townspeople, y = chance)) +
  geom_point() +
  geom_line() +
  labs(
    title = &amp;quot;solution to Riddler express&amp;quot;,
    subtitle = &amp;quot;chance of matched team with max n players&amp;quot;,
    x = &amp;quot;max N players per town&amp;quot;,
    y = &amp;quot;chance of even teams&amp;quot;
  ) +
  theme_minimal()

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/solve_express_r_extra-1.png&#34; width=&#34;672&#34; /&gt;
Let’s implement this in python. I won’t comment lines again, the flow of the function is fundamentally the same&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;import itertools

def find_matches_fraction(max_players):
  team_a = range(1,max_players)
  team_b = range(1,max_players)
  team_c = range(1,max_players)
 
  matched_team = []
  for players in list(itertools.product(team_a,team_b,team_c)):
      largest_team = max(players)
     
      l_combinations = list(players)
      l_combinations.pop(l_combinations.index(max(l_combinations)))
      remaining_players = sum(l_combinations)
     
      if remaining_players == largest_team:
          matched_team.append(1)
      else:
          matched_team.append(0)
         
  fraction_success = sum(matched_team) / len(matched_team)
  return(fraction_success)

answer_express = find_matches_fraction(6)
print(answer_express)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And in Julia&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using IterTools

function find_matches_fraction_jl(max_players)
  team_a = 1:max_players
  team_b = 1:max_players
  team_c = 1:max_players
 
  matched_teams = []

  for players in product(team_a, team_b, team_c)
    largest_team = maximum(players)
    other_teams = collect(players)
    deleteat!(other_teams, argmax(players))
    remaining_players = sum(other_teams)
   
    if largest_team == remaining_players
      push!(matched_teams, 1)
    else
      push!(matched_teams, 0)
    end
  end
  
  fraction_success = sum(matched_teams) / length(matched_teams)
  return fraction_success
end&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## find_matches_fraction_jl (generic function with 1 method)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;
answer_express = find_matches_fraction_jl(5);
answer_express&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also run these chunks in R using &lt;a href=&#34;https://rstudio.github.io/reticulate/&#34;&gt;reticulate&lt;/a&gt; and &lt;a href=&#34;https://cran.r-project.org/web/packages/JuliaCall/readme/README.html&#34;&gt;JuliaCall&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#packages to call other languages into R
library(JuliaCall)
library(reticulate)

#run the functions to check answers
py$find_matches_fraction(as.integer(6))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;julia_eval(&amp;quot;find_matches_fraction_jl(5)&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.24&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#microbenchmark to time functions
library(microbenchmark)

#run each function 10000 times
n &amp;lt;- 10000
bench_express &amp;lt;- microbenchmark(
  jl = julia_eval(&amp;quot;find_matches_fraction_jl(5)&amp;quot;),
  py = py$find_matches_fraction(as.integer(6)),
  r = find_matches_fraction(5),
  times = n
)

#plot the speeds of each functions
p2 &amp;lt;- ggplot2::autoplot(bench_express) +
  labs(
    title = &amp;quot;benchmarking of functions for Riddler Express&amp;quot;
  ) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/benchmark_express-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;I’m pretty happy with that. Even my rusty python ends up being faster than the R code (which I wrote for expressiveness and not speed per se), but my first ever solution in Julia outstrips both!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;classic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Classic&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;This month, the Tour de France is back, and so is the Tour de FiveThirtyEight!&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;For every mountain in the Tour de FiveThirtyEight, the first few riders to reach the summit are awarded points. The rider with the most such points at the end of the Tour is named “King of the Mountains” and gets to wear a special polka dot jersey.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;At the moment, you are racing against three other riders up one of the mountains. The first rider over the top gets 5 points, the second rider gets 3, the third rider gets 2, and the fourth rider gets 1.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;All four of you are of equal ability — that is, under normal circumstances, you all have an equal chance of reaching the summit first. But there’s a catch — two of your competitors are on the same team. Teammates are able to work together, drafting and setting a tempo up the mountain. Whichever teammate happens to be slower on the climb will get a boost from their faster teammate, and the two of them will both reach the summit at the faster teammate’s time.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;As a lone rider, the odds may be stacked against you. In your quest for the polka dot jersey, how many points can you expect to win on this mountain, on average?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A quick guess can be gotten by assuming there were &lt;em&gt;no&lt;/em&gt; teams and just taking the expected points after random assignment&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;riders &amp;lt;- 4
points &amp;lt;- c(5,3,2,1)

sum(points/riders)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.75&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then work out the answer to the classic analytically by calculating the chance that the rider is bumped back a spot for any position they find themselves in. For instance, if they finish 2nd, there is a 1 in 2 chance the rider ahead of them is part of the team, which would bump our rider into 3rd to make run for the teammate.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;expected_points &amp;lt;- 
  #first
  (points[1] / riders) + 
  #second
  (points[2] / riders)/(riders-1) + 2 * (points[(riders-1)] / riders)/(riders-1) + 
  #third
  (points[(riders-1)] / riders) / (riders-1) + 2 *(points[riders] / riders)/(riders-1) + 
  #last
  (points[riders] / riders)

expected_points&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.416667&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we have our answer, but what about for any combination of team and points? We can write an R function to assign riders to teams and simulating many races to get an estimate of the total points. We could again solve these analytically, but that wouldn’t really benefit my programming.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_team_points &amp;lt;- function(teams, points) {
  team_pos &amp;lt;- sample(unique(teams), length(unique(teams)), prob = table(teams))
  all_positions &amp;lt;- unlist(lapply(team_pos, function(p) rep(p, length(which(p == teams)))))
  team_points &amp;lt;- lapply(unique(teams), function(i) sum(points[which(all_positions == i)]))
  names(team_points) &amp;lt;- unique(teams)
  return(team_points)
}

sim_race &amp;lt;- function(n_riders, n_per_team = 2, points = c(5,3,2,1), times = 1000) {
  leftover_riders &amp;lt;- (n_riders-1) %% n_per_team
 
  teams &amp;lt;- (n_riders - leftover_riders - 1) / n_per_team
 
  teamed_riders &amp;lt;- c(
    rep(seq(teams), each = n_per_team),
    rep(max(teams)+1, leftover_riders),
    999
  )
 
  all_points &amp;lt;- c(
    points,
    rep(0, n_riders - length(points))
  )
 
  simmed_points &amp;lt;- unlist(purrr::rerun(times, get_team_points(teamed_riders, all_points)))
  expected_points &amp;lt;- tapply(simmed_points, names(simmed_points), sum) / times
  expected_points[names(expected_points) == 999]
}

expected_points &amp;lt;- sim_race(4, 2, points = c(5,3,2,1), times = 10000)
expected_points&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    999 
## 2.4188&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For a range of n riders and team sizes, we can calculate our riders expected points per race (we’ll use the same point structure of c(1:n-1, n+1)) for a little extra flourish&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;riders &amp;lt;- 1:20
n_per_team &amp;lt;- 1:5

library(dplyr)

arguments &amp;lt;- expand.grid(riders, n_per_team) %&amp;gt;%
  dplyr::rename(n_riders = Var1, n_per_team = Var2) %&amp;gt;%
  #must be more riders than riders per team
  dplyr::filter(n_riders &amp;gt; n_per_team)
arguments$points &amp;lt;- lapply(arguments$n_riders, function(r) c(r+1, (r-1):1))

#use map2
library(purrr)

sims &amp;lt;- 1000
arguments$expected_points &amp;lt;- pmap_dbl(arguments, sim_race, times = sims)

#plot the expected points
p3 &amp;lt;- ggplot(arguments, aes(x = n_riders, y = n_per_team)) +
  geom_tile(aes(fill = expected_points / (n_riders+1))) +
  scale_fill_viridis_c(option = &amp;quot;plasma&amp;quot;, name = &amp;quot;expected points\n / max possible points&amp;quot;) +
  labs(
    title = &amp;quot;solution to Riddler classic&amp;quot;,
    subtitle = &amp;quot;expected points for our rider&amp;quot;,
    x = &amp;quot;total n riders&amp;quot;,
    y = &amp;quot;number of riders per team&amp;quot;
  ) +
  theme_minimal()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/extra_credit_classic-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Lets now port our function for this over the python…&lt;/p&gt;
&lt;pre class=&#34;python&#34;&gt;&lt;code&gt;from numpy.random import choice
import numpy as np
import pandas as pd
import math
import itertools

def sim_race_py(n_riders, n_per_team, points):
  n_teams = math.ceil((n_riders - 1) / n_per_team) + 1
  filled_teams = math.floor((n_riders - 1) / n_per_team)
  leftover_riders = (n_riders - 1) % n_per_team
  
  if leftover_riders &amp;gt; 0:
    extra_riders = [leftover_riders, 1]
  else:
    extra_riders = 1
  
  if filled_teams == 1:
    win_prob = [n_per_team, extra_riders]
  else:
    win_prob = [n_per_team] * filled_teams
    win_prob.extend([extra_riders])
  flattened_probs = list(pd.core.common.flatten(win_prob))
  
  sum_probs = np.sum(flattened_probs)
  adjusted_probs = [p/sum_probs for p in flattened_probs]
  
  no_teams = list(range(len(flattened_probs)))
  
  finish_order = choice(no_teams, len(no_teams), p = adjusted_probs, replace = False)
  
  expanded_finish_order = []
  for team in finish_order:
   if team &amp;lt; filled_teams:
     expanded_finish_order += [team] * n_per_team
   else:
      if team != max(no_teams):
        expanded_finish_order += [team] * leftover_riders
      else:
        expanded_finish_order += [team]
  
  won_points = points[np.argmax(expanded_finish_order)]
  return won_points

def sim_races_py(n_riders, n_per_team, points, n_times):
  won_points = []
  for _ in range(n_times):
    sim_points = sim_race_py(n_riders, n_per_team, points)
    won_points.append(sim_points)
    expected_points = np.sum(won_points) / len(won_points)
    
  return(expected_points)
  
answer_classic = sim_races_py(4,2,[5,3,2,1], 10000)
print(answer_classic)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2.3907&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;…and in Julia&lt;/p&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;using StatsBase

function sim_race_jl(n_riders, n_per_team, points);
  n_teams = Int(ceil((n_riders - 1) / n_per_team));
  filled_teams = Int(floor((n_riders - 1) / n_per_team));
  leftover_riders = mod(n_riders - 1, n_per_team);
  
  if leftover_riders &amp;gt; 0
    extra_riders = [leftover_riders, 1];
  else
    extra_riders = 1;
  end
  
  if filled_teams == 1
    win_prob = vcat(n_per_team, extra_riders);
  else
    win_prob = vcat(repeat([n_per_team], filled_teams), extra_riders);
  end
  
  finish_order = sample(1:length(win_prob),
                        ProbabilityWeights(win_prob), 
                        length(win_prob), 
                        replace = false
  );
  
  expanded_finish_order = Vector{Int}();
  for team in finish_order
    if team &amp;lt;= filled_teams
       append!(expanded_finish_order, repeat([team], n_per_team));
    else
      if team != length(finish_order)
        append!(expanded_finish_order, repeat([team], leftover_riders));
      else
        append!(expanded_finish_order, team);
      end
    end
  end
  
  rider_position = findall(expanded_finish_order .== maximum(expanded_finish_order));
  points_won = points[rider_position];
return points_won
end&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## sim_race_jl (generic function with 1 method)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;
function sim_races_jl(n_riders, n_per_team, points, n_times);
  won_points = Vector{Int}();
  
  for _ in 1:n_times
    sim_points = sim_race_jl(n_riders, n_per_team, points);
    append!(won_points, sim_points);
  end
    
  expected_points = sum(won_points) / length(won_points);
    
  return expected_points;
end&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## sim_races_jl (generic function with 1 method)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;julia&#34;&gt;&lt;code&gt;
answer_classic = sim_races_jl(4,2,[5,3,2,1], 10000);
answer_classic&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 2.3966&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then lets benchmark each of these functions again&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#run each function 10000 times
n &amp;lt;- 10000

bench_classic &amp;lt;- microbenchmark(
  jl = julia_eval(&amp;quot;sim_race_jl(4,2,[5,3,2,1])&amp;quot;),
  py = py$sim_race_py(as.integer(4),as.integer(2),c(5,3,2,1)),
  r = sim_race(4,2,c(5,3,2,1), times = 1),
  times = n
)

#plot the speeds of each functions
p4 &amp;lt;- ggplot2::autoplot(bench_classic) +
  labs(
    title = &amp;quot;benchmarking of functions for Riddler Classic&amp;quot;
  ) +
  theme_minimal()

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-09-27-riddler_nba_and_tour_files/figure-html/benchmark_classic-1.png&#34; width=&#34;672&#34; /&gt;
A bit closer this time. I think I haven’t quite got efficiency for more involved functions down for python and Julia. Julia still wins this round but I feel could be speed up by at least a factor 2 or 3x.&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>The Riddler - June 26th</title>
      <link>/post/riddler_june_26th/</link>
      <pubDate>Mon, 29 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/riddler_june_26th/</guid>
      <description>


&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#for working with polygons
library(sf)
library(sfheaders)

library(tidyverse)
library(gtools)

set.seed(22081992)&lt;/code&gt;&lt;/pre&gt;
&lt;div id=&#34;riddler-express&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Riddler Express&lt;/h1&gt;
&lt;p&gt;This weeks express deals with an erratic driver:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;In Riddler City, the city streets follow a grid layout, running north-south and east-west. You’re driving north when you decide to play a little game. Every time you reach an intersection, you randomly turn left or right, each with a 50 percent chance.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;After driving through 10 intersections, what is the probability that you are still driving north?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;So all we have to do is create a binomial tree of depth 10 and then sum by final heading direction. As the driver &lt;em&gt;must&lt;/em&gt; turn left or right at each junction, we actually only have to consider the final turn as this will change it from whichever North/South or East/West it is heading to the other with p = 0.5. But if we want to prove this, let’s consider it as a more canonical ball-drawing probability task where one can draw balls from a bag:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red (right) ball with probability p or&lt;/li&gt;
&lt;li&gt;Lime (left) ball with probability q&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;drawing balls 10 times without replacement&lt;/p&gt;
&lt;p&gt;We know that as there are only two balls, the total probability is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q) = 1 \]&lt;/span&gt;
on the first pick we are just choosing p or q so can raise everything to the power 1 (pick) to get the same formula:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^1 = 1^1 \]&lt;/span&gt;
and can generalise to n picks&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^n = 1^n \]&lt;/span&gt;
to expand this we’re going to get combinations of p and q to the powers from 0:n, multiplied by the combinatorics from &lt;a href=&#34;https://en.wikipedia.org/wiki/Pascal%27s_triangle&#34;&gt;Pascal’s triangle&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;If we set this multiplication as m, we can express this as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ m = \frac{n!}{(n-k!)k!} \]&lt;/span&gt;
(where k is 0:n)&lt;/p&gt;
&lt;p&gt;so for n = 10 (turns of the car, or picks of a ball), we get&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate pascals triangle via factorials
calc_pascal &amp;lt;- function(n,k) {
  factorial(n) / (factorial(n-k) * factorial(k))
}

#run for n turns
n_turns &amp;lt;- 10
m = map2_dbl(n_turns, 0:n_turns, calc_pascal)
m&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1]   1  10  45 120 210 252 210 120  45  10   1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so for&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ (p + q)^{10}\]&lt;/span&gt;
we will expand this into&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ 1p^{10} + 10p^9q + 45p^8q^2 + 120 p^7q^3 + 210p^6q^4 + 252p^5q^5 + 210p^4q^6 + 120p^3q^7 + 45p^2q^8 + 10pq^9 + 1q^{10}\]&lt;/span&gt;
But where we now diverge from the balls in a bag, each time we draw (/turn), the position of our car updates. We don’t care about the probability of each of these per se, but the probabilities grouped by the final direction of the car.&lt;/p&gt;
&lt;p&gt;It should be clear that every p draw (a right turn), moves the car 1 cardinal direction to the right, whereas a left turn moves it -1 cardinal direction. In our expansion we have 210 examples of drawing 6 right turns and 4 left turns, which would end up having the car face due south (2 cardinal turns). For each term, we just have to minus the exponent of the left turns from the exponent of the right turns, then find the direction by taking the 4th modulus of this.&lt;/p&gt;
&lt;p&gt;For a binomial expansion like this, it’s very easy:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate the end heading for each term of the expansion
term_direction = (n_turns:0 - 0:n_turns) %% 4
term_direction&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 2 0 2 0 2 0 2 0 2 0 2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so we’re either going to end up facing north (0 overall turn) or south (2 overall turns). We can then multiply these by the m for each term&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#list of cardinal direction
final_directions &amp;lt;- c(&amp;quot;north&amp;quot;, &amp;quot;east&amp;quot;, &amp;quot;south&amp;quot;, &amp;quot;west&amp;quot;)

#loop through each expansion term to get the final direction
direction_p &amp;lt;- c()
for(d in 0:3) {
  direction_p[d+1] &amp;lt;- sum(m[term_direction == d])
}

#find the probability of facing any direction
names(direction_p) &amp;lt;- final_directions
direction_p / sum(direction_p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## north  east south  west 
##   0.5   0.0   0.5   0.0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so we have a 50% chance of ending up facing either north or south. So the answer to this weeks riddler express is&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[p(North) = 0.5 \]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&#34;extra-credit&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extra Credit&lt;/h2&gt;
&lt;p&gt;For extra credit, the driver decides instead to turn left, right, or continue straight with equal probability (1/3). In addition to p and q, we now also have an r probability where&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ r = p(No Turn) \]&lt;/span&gt;
We can then use expand.grid() to produce combinations of these three probabilities, and count the combinations by number of each of these:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find combinations of p, q, and r
extra_credit &amp;lt;- expand.grid(rep(list(c(&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;)), n_turns)) %&amp;gt;%
  #label each combination
  mutate(id = 1:n()) %&amp;gt;%
  #count numbers of p, q, and r
  pivot_longer(cols = starts_with(&amp;quot;Var&amp;quot;)) %&amp;gt;%
  group_by(id, value) %&amp;gt;%
  summarise(n = n()) %&amp;gt;%
  #pivot back to wide
  pivot_wider(id_cols = id, names_from = value, values_from = n) %&amp;gt;%
  mutate_at(c(&amp;quot;p&amp;quot;, &amp;quot;q&amp;quot;, &amp;quot;r&amp;quot;),  ~replace(., is.na(.), 0)) %&amp;gt;%
  #count numbers of each combination
  group_by(p, q, r) %&amp;gt;%
  summarise(n = n()) %&amp;gt;%
  arrange(n)

extra_credit&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 66 x 4
## # Groups:   p, q [66]
##        p     q     r     n
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;int&amp;gt;
##  1     0     0    10     1
##  2     0    10     0     1
##  3    10     0     0     1
##  4     0     1     9    10
##  5     0     9     1    10
##  6     1     0     9    10
##  7     1     9     0    10
##  8     9     0     1    10
##  9     9     1     0    10
## 10     0     2     8    45
## # ... with 56 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we might expect, we get the same number of each combinations, but with 3x combinations for each x^n y^n (for each combination of p, q, and r). As we know that the final heading will be the difference in number of right and left turns, we can subtract these and count the number of combinations leading to each direction&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;extra_credit_answer &amp;lt;- extra_credit %&amp;gt;%
  mutate(net_turns = p - q) %&amp;gt;%
  mutate(final_direction = net_turns %% 4) %&amp;gt;%
  .$final_direction %&amp;gt;%
  table()

names(extra_credit_answer) &amp;lt;- final_directions
extra_credit_answer / sum(extra_credit_answer)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     north      east     south      west 
## 0.2727273 0.2272727 0.2727273 0.2272727&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;giving us an answer of&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ p(North) = 0.\dot{2}\dot{7} \]&lt;/span&gt;
# Riddler Classic&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Polly Gawn loves to play “connect the dots.” Today, she’s playing a particularly challenging version of the game, which has six unlabeled dots on the page. She would like to connect them so that they form the vertices of a hexagon. To her surprise, she finds that there are many different hexagons she can draw, each with the same six vertices.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;What is the greatest possible number of unique hexagons Polly can draw using six points?&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;This is a pretty tricky question! I can’t see any way to analytically solve it and given that it involves polygons (and not just pure numbers) it seems like a tricky question to brute force. That doesn’t mean we can’t try though.&lt;/p&gt;
&lt;p&gt;Let’s start by using the data in the hint- that for n = 4 points, the maximum number is 3 polygons, given that the fourth point lies within an enclosing triangle of the other three. We can generate some points randomly for this pretty easily, and use the &lt;a href=&#34;https://r-spatial.github.io/sf/articles/sf1.html&#34;&gt;simple features&lt;/a&gt; package to test the properties of the resulting polygons:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#generate 3 random points
points &amp;lt;- data.frame(
  x = runif(3),
  y = runif(3)
)

#create a triangle from these points
triangle &amp;lt;- sf_polygon(points)

#randomly generate a fourth point within the bounding box of these points
new_point &amp;lt;- data.frame(
  x = runif(1, min = min(points$x), max = max(points$x)),
  y = runif(1, min = min(points$y), max = max(points$y))
)

#keep generate this point until it lies within the triangle of the previous 3
while(length(unlist(st_contains(triangle, sf_point(new_point)))) ==0) {
  new_point &amp;lt;- data.frame(
    x = runif(1, min = min(points$x), max = max(points$x)),
    y = runif(1, min = min(points$y), max = max(points$y))
  )
}

#bind the fourth point onto the previous 3
points &amp;lt;- rbind(points, new_point)

#plot the points
p2 &amp;lt;- ggplot() +
  #triangle
  geom_sf(data = triangle, alpha = 0.1) +
  geom_point(data = points, aes(x, y), 
             shape = 21, fill = &amp;quot;skyblue&amp;quot;, colour = &amp;quot;black&amp;quot;, size = 3) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/generate_four_points-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Now we need to brute force through every possible polygon. To do this we can use combinatorics again, this time with the permutations() function from the gtools package. We create every possible route of points, then take only the routes that start on the first point (to cut down our search space, as many routes will be the same just shifted to a different start node)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create all possible routes of 4 points
routes &amp;lt;- permutations(4, 4, 1:4) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  #filter those beginning with node 1
  filter(V1 == 1)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For each route we then create the resulting polygon by ordering the points and creating a simple features polygon. These are then bound together and each given an id.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#cycle through routes to create polygons
for(r in seq(nrow(routes))) {
  nodes &amp;lt;- as.numeric(routes[r,])
  sf_points &amp;lt;- points[nodes,]
  sf &amp;lt;- sf_polygon(sf_points)
  
  if(r == 1) {
    polygons &amp;lt;- sf
  } else {
    polygons &amp;lt;- rbind(polygons, sf)
  }
}

polygons$id &amp;lt;- 1:nrow(polygons)

#plot the resulting polygons
p3 &amp;lt;- ggplot() +
  geom_sf(data = polygons, fill = &amp;quot;dodgerblue&amp;quot;) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/test_resulting_polygons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;However, we know that there are only 3 unique polygons for n = 4 points. Why have we found 6? From inspection it’s pretty clear that even though they all have unique paths, 3 of these are duplicates of 3 others. This occurs as for each starting node, there are two paths to create each polygon, a ‘clockwise’ path and an ‘anticlockwise’ one.&lt;/p&gt;
&lt;p&gt;We can easily test for this and remove half the polygons as such:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test for duplicate polygons
duplicates &amp;lt;- as.data.frame(st_equals(polygons, polygons)) %&amp;gt;%
  #ignore self matches
  filter(row.id != col.id) %&amp;gt;%
  mutate(id = 1:n()) %&amp;gt;%
  #remove the last 3 polygons
  top_frac(0.5, id)

polygons &amp;lt;- polygons[-duplicates$row.id,]

#replot
p4 &amp;lt;- ggplot() +
  geom_sf(data = polygons, fill = &amp;quot;dodgerblue&amp;quot;) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/remove_duplicate_polygons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And we have our 3 unique polygons. For a higher number n, we want to spin out and generalise two functions:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;one to create points on a ‘page’&lt;/li&gt;
&lt;li&gt;one to build as many unique polygons as possible&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To create points, we can pretty much verbatim take the previous code. I’ve added a second argument of how many points should lie within a perimeter triangle of points, though this will always be n-3 (where n &amp;gt; 3), as far as I can see.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#take our previous code for any n
create_points &amp;lt;- function(sides, within) {
  points &amp;lt;- data.frame(
    x = runif(sides - within),
    y = runif(sides - within)
  )
  perimeter &amp;lt;- sf_polygon(points)
  
  new_points &amp;lt;- data.frame(
    x = runif(within, min = min(points$x), max = max(points$x)),
    y = runif(within, min = min(points$y), max = max(points$y))
  )

  while(length(unlist(st_contains(perimeter, sf_point(new_points)))) != within) {
    new_points &amp;lt;- data.frame(
      x = runif(within, min = min(points$x), max = max(points$x)),
      y = runif(within, min = min(points$y), max = max(points$y))
    )
  }
  
  points &amp;lt;- rbind(points, new_points) %&amp;gt;%
    mutate(id = 1:n())
  return(points)
}

#run to create a pentagon
five_points &amp;lt;- create_points(5, 2)

#plot the five points
p5 &amp;lt;- ggplot() +
  geom_point(data = five_points, aes(x, y, fill = as.factor(id)),
             shape = 21, colour = &amp;quot;black&amp;quot;, size = 3) +
  scale_fill_discrete(guide = FALSE) +
  theme_minimal()

p5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/generalise_point_creation-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The second function (to test how many polygons can be drawn) needs two minor tweaks. Polygons are created as before, but to test for duplicates, we now take the smaller id each time, and also use st_is_valid() to check that the polygon does not contain any self-intersections (where lines cross each other).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#create polygons for n points
get_unique_polygons &amp;lt;- function(points) {
  #create polygons as before
  sides &amp;lt;- nrow(points)
  routes &amp;lt;- permutations(sides, sides, 1:sides) %&amp;gt;%
    as.data.frame() %&amp;gt;%
    filter(V1 == 1)
  
  for(r in seq(nrow(routes))) {
    nodes &amp;lt;- as.numeric(routes[r,])
    sf_points &amp;lt;- points[nodes,]
    sf &amp;lt;- sf_polygon(sf_points)
    
    if(r == 1) {
      polygons &amp;lt;- sf
    } else {
      polygons &amp;lt;- rbind(polygons, sf)
    }
  }
  
  polygons$id &amp;lt;- 1:nrow(polygons)
  
  #find duplicate polygons
  duplicates &amp;lt;- as.data.frame(st_equals(polygons, polygons)) %&amp;gt;%
    filter(row.id != col.id) %&amp;gt;%
    mutate(smaller = case_when(
      row.id &amp;lt; col.id ~ row.id,
      col.id &amp;lt; row.id ~ col.id
    ))
  #always take the smaller id
  polygons &amp;lt;- polygons[polygons$id %in% duplicates$smaller,]
  #test for valid polygons
  #i.e. no self-intersections
  polygons &amp;lt;- polygons[st_is_valid(polygons),]
  
  return(polygons)
}

#create pentagons
pentagons &amp;lt;- get_unique_polygons(five_points)
#calculate and arrange by the area of each for aesthetics
pentagons$area &amp;lt;- st_area(pentagons)
pentagons &amp;lt;- pentagons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#plot the unique pentagons
p6 &amp;lt;- ggplot() +
  geom_sf(data = pentagons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id, nrow = 2)

p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/create_polygons_function-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So for 5 points, the answer seems to be 8 unique polygons that can be drawn.&lt;/p&gt;
&lt;p&gt;For higher n, I then ran these function repeatedly and found the largest number of polygons for any random allocation of points, I’ve used 6 here, but the number can be any. At n = 6 points it’s already struggling (my code here wasn’t written for efficiency) and at 7 is reaaalllly slow, so the loops can be arbitrarily large and run while you make dinner/watch TV etc.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#very dirty inefficient brute force code
all_n &amp;lt;- c()
n_points &amp;lt;- 6
for(i in 1:1){
  #randomly create points
  points &amp;lt;- create_points(n_points, n_points-3)
  #build polygons from these
  polygon &amp;lt;- get_unique_polygons(points)
  n &amp;lt;- nrow(polygon)
  all_n[i] &amp;lt;- n
  #report back from the loop
  print(paste(i, &amp;quot;loops run&amp;quot;))
  print(paste(&amp;quot;biggest n so far is&amp;quot;, max(all_n)))
  print(all_n)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;1 loops run&amp;quot;
## [1] &amp;quot;biggest n so far is 24&amp;quot;
## [1] 24&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;While I was running this to check if I’d missed anything, I tried to solve the problem logically (but not analytically). It seemed clear that you want as many points within larger perimeter triangle of 3 points. It also seemed like you wanted to make sure that none of these points were on a straight line of 3 points (which would limit the number of possible connections of those 3 points). For n = 6 I settled on a slightly offset (by rounding errors) triangle-within-a-triangle&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#logic-created six points
six_points &amp;lt;- data.frame(
  x = c(0, 1, 0.55, 0.25, 0.75, 0.45),
  y = c(0, 0, sqrt(0.75), 0.22, 0.22, 0.65)
)


#plot the six points
p7 &amp;lt;- ggplot() +
  geom_point(data = six_points, aes(x, y),
             shape = 21, fill = &amp;quot;skyblue&amp;quot;, colour = &amp;quot;black&amp;quot;, size = 3) +
  theme_minimal()

p7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/six_points-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;if we pass these points through our function we find that it can create 29 unique polygons (the same number I found from ~100 loops of my brute force attack). Plotting them as before, these are:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test the six points and munge
heaxgons &amp;lt;- get_unique_polygons(six_points)
heaxgons$area &amp;lt;- st_area(heaxgons)
heaxgons &amp;lt;- heaxgons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#plot
p8 &amp;lt;- ggplot() +
  geom_sf(data = heaxgons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)
  
p8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/create_hexagons-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;This isn’t a proof, but I feel reasonably confident in this as the answer for the classic&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;extra-credit-1&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Extra Credit&lt;/h2&gt;
&lt;p&gt;As mentioned, now we want to find this for 7 points creating heptagons. Given we can now fit 4 spare points inside our original triangle, I decided to see what would happen if you stretched the triangle-within-a-triangle and point the final point inside this.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#logic-created seven points
#stretched y axis on point six
#point seven lies within new triangle
seven_points &amp;lt;- data.frame(
  x = c(0, 1, 0.55, 0.25, 0.75, 0.5, 0.45),
  y = c(0, 0, sqrt(0.75), 0.22, 0.22, 0.75, 0.65)
)

#munge our heptagons
heptagons &amp;lt;- get_unique_polygons(seven_points)
heptagons$area &amp;lt;- st_area(heptagons)
heptagons &amp;lt;- heptagons %&amp;gt;%
    arrange(area) %&amp;gt;%
    mutate(id = 1:n())

#aaaaand plot
p9 &amp;lt;- ggplot() +
  geom_sf(data = heptagons, aes(fill = area)) +
  scale_fill_continuous(guide = FALSE) +
  theme_minimal() +
  theme(axis.text = element_blank()) +
  facet_wrap(~id)
  
p9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-06-28-riddlerjune26_files/figure-html/test_heptagon-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Again, running a brute force (though for few iterations as seven really stretches the inefficient code here), 91 polygons seems a common end point, which is pretty close. I think there’s probably a very limited error on the difference between 91 and 92 polygons, so I maybe got lucky. But who knows?&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;final-answers&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Final Answers&lt;/h1&gt;
&lt;div id=&#34;express&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Express&lt;/h2&gt;
&lt;div id=&#34;section&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;0.5&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&#34;extra-credit-0.27-recurring&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;extra credit: 0.27 recurring&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;classic&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Classic&lt;/h2&gt;
&lt;div id=&#34;section-1&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;29&lt;/h3&gt;
&lt;/div&gt;
&lt;div id=&#34;section-2&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;92&lt;/h3&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>#TidyTuesday - Building Stalk Portfolios with R</title>
      <link>/post/how_i_made_my_millions/</link>
      <pubDate>Sun, 17 May 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/how_i_made_my_millions/</guid>
      <description>


&lt;p&gt;Every Tuesday, the R4DataScience community posts a dataset online as part of &lt;a href=&#34;https://github.com/rfordatascience/tidytuesday&#34;&gt;#TidyTuesday&lt;/a&gt; as practice wrangling and modelling data. For the week of 5th May 2020, the dataset concerned the video game &lt;a href=&#34;https://en.wikipedia.org/wiki/Animal_Crossing&#34;&gt;Animal Crossing&lt;/a&gt;.&lt;/p&gt;
&lt;div id=&#34;intro&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=n10JC0BOWF8&#34;&gt;Radiohead - How I Made My Millions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I don’t play Animal Crossing (unfortunately Nintendo Switches sold out as the UK went into lockdown), but it seems that everyone around me does so I’ve become fascinated by how it has created almost a surrogate life for people, performing manual tasks to pay off loans to Tom Nook, the nefarious bankster of the player’s island.&lt;/p&gt;
&lt;p&gt;One aspect in particular that captured my attention was the weekly market for turnips on each player’s island. Every Sunday, the player has the opportunity to buy turnips from a salesperson, which they then have a week to sell (before the turnips rot). The prices of turnips fluctuate over the week and (as far as I know) the vegetables have little function outside of buying/selling, so in essence they work as stocks which can be bought once per week, and the player must clear before the next offering.&lt;/p&gt;
&lt;p&gt;To formalise this (taken from &lt;a href=&#34;https://animalcrossing.fandom.com/wiki/White_turnip&#34;&gt;here&lt;/a&gt;):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;players can buy as many turnips as they want from character a for price x per turnip* on Sunday morning&lt;/li&gt;
&lt;li&gt;players can then sell as many or as few turnips as they want to character b for price y(t) from the morning until 10pm&lt;/li&gt;
&lt;li&gt;prices vary depending on price y(t-1) and a given pattern, changing at the start of each day and then at midday each day (so there are 12 independent selling prices y through a week)&lt;/li&gt;
&lt;li&gt;on the next Sunday everything resets&lt;/li&gt;
&lt;li&gt;for the next week the pattern the prices follow may or may not be different&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;*technically players buy turnips in bundles of 10, but it’s easier just to refer to the turnips rather than bundles&lt;/p&gt;
&lt;p&gt;Modelling the movement of the turnip price leads to some interesting analysis using models from financial data science, and while this data wasn’t a part of #TidyTuesday, I think it’s related enough to potentially be of interest to people.&lt;/p&gt;
&lt;p&gt;First, as always, let’s load the libraries we’ll need:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#load libraries
library(tidyverse)
library(MASS)
library(conflicted)
#prefer tidyverse functions
preferred &amp;lt;- map(c(&amp;quot;filter&amp;quot;, &amp;quot;select&amp;quot;, &amp;quot;lag&amp;quot;), conflict_prefer, &amp;quot;dplyr&amp;quot;)


#source the functions governing turnips price dynamics
source(&amp;quot;../../static/files/turnips/turnip_funs.R&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;price-patterns&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Price Patterns&lt;/h2&gt;
&lt;p&gt;Looking into the code governing the price of turnips, it appears that on each Sunday, turnips are sold randomly for between 90 and 110 ‘bells’ (equivalent to and henceforth referred to as $), and then there are 4 independent ‘patterns’ of price evolution which last the whole week. After purchasing turnips the prices can either:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fluctuate (go up and down around mean $100 purchase price)&lt;/li&gt;
&lt;li&gt;‘spike’ upwards around midweek (where prices will decrease before shooting up past the ~$100 purchase price around Wednesday). This is actually two separate but similar patterns, where ‘large spike’ leads to greater selling prices than ‘small spike’&lt;/li&gt;
&lt;li&gt;decreasing in which the player has no hope of making a profit that week as prices will decrease every day before resetting on the Sunday&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;for a few more details see &lt;a href=&#34;https://animalcrossing.fandom.com/wiki/White_turnip&#34;&gt;the game’s wiki&lt;/a&gt; or the &lt;a href=&#34;https://gist.github.com/Treeki/85be14d297c80c8b3c0a76375743325b&#34;&gt;C++ code I ripped my functions from&lt;/a&gt;. The R translations I use here can be found on the Github repo for my site &lt;a href=&#34;https://github.com/RobWHickman/netlify_blog/blob/master/static/files/turnips/turnip_funs.R&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The patterns are not completely memory-less, and progress as a Markov Chain, where the probability of prices following a pattern next week are dependent on the current price pattern. Let’s say however that we are only playing video games to relax and not paying too much attention to virtual stock markets, the chance of seeing a pattern can be estimated as the stationary probabilities of each node of the chain.&lt;/p&gt;
&lt;p&gt;There are two ways to solve this, first (and easiest) we have full knowledge of the transitions from week to week, so can solve analytically. The chance of seeing a pattern next week (column names) is related to the observed pattern this week (rownames) in the following matrix:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#the four patterns
states &amp;lt;- c(&amp;quot;fluctuating&amp;quot;, &amp;quot;large_spike&amp;quot;, &amp;quot;decreasing&amp;quot;, &amp;quot;small_spike&amp;quot;)

#build the transition matrix between the states
transition_matrix &amp;lt;- matrix(
  c(
    0.2, 0.3, 0.15, 0.35,
    0.5, 0.05, 0.2, 0.25,
    0.25, 0.45, 0.05, 0.25,
    0.45, 0.25, 0.15, 0.15
  ),
  nrow = 4, byrow = TRUE)
#name the current (rows) and next (cols) states
rownames(transition_matrix) &amp;lt;- states
colnames(transition_matrix) &amp;lt;- states

transition_matrix&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##             fluctuating large_spike decreasing small_spike
## fluctuating        0.20        0.30       0.15        0.35
## large_spike        0.50        0.05       0.20        0.25
## decreasing         0.25        0.45       0.05        0.25
## small_spike        0.45        0.25       0.15        0.15&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we are a naive observer, the chance of observing any pattern is therefore solved by taking the left eigenvectors of this matrix:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#take the elft eignevector
#ginv from the MASS package
left_eigen &amp;lt;- ginv(eigen(transition_matrix)$vectors)[1,]
pattern_likelihood_analytic &amp;lt;- left_eigen / sum(left_eigen)
#name the probabilities
names(pattern_likelihood_analytic) &amp;lt;- states

pattern_likelihood_analytic&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## fluctuating large_spike  decreasing small_spike 
##   0.3462773   0.2473628   0.1476074   0.2587525&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where we see that around half the time we have a chance of either a large or a small spike in prices around midweek (24.7% + 25.9%), with the majority of the remaining weeks showing a fluctuating pattern (where the player can still make a small profit). The worst case scenario of continually decreasing prices happens only 14.7% of the time, so overall, the stalk market looks like a pretty good bet for investors.&lt;/p&gt;
&lt;p&gt;Of course, we can also do this using Hamiltonian Monte Carlo methods by simulating a few sets of independent weeks&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#transition probabilities
transition_df &amp;lt;- as.data.frame(transition_matrix) %&amp;gt;%
  rownames_to_column(var = &amp;quot;current_state&amp;quot;) %&amp;gt;%
  pivot_longer(cols = states, names_to = &amp;quot;next_state&amp;quot;, values_to = &amp;quot;prob&amp;quot;) %&amp;gt;%
  group_by(current_state) %&amp;gt;%
  mutate(cum_prob = cumsum(prob)) %&amp;gt;%
  ungroup()

#get the next pattern from the current pattern
find_next_pattern &amp;lt;- function(pattern, rng, transitions = transition_df) {
  next_transition &amp;lt;- transitions %&amp;gt;%
    #find possible patterns
    filter(current_state == pattern &amp;amp; cum_prob &amp;gt; rng) %&amp;gt;%
    #take top row
    .[1,]
  #next state is that pattern
  next_state &amp;lt;- next_transition$next_state
}

#run forward for prop_forward weeks for each run to check convergence
transition_patterns &amp;lt;- function(initial_pattern, prop_forward) {
  patterns &amp;lt;- c()
  pattern &amp;lt;- initial_pattern
  #run n times
  for(runs in seq(prop_forward)) {
    pattern &amp;lt;- find_next_pattern(pattern, runif(1))
    patterns &amp;lt;- append(patterns, pattern)
  }
  #return as df
  df &amp;lt;- data.frame(
    initial_pattern,
    pattern = as.character(patterns),
    t = 1:prop_forward
  )
  return(df)
}

#repeat sims n times
simulation_reps &amp;lt;- 100
#how many weeks to run each sim for
prop_forward = 10
#run the sims
pattern_likelihood &amp;lt;- states %&amp;gt;%
  rep(simulation_reps) %&amp;gt;%
  map_df(., transition_patterns, prop_forward) %&amp;gt;%
  group_by(pattern) %&amp;gt;%
  summarise(prob = n() / (simulation_reps *  prop_forward * length(states)))

pattern_likelihood&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 4 x 2
##   pattern      prob
##   &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 decreasing  0.147
## 2 fluctuating 0.352
## 3 large_spike 0.244
## 4 small_spike 0.256&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we get pretty much the same numbers (as we would expect). To show the relative frequencies and how well our two methods of finding the stationary probabilities work, we can easily graph this using ggplot:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- pattern_likelihood_analytic %&amp;gt;%
  as.data.frame() %&amp;gt;%
  rownames_to_column(&amp;quot;pattern&amp;quot;) %&amp;gt;%
  left_join(pattern_likelihood, by = &amp;quot;pattern&amp;quot;) %&amp;gt;%
  rename(hmc = &amp;quot;prob&amp;quot;, analytic = &amp;quot;.&amp;quot;) %&amp;gt;%
  pivot_longer(c(&amp;quot;hmc&amp;quot;, &amp;quot;analytic&amp;quot;), names_to = &amp;quot;calc&amp;quot;, values_to = &amp;quot;prob&amp;quot;) %&amp;gt;%
  ggplot(aes(x = pattern, y = prob, group = calc)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, position = &amp;quot;dodge&amp;quot;, aes(fill = calc), colour = &amp;quot;black&amp;quot;) +
  scale_fill_manual(values = c(&amp;quot;dodgerblue&amp;quot;, &amp;quot;orange&amp;quot;)) +
  labs(
    title = &amp;quot;probability of observing any one price pattern when randomly sampling&amp;quot;,
    subtitle = &amp;quot;showing difference estimate from analytic and Monte Carlo methods&amp;quot;,
    x = &amp;quot;week&amp;#39;s prices pattern&amp;quot;,
    y = &amp;quot;probability&amp;quot;
  ) +
  theme_minimal()

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/plot_pattern_likelihood-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So, given the likelihood of spikes in prices, we know we’ve got a good chance of making some money by buying and selling turnips.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;modelling-turnips-prices&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Modelling Turnips Prices&lt;/h2&gt;
&lt;p&gt;To calculate exactly how much we might expect, it’s easiest, just to simulate the prices a load of times. We can do this by using a simple function that samples from &lt;a href=&#34;https://gist.github.com/Treeki/85be14d297c80c8b3c0a76375743325b&#34;&gt;the C++ code provided by Treeki&lt;/a&gt; (for a translation into R which I’m using here see my Github &lt;a href=&#34;https://github.com/RobWHickman/netlify_blog/blob/master/static/files/turnips/turnip_funs.R&#34;&gt;here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The function randomly selects an initial (Sunday) price for turnips to be bought at, and then, runs the simulation code for a given pattern of prices. The second argument simply gives a list of names for the epochs (each day for both AM or PM, which will have different selling prices). I wrap the simulation up into a df because I find it easier to work with though the real meat of the simulation is a vector of length 14 which contains the ‘two’ Sunday buying prices (which will be identical- it’s just to make it easier for me to count), and the 12 selling prices from Monday AM - Saturday PM.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#the epochs for buying and selling turnips
#14 epochs, 2 identical buying epochs, and 12 unique selling epochs
week &amp;lt;- c(&amp;quot;sun&amp;quot;, &amp;quot;mon&amp;quot;, &amp;quot;tues&amp;quot;, &amp;quot;wed&amp;quot;, &amp;quot;thurs&amp;quot;, &amp;quot;fri&amp;quot;, &amp;quot;sat&amp;quot;)
epochs &amp;lt;- paste(rep(week, each = 2), rep(c(&amp;quot;AM&amp;quot;, &amp;quot;PM&amp;quot;), 7))

#simulate a week of prices given a pattern
simulate_week &amp;lt;- function(pattern, epochs) {
  #set up prices vector
  sunday_price &amp;lt;- sample(90:110, 1)
  initial_prices &amp;lt;- c(rep(sunday_price, 2), rep(0, 12))
  
  #simulate pattern
  if(pattern == &amp;quot;decreasing&amp;quot;) {
    week_prices &amp;lt;- sim_decreasing(
      prices = initial_prices
    )
  } else if(pattern == &amp;quot;fluctuating&amp;quot;) {
    week_prices &amp;lt;- sim_fluctuating(
      prices = initial_prices, 
      first_epochs = c(sample(0:6, 1), sample(2:3, 1))
    )
  } else if(pattern == &amp;quot;large_spike&amp;quot;) {
    week_prices &amp;lt;- sim_largespike(
      prices = initial_prices, 
      rate = runif(1, 0.85, 0.95), 
      first_peak = sample(2:8, 1)
    )
  } else if(pattern == &amp;quot;small_spike&amp;quot;) {
    week_prices &amp;lt;- sim_smallspike(
      prices = initial_prices, 
      first_peak = sample(1:8, 1)
    )
  }
  
  #arrange df
  weekly_prices &amp;lt;- data.frame(
    day = epochs,
    buy_price = sunday_price,
    price = week_prices
  )
  
  return(weekly_prices)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can calculate how many times each pattern should be run by defining the number of simulations we want to run, and sampling price patterns, weighted by likelihood, from the df we calculated above.&lt;/p&gt;
&lt;p&gt;Then we just have to sample the vector of 1000 choices of the 4 patterns to the function and do a little munging at the end. After we can get a sense of which days are most profitable for selling turnips by plotting the histogram of the return (by how many times we have multiplied our original stock of $) on turnip investment.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#how many simulations of weeks to run
simulation_reps &amp;lt;- 1000
prices &amp;lt;- pattern_likelihood %&amp;gt;%
  #sample patterns by likelihood
  sample_n(simulation_reps, weight = prob, replace = TRUE) %&amp;gt;%
  .$pattern %&amp;gt;%
  map_df(., simulate_week, epochs) %&amp;gt;%
  mutate(return = price / buy_price,
         day = factor(day, levels = epochs)) %&amp;gt;%
  filter(!grepl(&amp;quot;sun [A-Z]{2}&amp;quot;, day)) %&amp;gt;%
  group_by(day) %&amp;gt;%
  mutate(mean_return = mean(return)) %&amp;gt;%
  ungroup()

p2 &amp;lt;- ggplot(prices, aes(x = return, fill = mean_return)) +
  geom_histogram(alpha = 0.8, colour = &amp;quot;black&amp;quot;) +
  geom_vline(xintercept = 1, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;dodgerblue&amp;quot;, size = 1) +
  scale_fill_gradient2(low = &amp;quot;red&amp;quot;, high = &amp;quot;green&amp;quot;, mid = &amp;quot;black&amp;quot;, midpoint = 1) +
  scale_x_continuous(limits = c(0, 2)) +
  theme_minimal() +
  labs(
    title = &amp;quot;which days yield greatest profits in the stalk market?&amp;quot;,
    subtitle = paste(&amp;quot;based on&amp;quot;, simulation_reps, &amp;quot;simulations&amp;quot;),
    x = &amp;quot;return on turnip investment&amp;quot;,
    y = &amp;quot;observed count&amp;quot;
  ) +
  facet_wrap(~day)

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/run_simulations-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So the period of Wednesday-Thursday seems to have the greatest mean profit, which we could have predicted, given that that the two known profitable patterns both have their ‘spike’ around this time. For all days though, we can see a large hump under the break even point (a return of 1) which is due to the fact that &lt;em&gt;all&lt;/em&gt; patterns (even the profitable spike ones) have a random amount of decrease in prices over the week.&lt;/p&gt;
&lt;p&gt;What might be most concerning to a turnip investor is that the mean return the next weekend (which might be the next time they get to play the game) is fairly lower (~0.8) than break even, so they are going to have to pay attention to the movement of prices during the week.&lt;/p&gt;
&lt;p&gt;The histograms struggle to portray the movement of time across epochs, so I also wanted to plot the prices using the &lt;a href=&#34;https://cran.r-project.org/web/packages/ggridges/vignettes/introduction.html&#34;&gt;ggridges&lt;/a&gt; package to produce density &lt;a href=&#34;https://upload.wikimedia.org/wikipedia/en/7/70/Unknown_Pleasures_Joy_Division_LP_sleeve.jpg&#34;&gt;joy plots&lt;/a&gt; over time. Here we can see a bit clearer that it’s only the long positive tails on the distributions which give us an expected return slightly above break even from Wednesday AM- Thursday PM:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(ggridges)

p3 &amp;lt;- ggplot(prices, aes(x = return, y = day, fill = mean_return)) +
  geom_density_ridges2() +
  geom_vline(xintercept = 1, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;dodgerblue&amp;quot;, size = 1) +
  scale_fill_gradient2(low = &amp;quot;red&amp;quot;, high = &amp;quot;green&amp;quot;, mid = &amp;quot;black&amp;quot;, midpoint = 1) +
  scale_x_continuous(limits = c(0, 2.5)) +
  labs(
    title = &amp;quot;which days yield greatest profits in the stalk market?&amp;quot;,
    subtitle = paste(&amp;quot;based on&amp;quot;, simulation_reps, &amp;quot;simulations&amp;quot;),
    x = &amp;quot;return on turnip investment&amp;quot;,
    y = &amp;quot;observed density by day&amp;quot;
  ) +
  theme_minimal()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/plot_ridgeline-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;astute-turnip-investment&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Astute Turnip Investment&lt;/h2&gt;
&lt;p&gt;Given the potential constraints of any person’s (even one quarantined at home’s) time, an astute investor of turnips may want to calculate which days they should check prices to ensure the greatest return on investment. This is simply done, but first we must introduce one last factor in the stalk market- the risk free interest banked money accrues.&lt;/p&gt;
&lt;p&gt;In addition to performing manual tasks or investing in turnip stocks, the player can also bank their hard-earned money and collect the interest. As far as I can tell banked money earns interest at a rate of 0.05%* which is payed out monthly. To work with this a bit easier, I’m going to make a slight tweak and calculate as if the interested was earned daily. Therefore, if we take time 0 to be a Sunday morning at the beginning of the month, by the following Saturday, the player who put $100 dollars in the bank will know have (1 + (0.05/ 100)) ^ (6/30) * 100 in their bank account (or an extra 1cent if you calculate).&lt;/p&gt;
&lt;p&gt;The risk-free return over that one week will therefore have been 1cent- it is the return the player receives without having to risk their money buying/selling turnips. For each day over the week, this risk-free return is easy to calculate. Because we are only interested in this compared to the returns on investing savings in turnips, the amount in the bank doesn’t actually matter- we only care on the interest gained as a proportion of savings.&lt;/p&gt;
&lt;p&gt;*the FT has an &lt;a href=&#34;https://www.ft.com/content/68f96d24-02f0-42fd-b132-aba0acba777f&#34;&gt;article on&lt;/a&gt; the recent Animal Crossing interest rate cut and why it forces players into riskier assets like turnips&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;monthly_interest &amp;lt;- 1.005

interest_df &amp;lt;- data.frame(day = factor(epochs, levels = epochs)) %&amp;gt;%
  mutate(interest_days = rep(0:6, each = 2)) %&amp;gt;%
  mutate(interest_gained = (1 * (monthly_interest ^ (1/30)) ^ interest_days) -1)

interest_df&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         day interest_days interest_gained
## 1    sun AM             0    0.0000000000
## 2    sun PM             0    0.0000000000
## 3    mon AM             1    0.0001662652
## 4    mon PM             1    0.0001662652
## 5   tues AM             2    0.0003325581
## 6   tues PM             2    0.0003325581
## 7    wed AM             3    0.0004988785
## 8    wed PM             3    0.0004988785
## 9  thurs AM             4    0.0006652267
## 10 thurs PM             4    0.0006652267
## 11   fri AM             5    0.0008316025
## 12   fri PM             5    0.0008316025
## 13   sat AM             6    0.0009980060
## 14   sat PM             6    0.0009980060&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then work out the return on investment compared to risk. The simplest way to do this is to use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Sharpe_ratio&#34;&gt;Sharpe ratio&lt;/a&gt; which can be formalized as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[S_{a} = \frac{E[R_{a} - R_{b}]}{\sqrt{var[R_{a} - R_{b}]}} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Where we calculate the Sharpe ratio S of an asset a which is a function of the expected excess return (aka profit) R of that asset above the expected excess return of a ‘safe’ asset b (in this case the interest on money in the bank). This is then divided by the variance of the expected gain above the risk free asset. We call the difference in return of the risky and safe asset Ra - Rb the ‘excess return’.&lt;/p&gt;
&lt;p&gt;It should also be clear that we want a Sharpe ratio of &lt;em&gt;at least&lt;/em&gt; greater than 0 to make our investment worthwhile (as a risky asset is time discounted and the possibility of prospect-like losses); generally we want a Sharpe ratio of 1 to indicate a good investment.&lt;/p&gt;
&lt;p&gt;As we have the interest gained per day, we can calculate the excess return by joining our interest df and taking the return by day for each simulation as Ra, which we average to find the expected and variance.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#join in interest data
Sharpe_mean_returns &amp;lt;- prices %&amp;gt;%
  left_join(interest_df, by = &amp;quot;day&amp;quot;) %&amp;gt;%
  #calculate excess return over safe asset
  mutate(excess_return = (return - 1) - interest_gained) %&amp;gt;%
  group_by(day) %&amp;gt;%
  #calc nominator and denominator
  summarise(mean_excess = mean(excess_return),
            sd_excess = sd(excess_return)) %&amp;gt;%
  mutate(sharpe_ratio = mean_excess / sd_excess)

select(Sharpe_mean_returns, day, sharpe_ratio)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 12 x 2
##    day      sharpe_ratio
##    &amp;lt;fct&amp;gt;           &amp;lt;dbl&amp;gt;
##  1 mon AM        -0.274 
##  2 mon PM        -0.369 
##  3 tues AM       -0.158 
##  4 tues PM        0.0975
##  5 wed AM         0.157 
##  6 wed PM         0.135 
##  7 thurs AM       0.0574
##  8 thurs PM       0.0533
##  9 fri AM         0.0347
## 10 fri PM        -0.103 
## 11 sat AM        -0.595 
## 12 sat PM        -0.763&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So, as expected, the only epochs which show a positive Sharpe ratio are in the middle of the week, where prices spike. If we plot this we get a clearer indication of this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p4 &amp;lt;- ggplot(Sharpe_mean_returns, aes(x = day, y = sharpe_ratio, group = 1)) +
  geom_line(colour = &amp;quot;dodgerblue&amp;quot;) +
  geom_point(size = 2, colour = &amp;quot;dodgerblue&amp;quot;) +
  geom_hline(yintercept = 0, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;orange&amp;quot;) +
  labs(
    title = &amp;quot;Sharpe ratio for selling turnip investment on a given epoch&amp;quot;,
    subtitle = paste(&amp;quot;based on&amp;quot;, simulation_reps, &amp;quot;simulations&amp;quot;),
    x = &amp;quot;day&amp;quot;,
    y = &amp;quot;Sharpe ratio&amp;quot;
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/plot_sharpe_ratio-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Remember, we want a Sharpe ratio of around 1 to be confident our investment is a good idea, so for the casual investor, the stalk market doesn’t seem to give good value. If a player did want to dabble and could only dedicate so many hours per week to the game, the calculation suggests they should try to make time somewhere around Wednesday or Thursday to check in on the market to maximize their returns.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;globalizing-the-stalk-market&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Globalizing the Stalk Market&lt;/h2&gt;
&lt;p&gt;However, all is not lost for turnip investors! While each player lives and works on their &lt;em&gt;own&lt;/em&gt; island, they are able to visit the islands of their friends and can buy and sell Turnips there following the same rules. However, prices (both buying on Sunday and selling for the rest of the week) are independent between player’s islands, so a smart investor can sample many markets and sell in the one which offers the greatest price.&lt;/p&gt;
&lt;p&gt;To simulate these open markets, we image a player has n friends who will let them visit, and calculate the potential profit made by an optimal investor (buying on the cheapest island, and selling on the most profitable). We simulate each epoch on each island the same 1000 times and take the max potential returns per epoch.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#do the same for n islands
simulate_open_economies &amp;lt;- function(islands, pattern_likelihood, epochs) {
  patterns &amp;lt;- pattern_likelihood %&amp;gt;%
    sample_n(islands, weight = prob, replace = TRUE) %&amp;gt;%
    .$pattern
  
  #munge
  all_prices &amp;lt;- map_df(patterns, simulate_week, epochs) %&amp;gt;%
    #will always buy at lowest and sell at highest
    mutate(buy_price = min(buy_price)) %&amp;gt;%
    group_by(day) %&amp;gt;%
    mutate(sell_price = max(price)) %&amp;gt;%
    select(day, buy_price, sell_price) %&amp;gt;%
    unique() %&amp;gt;%
    mutate(islands)
}

#run on 1:n islands
n_islands &amp;lt;- 10
open_prices &amp;lt;- rep(1:n_islands, simulation_reps) %&amp;gt;%
  map_df(simulate_open_economies, pattern_likelihood, epochs) %&amp;gt;%
  group_by(islands) %&amp;gt;%
  mutate(return = sell_price / buy_price,
         day = factor(day, levels = epochs)) %&amp;gt;%
  filter(!grepl(&amp;quot;sun [A-Z]{2}&amp;quot;, day)) %&amp;gt;%
  group_by(islands, day) %&amp;gt;%
  mutate(mean_return = mean(return)) %&amp;gt;%
  ungroup()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we then paste the density of returns by simulation, colored by the number of islands, we can see a clear rightward shift towards greater returns when a player has more friends. To think about this simply, if we imagine a player has infinite friends, they will &lt;em&gt;always&lt;/em&gt; buy turnips for the minimum possible price ($90) and &lt;em&gt;always&lt;/em&gt; sell them for the maximum possible price on that day.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p5 &amp;lt;- ggplot(open_prices, aes(x = return, y = day, group = paste(day, islands),
                              fill = islands, colour = islands)) +
  geom_density_ridges2(alpha = 0.2) +
  geom_vline(xintercept = 1, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;dodgerblue&amp;quot;, size = 1) +
  scale_fill_gradient(low = &amp;quot;yellow&amp;quot;, high = &amp;quot;green&amp;quot;) +
  scale_colour_gradient(low = &amp;quot;yellow&amp;quot;, high = &amp;quot;green&amp;quot;) +
  scale_x_continuous(limits = c(0, 2.5)) +
  labs(
    title = &amp;quot;which days yield greatest profits in the stalk market?&amp;quot;,
    subtitle = &amp;quot;by day and number of islands sampled&amp;quot;,
    x = &amp;quot;return on investment&amp;quot;,
    y = &amp;quot;day&amp;quot;
  ) +
  theme_minimal()

p5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/plot_multiisland_prices-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;What’s striking is that even with just 10 friends, player can be pretty much guaranteed to always make profit no matter which day they collude to all check their islands prices- the mean return on investment is clearly above 1.0 even by the following Saturday. The best potential returns are clearly still to be had midweek however, where now a player can clearly expect a doubling of their investment:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;open_prices %&amp;gt;%
  group_by(islands, day) %&amp;gt;%
  summarise(mean_return = mean(return)) %&amp;gt;%
  arrange(-mean_return) %&amp;gt;%
  head(n = 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 3
## # Groups:   islands [2]
##    islands day      mean_return
##      &amp;lt;int&amp;gt; &amp;lt;fct&amp;gt;          &amp;lt;dbl&amp;gt;
##  1      10 thurs AM        2.65
##  2      10 fri AM          2.60
##  3      10 wed AM          2.59
##  4      10 wed PM          2.59
##  5      10 thurs PM        2.58
##  6       9 wed AM          2.58
##  7      10 tues PM         2.57
##  8      10 fri PM          2.56
##  9       9 wed PM          2.54
## 10       9 thurs AM        2.54&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we use our Sharpe ratio calculation to then calculate when a player should collude with friends to all check their local turnip prices* we might expect therefore that it will also suggest checking somewhere in this midweek spike. However, if we plot it, we find an unexpected result:&lt;/p&gt;
&lt;p&gt;*if we assume that quarantined players probably &lt;em&gt;can&lt;/em&gt; manage to check prices more than once/twice a week, managing to co-ordinate between multiple players is going to get very hard very quickly so this constraint really will become a factor&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate Sharpe ratio per island as before
Sharpe_mean_open_returns &amp;lt;- open_prices %&amp;gt;%
  left_join(interest_df, by = &amp;quot;day&amp;quot;) %&amp;gt;%
  mutate(excess_return = (return - 1) - interest_gained) %&amp;gt;%
  group_by(islands, day) %&amp;gt;%
  summarise(mean_excess = mean(excess_return),
            sd_excess = sd(excess_return)) %&amp;gt;%
  mutate(sharpe_ratio = mean_excess / sd_excess)

#plot the sharpe ratio coloured by islands
p6 &amp;lt;- ggplot(Sharpe_mean_open_returns, 
             aes(x = day, y = sharpe_ratio, group = islands, colour = islands)) +
  geom_line() +
  geom_point(size = 2) +
  geom_hline(yintercept = 0, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;orange&amp;quot;) +
  labs(
    title = &amp;quot;Sharpe ratio for selling turnip investment on a given epoch&amp;quot;,
    subtitle = &amp;quot;by day and number of islands sampled&amp;quot;,
    x = &amp;quot;day&amp;quot;,
    y = &amp;quot;Sharpe ratio&amp;quot;
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/sharpe_ratios-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;As we &lt;em&gt;increase&lt;/em&gt; the number of islands, the Sharpe ratio tilts towards selling &lt;em&gt;earlier&lt;/em&gt; (when the mean returns are lower). Why do we get this result? To investigate we need to look at some real stock charts, which we can easily do via the &lt;a href=&#34;https://cran.r-project.org/web/packages/tidyquant/index.html&#34;&gt;tidyquant&lt;/a&gt; package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyquant)

#get nintendo stock data
nintendo_symbol &amp;lt;- &amp;quot;7974.T&amp;quot;
nintendo &amp;lt;- getSymbols(nintendo_symbol,
                       from = &amp;#39;2019-06-01&amp;#39;,
                       to = &amp;quot;2020-03-15&amp;quot;,
                       auto.assign = FALSE) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  rename_all(~gsub(paste0(nintendo_symbol, &amp;quot;.&amp;quot;), &amp;quot;&amp;quot;, .)) %&amp;gt;%
  rownames_to_column(&amp;quot;date&amp;quot;) %&amp;gt;%
  mutate(date = as.Date(date)) %&amp;gt;%
  select(date, close = Close)

#plot the last 9 months of nintendo stock
p7 &amp;lt;- ggplot(nintendo, aes(x = date, y = close)) +
  geom_line(size = 2, colour = &amp;quot;orange&amp;quot;) +
  labs(
    title = &amp;quot;Nintendo stock prices&amp;quot;,
    subtitle = &amp;quot;data from June 2019-March 2020&amp;quot;,
    x = &amp;quot;date&amp;quot;,
    y = &amp;quot;closing stock price&amp;quot;
  ) +
  theme_minimal()

p7&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/get_stock_prices-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Even though the Nintendo stock price has been fairly volatile over the past 9 months, it’s held its value fairly steadily- it would be literally impossible for a trader to double their investment over this time (c.f. turnips in a week). We can drill down into the data by looking at the daily change in closing price (as a fraction of the price), using dplyr::lag()&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p8 &amp;lt;- nintendo %&amp;gt;%
  mutate(daily_change = (close - lag(close)) / lag(close)) %&amp;gt;%
  ggplot(aes(x = daily_change)) +
  geom_histogram(fill = &amp;quot;orange&amp;quot;, colour = &amp;quot;black&amp;quot;) +
  geom_vline(xintercept = 0, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;dodgerblue&amp;quot;) +
  labs(
    title = &amp;quot;daily changes in Nintendo stock prices&amp;quot;,
    subtitle = &amp;quot;data from June 2019-March 2020&amp;quot;,
    x = &amp;quot;fractional daily change in price&amp;quot;,
    y = &amp;quot;count&amp;quot;
  ) +
  theme_minimal()

p8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/show_stock_returns-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There’s three things to note here:
- the daily change in prices (roughly) follows a normal distribution* (with a mean slightly above 0 over a given time frame)
- the daily change in price is fairly small, i.e. the price is fairly stable
- there is a greater downside risk in large price moves- you’re more likely to see a big reduction in price than a big increase (see the recent downturn in Nintendo stock due to COVID-19 for example**)&lt;/p&gt;
&lt;p&gt;*stock returns don’t follow a normal distribution if you rigorously test it, but it’s close enough to be useful&lt;/p&gt;
&lt;p&gt;**yes, I know it has bounced back up, the data was selectively chosen to make a point&lt;/p&gt;
&lt;p&gt;These are important basic heuristics for portfolio building and we can see that our stalk market fails on all three. Luckily, the fact that our turnip returns are skewed (even if they are skewed upwards instead of downwards as in the real life data).&lt;/p&gt;
&lt;p&gt;Instead of using the Sharpe ratio, which considers the total standard deviation of the returns, we can use the &lt;a href=&#34;https://en.wikipedia.org/wiki/Sortino_ratio&#34;&gt;Sortino ratio&lt;/a&gt; which is a risk-adjusted version to control for the downside risk of investment (i.e. you’re more likely to make big losses than big gains). We know that with multiple friends, we can be pretty confident of making big returns,&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[S_{a} = \frac{E(R_{a} - MAR)}{\sqrt{\frac{1}{n}\cdot\int_{-\infty}^{MAR}{(MAR - R_{a})^2}}dR} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which ok, looks pretty rough, but is simple enough to calculate.&lt;/p&gt;
&lt;p&gt;The numerator is just the same as the Sharpe ratio numerator, except instead of the returns on asset a vs. a risk-free asset, we’re now calculating the returns vs. a Minimal Acceptable Return (MAR). Re-imagine our scenario where someone only has x hours spare to play Animal Crossing, they aren’t going to go through the stress and commitment to play the stalk market without making &lt;em&gt;at least&lt;/em&gt; MAR returns (where MAR is some number).&lt;/p&gt;
&lt;p&gt;The denominator also looks more complicated than the Sharpe ratio, but remember, for that we want to find&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[denom_{Sharpe} = \sqrt{var[R_{a} - R_{b}]} = sd[R_{a} - R_{b}]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which is what we’re calculating here, just we are limiting the standard deviation to the &lt;em&gt;downside risk&lt;/em&gt;, which means we only take the standard deviation of returns which fall beneath the MAR (hence the max argument in the integration).&lt;/p&gt;
&lt;p&gt;For instance, let’s say we want an excess return of 1, i.e. we want to judge the profitability of checking certain epochs to at least double our initial investment on turnips:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#want to double investment so MAR = 1
MAR &amp;lt;- 1

#calc Sortino ratio
Sortino_ratio &amp;lt;- open_prices %&amp;gt;%
  group_by(day, islands) %&amp;gt;%
  mutate(excess_return = return - 1) %&amp;gt;%
  summarise(
    #numerator
    mean_excess = mean(excess_return - MAR),
    #denominator squared for readability
    downside_sq = sum((MAR - excess_return[excess_return &amp;lt; MAR])^2/n())
  ) %&amp;gt;%
  #calc
  mutate(sortino_ratio = mean_excess / sqrt(downside_sq))

#plot the Sortino ratio by epoch
p9 &amp;lt;- ggplot(Sortino_ratio, aes(x = day, y = sortino_ratio, group = islands, colour = islands)) +
  geom_line() +
  geom_point(size = 2) +
  geom_hline(yintercept = 0, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;orange&amp;quot;) +
  labs(
    title = &amp;quot;Sortino ratio for selling turnip investment on a given epoch&amp;quot;,
    subtitle = &amp;quot;by day and number of islands sampled&amp;quot;,
    x = &amp;quot;day&amp;quot;,
    y = &amp;quot;Sortino ratio&amp;quot;
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p9&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/sortino_ratio-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And we can see that, compared to the Sharpe ratio, we are now being advised to preferentially check on prices mid-week. In addition, it gives us a nice idea of how many friends we need to round up to (in this example) double our investment. With 4/5 friends who co-ordinate with us, we have a reasonable chance (a Sortino ratio ~0) of doubling our money, but to be encouraged (generally a ratio of 1 is at least desired) we want 7 or so.&lt;/p&gt;
&lt;p&gt;Of course, the MAR is not an absolute, it depends on the how much risk a trader is willing to take, or in this case, how much motivation a video game player needs to try to play the stalk market. We can reproduce this plot easily for a range of MARs as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#range of MARs to test
MARs &amp;lt;- c(-0.5, 1, 2, 6)

#same as above
multiple_sortinos &amp;lt;- map_dfr(seq(length(MARs)), ~open_prices) %&amp;gt;%
  mutate(MAR = rep(MARs, each = nrow(open_prices))) %&amp;gt;%
  select(day, islands, return, MAR) %&amp;gt;%
  group_by(day, islands, MAR) %&amp;gt;%
  mutate(excess_return = return - 1) %&amp;gt;%
  summarise(
    mean_excess = mean(excess_return - MAR),
    downside_sq = sum((MAR - excess_return[excess_return &amp;lt; MAR])^2/n())
  ) %&amp;gt;%
  mutate(sortino_ratio = mean_excess / sqrt(downside_sq))

#plot faceted as above
p10 &amp;lt;- ggplot(multiple_sortinos, aes(x = day, y = sortino_ratio, group = islands, colour = islands)) +
  geom_line() +
  geom_point(size = 2) +
  geom_hline(yintercept = 0, linetype = &amp;quot;dashed&amp;quot;, colour = &amp;quot;orange&amp;quot;) +
  labs(
    title = &amp;quot;Sortino ratio for selling turnip investment on a given epoch&amp;quot;,
    subtitle = &amp;quot;by day and number of islands sampled&amp;quot;,
    x = &amp;quot;day&amp;quot;,
    y = &amp;quot;Sortino ratio&amp;quot;
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  facet_wrap(~MAR, scales = &amp;quot;free&amp;quot;)

#plot - note the free y scales
p10&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-05-17-playing_the_stalk_market_files/figure-html/calc_sortinos-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;There’s two things to really take away here- as we increase the MAR, the ratio decreases. This is because the df of returns stays constant, so as a player demands more and more return, the ratio is more and more pessimistic on their chances. Given that the maximum possible profit is roughly buying turnips for $90 and selling for $600 ($510 profit, an excess return of 5.6x our initial investment), demanding a MAR of 6 is literally impossible even with infinite friend’s islands, and for our relatively small number, the ratio approaches it’s limit at -1.&lt;/p&gt;
&lt;p&gt;Conversely, if a player only wanted to buy turnips for fun and didn’t mind losing 50% of their initial investment (a MAR of -0.5), they can be reasonably confident of being fine even just checking their own island inconsistently. By the time they have a few friends islands thrown in, they are guaranteed to make that much, and the ratio goes to infinity (there is no downside risk).&lt;/p&gt;
&lt;p&gt;That’s all for this post. As I’ve mentioned, thanks to &lt;a href=&#34;https://gist.github.com/Treeki/85be14d297c80c8b3c0a76375743325b&#34;&gt;Treeki&lt;/a&gt; for putting the turnip pricing mechanism code online, and if you want to play with it, my R translation is hosted on the &lt;a href=&#34;https://github.com/RobWHickman/netlify_blog/blob/master/static/files/turnips/turnip_funs.R&#34;&gt;Github repo&lt;/a&gt; for this site. Thanks for reading, and also to the organizers of #TidyTuesday for giving me the idea :)&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>An Introduction to Modelling Soccer Matches in R (part 2)</title>
      <link>/post/dixon_coles_2/</link>
      <pubDate>Sun, 26 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/dixon_coles_2/</guid>
      <description>


&lt;p&gt;&lt;em&gt;I wrote this one pretty quickly compared to part 1 (which goes much deeper into mathematical concepts), and only realized after how much of a similarity it has to many of &lt;a href=&#34;https://twitter.com/Torvaney?ref_src=twsrc%5Egoogle%7Ctwcamp%5Eserp%7Ctwgr%5Eauthor&#34;&gt;Ben Torvaney’s&lt;/a&gt; posts on the subject. This probably isn’t a coincidence given how much I’ve used his work previously in posts on this blog. Any imitation here is meant as flattery. The purpose of this post is really as a bridge between what I really want to write about- the maths behind the models in part 1, and extensions of these models into other distribution in parts 3-n so it might be a little derivative of stuff written elsewhere.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;On this blog I enjoy explaining various concepts from the more academic side of football analytics. One of my favourite results from this field are the papers in predicting future soccer matches based on limited information about past matches. Roughly 1 year ago I published &lt;a href=&#34;https://www.robert-hickman.eu/post/dixon_coles_1/&#34;&gt;part 1&lt;/a&gt; on a series of this and never got round to writing part 2 (of hopefully 2 or 3 more).&lt;/p&gt;
&lt;p&gt;In the first post, we saw how we can use the Poisson distribution to estimate the relative strengths of teams in a hypothetical summer league between Arsenal, Blackburn Rovers, Coventry City, Dover Athletic, Enfield Town, and Frimley Green. Now we want to move onto actually &lt;em&gt;using&lt;/em&gt; these estimates to predict matches, and eventually, whole leagues.&lt;/p&gt;
&lt;p&gt;A good way to sum up this post in one line is a quote (mis) attributed to Niels Bohr:&lt;/p&gt;
&lt;div id=&#34;its-difficult-to-make-predictions-especially-about-the-future&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&lt;em&gt;“It’s Difficult to Make Predictions, Especially About the Future”&lt;/em&gt;&lt;/h3&gt;
&lt;p&gt;We’ve made our predictions about the past (estimating the relative strengths of teams based on past results), now we need to predict the future. I think it also nicely captures that even our predictions about the past are noisy- we can not ever truly know the exact strengths of football teams; the job of analytics is to estimate these are accurately as possible. But any noise in those past predictions will be carried forward and amplified when predicting the future.&lt;/p&gt;
&lt;p&gt;Onward to the code, first as always, loading libraries and setting a seed for reproducibility:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)
library(ggrepel)

set.seed(3459)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re then going to load all the stuff we prepped and predicted in the last post. Remember the α parameter below refers to a teams attacking strength (the relative number of goals they are expected to score), and the β parameter refers to the attacking strength (the inverse of the relative number of goals they are expected to concede). Finally, γ refers to the extra advantage of playing at home.&lt;/p&gt;
&lt;p&gt;(all these files are on the github repo for this site)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixtures &amp;lt;- readRDS(&amp;quot;../../static/files/dc_2/dc_fixtures.rds&amp;quot;)
results &amp;lt;- readRDS(&amp;quot;../../static/files/dc_2/dc_results.rds&amp;quot;)

model &amp;lt;- readRDS(&amp;quot;../../static/files/dc_2/dc_model.rds&amp;quot;)

model&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $alpha
##          Arsenal Blackburn_Rovers    Coventry_City   Dover_Athletic 
##        1.1106558        0.6370160        0.3023048       -0.2875353 
##     Enfield_Town    Frimley_Green 
##       -0.3767038       -1.3857376 
## 
## $beta
##          Arsenal Blackburn_Rovers    Coventry_City   Dover_Athletic 
##        0.6457175        0.4289270        0.3647815       -0.1362931 
##     Enfield_Town    Frimley_Green 
##       -0.3852812       -0.9178517 
## 
## $gamma
##    gamma 
## 0.189462&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll define a quick function to do our prediction. For a quick explanation of exactly why it’s coded as presented, see &lt;a href=&#34;https://www.robert-hickman.eu/post/dixon_coles_1/#Tinkering&#34;&gt;the previous post&lt;/a&gt;, under the title ‘Tinkering’.&lt;/p&gt;
&lt;p&gt;For a given string of a home team and an away team, the function finds the relevant parameters from a third argument (param_list) and calculates the expected goal for each team.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;predict_results &amp;lt;- function(home, away, param_list) {
  e_goals_home &amp;lt;- exp(param_list$alpha[home] - param_list$beta[away] + param_list$gamma)
  e_goals_away &amp;lt;- exp(param_list$alpha[away] - param_list$beta[home])
  
  df &amp;lt;- data.frame(home = home, away = away,
                   e_hgoal = as.numeric(e_goals_home), 
                   e_agoal = as.numeric(e_goals_away))
  
  return(df)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we run this for two example teams for example:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#two example teams
home &amp;lt;- &amp;quot;Blackburn_Rovers&amp;quot;
away &amp;lt;- &amp;quot;Arsenal&amp;quot;

prediction &amp;lt;- predict_results(home, away, model) 
prediction&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               home    away  e_hgoal  e_agoal
## 1 Blackburn_Rovers Arsenal 1.198128 1.977293&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see that it gives Arsenal (the away team) a slightly more optimistic chance than Blackburn. The expected goals for each team of course can be rewritten as the mean, and in our Poisson model refers to λ (lambda)- the mean times an event (goal) happens per a time interval (match). We also set a maximum number of possible goals (7 in this case*) to bound the area under the distribution so we aren’t sampling forever.&lt;/p&gt;
&lt;p&gt;*sharp readers might notice that this is actually &lt;em&gt;lower&lt;/em&gt; than the lambda for our more extreme cases (e.g. Arsenal at home to Frimley Green), but for realistic matches (even between wildly different professional sides) this is a fair enough assumption.&lt;/p&gt;
&lt;p&gt;We then use dpois() to calculate the probability of this Poisson function returning a value (0:7 goals) given it’s lambda value. So if we run this over the prediction we made for Blackburn Rovers vs. Arsenal we get:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#set a limit of where we&amp;#39;ll calculate across
max_goals &amp;lt;- 7

#calculate the probability of scoring x goals for either team
blackburn_goal_probs &amp;lt;- lapply(0:max_goals, dpois, lambda = prediction$e_hgoal)
arsenal_goal_probs &amp;lt;- lapply(0:max_goals, dpois, lambda = prediction$e_agoal)

#bind together in a df
df &amp;lt;- data.frame(goals = rep(0:max_goals, 2),
                 team = rep(c(home, away), each = max_goals+1),
                 p = c(unlist(blackburn_goal_probs), unlist(arsenal_goal_probs)))

#plot the p of scoring x goals for either team
p1 &amp;lt;- ggplot(df, aes(x = goals, y = p, fill = team)) +
  geom_density(stat = &amp;quot;identity&amp;quot;, alpha = 0.5) +
  scale_fill_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;)) +
  labs(title = &amp;quot;Predicted goals for Blackburn Rovers and Arsenal&amp;quot;,
       y = &amp;quot;probability&amp;quot;) +
  theme_minimal()

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-2_files/figure-html/predict_mach_goals-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Because of how maths works, these curves are the same result we would get if we ran rpois() (sampling from the Poisson function) lots of times. We’ll do that quickly because it sets the stage nicely for what will come later.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#sample from the function lots of times for each team
n &amp;lt;- 100000
blackburn_goals_samples &amp;lt;- rpois(n, lambda = prediction$e_hgoal)
arsenal_goals_samples &amp;lt;- rpois(n, lambda = prediction$e_agoal)

df &amp;lt;- data.frame(team = rep(c(home, away), each = n),
                 sampled_goals = c(blackburn_goals_samples, arsenal_goals_samples))

#look its the same plot!
p2 &amp;lt;- ggplot(df, aes(x = sampled_goals, fill = team)) +
  geom_bar(stat = &amp;quot;count&amp;quot;, position = &amp;quot;dodge&amp;quot;, colour = &amp;quot;black&amp;quot;, alpha = 0.5) +
  geom_line(aes(colour = team), stat = &amp;quot;count&amp;quot;, size = 3) +
  scale_fill_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;), guide = FALSE) +
  scale_colour_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;), guide = FALSE) +
  labs(title = &amp;quot;Predicted goals for Blackburn Rovers and Arsenal&amp;quot;,
       y = &amp;quot;probability&amp;quot;,
       x = &amp;quot;sampled goals&amp;quot;) +
  theme_minimal() +
  theme(axis.text.y = element_blank())

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-2_files/figure-html/monte_carlo_poisson-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Ok great!, in terms of predicting the result, the rightwards shift of the red (Arsenal) curve here is the difference in the teams ability to generate a positive goal differential- it makes it more likely that if we sample event, Arsenal will have scored more goals than Blackburn Rovers at the end of the match. Of course, it’s also obvious that while Arsenal’s curve is right shifted, the bars for Arsenal scoring 0 goals and Blackburn scoring 6 are still sizable enough that it isn’t outside the realm of possibility.&lt;/p&gt;
&lt;p&gt;This is a nice way of presenting the chance of each team scoring n goals, but doesn’t really help us in predicting the result of a match given that this relies on the interaction of both these distributions (we need to know how many goals BOTH Arsenal AND Blackburn will score).&lt;/p&gt;
&lt;p&gt;To calculate this, we can do an outer product of the probabilities for both teams scoring n goals. We can then plot the probability of each &lt;em&gt;scoreline&lt;/em&gt; as a tile plot:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate matrix of possible results and probabilities of those
matrix &amp;lt;- outer(unlist(arsenal_goal_probs), unlist(blackburn_goal_probs)) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  gather() %&amp;gt;%
  #add in scorelines
  mutate(hgoals = rep(0:max_goals, max_goals+1),
         agoals = rep(0:max_goals, each = max_goals+1))

#make the tile plot
p3 &amp;lt;- ggplot(matrix, aes(x = hgoals, y = agoals, fill = value)) +
  geom_tile() +
  geom_text(aes(label = paste(hgoals, agoals, sep = &amp;quot;-&amp;quot;))) +
  scale_fill_gradient2(low = &amp;quot;white&amp;quot;, high = &amp;quot;red&amp;quot;, guide = FALSE) +
  theme_minimal()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-2_files/figure-html/example_tileplot-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Where we can see that the most common scorelines are low scoring (football is a low scoring game), and slightly biased towards away goals (i.e. Arsenal are more likely to win than lose). The darkest (most likely) tiles being 1-1 or a 2-1 Arsenal win seem very plausible given our calculated λs earlier.&lt;/p&gt;
&lt;p&gt;We can then do this for every fixture and build a large graph of the expected results for each using a simple map2_ apply. Because of the huge plot, I’ve restricted it here to a 3x3 matrix of the results for Arsenal, Coventry City, and Enfield Town, but if you click you should be linked to the full image.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#want to predict over the whole fixture space
all_fixtures &amp;lt;- bind_rows(fixtures, results) %&amp;gt;%
  filter(!duplicated(paste(home, away), fromLast = TRUE))

#get the lambda for each team per game
predictions &amp;lt;- map2_df(all_fixtures$home, all_fixtures$away, 
                       predict_results,
                       model)

#calc out probabilities and bind up
all_predictions &amp;lt;- map2_df(
  predictions$e_hgoal, predictions$e_agoal, 
  function(lambda_home, lambda_away, max_goals) {
    hgoal_prob &amp;lt;- dpois(0:max_goals, lambda_home) %&amp;gt;% `names&amp;lt;-`(0:max_goals)
    agoal_prob &amp;lt;- dpois(0:max_goals, lambda_away) %&amp;gt;% `names&amp;lt;-`(0:max_goals)
    outer(hgoal_prob, agoal_prob) %&amp;gt;%
      as.data.frame() %&amp;gt;% 
      gather() %&amp;gt;% 
      rownames_to_column(&amp;quot;row&amp;quot;) %&amp;gt;%
      mutate(hgoal = as.numeric(row) %% (max_goals+1)-1) %&amp;gt;% 
      mutate(hgoal = case_when(hgoal &amp;lt; 0 ~ max_goals, TRUE ~ hgoal),
             agoal = as.numeric(key)) %&amp;gt;%
      select(sample_hgoal = hgoal, sample_agoal = agoal, prob = value)
}, max_goals) %&amp;gt;%
  cbind(all_fixtures[rep(seq_len(nrow(all_fixtures)), each=(max_goals+1)^2),], .) %&amp;gt;%
  group_by(home, away) %&amp;gt;%
  mutate(prob = prob / sum(prob)) %&amp;gt;%
  ungroup()

#plot again
p3 &amp;lt;- all_predictions %&amp;gt;%
  #filter only a few out to scale plot 
  filter(home %in% c(&amp;quot;Arsenal&amp;quot;, &amp;quot;Coventry_City&amp;quot;, &amp;quot;Enfield_Town&amp;quot;),
         away %in% c(&amp;quot;Arsenal&amp;quot;, &amp;quot;Coventry_City&amp;quot;, &amp;quot;Enfield_Town&amp;quot;)) %&amp;gt;%
  ggplot(aes(x = sample_hgoal, y = sample_agoal, fill = prob)) +
  geom_tile() +
  geom_point(aes(x = hgoal, y = agoal), 
             colour = &amp;quot;blue&amp;quot;, size = 5, alpha = 0.5 / max_goals^2) +
  geom_text(aes(label = paste(sample_hgoal, sample_agoal, sep = &amp;quot;-&amp;quot;)), size = 2.3) +
  scale_fill_gradient2(low = &amp;quot;white&amp;quot;, high = &amp;quot;red&amp;quot;, guide = FALSE) +
  labs(
    title = &amp;quot;predictions for final score across all fixtures&amp;quot;,
    y = &amp;quot;away goals&amp;quot;,
    x = &amp;quot;home goals&amp;quot;) +
  theme_minimal() +
  facet_grid(away~home, scales = &amp;quot;free&amp;quot;)

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-2_files/figure-html/plot_all_matrix-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;For the whole matrix, click &lt;a href=&#34;https://www.robert-hickman.eu/img/results_matrix.png&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;so-what&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;So what?&lt;/h2&gt;
&lt;p&gt;These graphs are nice, but whats important is what they show: &lt;em&gt;we have a way to quantify how likely any result is in a match between two given teams&lt;/em&gt;. Why is this useful&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Firstly, we can use the output of this to build betting models. Given the odds on final scores for any match, we can hedge effectively by betting on (e.g.) the five overwhelmingly most likely results.&lt;/li&gt;
&lt;li&gt;Secondly, we can simulate leagues. This is &lt;a href=&#34;https://www.bloomberg.com/graphics/2020-coronavirus-european-football/&#34;&gt;perhaps especially of interest given the context of writing this post&lt;/a&gt;. I’m going to focus on this application because I don’t bet on football, and also because it’s hard to get a nice database of odds at the moment given the aforementioned situation.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=DYb8gS-wDrM&#34;&gt;The Verve - Monte Carlo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;We can do this using a technique called &lt;a href=&#34;https://en.wikipedia.org/wiki/Monte_Carlo_method&#34;&gt;Monte Carlo simulation&lt;/a&gt;. There are lots of good explanation of the technique on the internet, but it basically boils down to this:&lt;/p&gt;
&lt;div id=&#34;if-events-follow-a-known-distribution-you-can-sample-these-events-lots-of-times-to-get-stochastic-guesstimates-but-over-many-samples-you-will-reproduce-exactly-that-distribution&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;&#34;if events follow a known distribution*, you can sample these events lots of times to get stochastic guesstimates, but over many samples you will reproduce exactly that distribution&#34;&lt;/h3&gt;
&lt;p&gt;*a Poisson distribution for the expected number of goals scored in our case&lt;/p&gt;
&lt;p&gt;For football, this means that while on an individual match level results are noisy (sometimes better teams lose!), if we simulate matches lots and lots of times, eventually they should converge to the ‘truth’*&lt;/p&gt;
&lt;p&gt;*as defined by our Poisson distribution (which may or may not be a good/accurate ‘truth’ but go with it for now).&lt;/p&gt;
&lt;p&gt;To work with this highly repetitive data, first we want to ‘nest’ the probabilities for each match. This basically means storing a df of all the possible results and their probabilities as a column inside a larger df so we can move between the data in those two structures easier.&lt;/p&gt;
&lt;p&gt;For instance, the nest match results probability information for the next match to be played (Coventry City and home to Arsenal):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nested_probabilities &amp;lt;- all_predictions %&amp;gt;%
  filter(is.na(hgoal)) %&amp;gt;%
  select(-hgoal, -agoal) %&amp;gt;%
  nest(probabilities = c(sample_hgoal, sample_agoal, prob))

nested_probabilities$probabilities[[1]] %&amp;gt;%
  rename(&amp;quot;Coventry City&amp;quot; = sample_hgoal, &amp;quot;Arsenal&amp;quot; = sample_agoal) %&amp;gt;%
  arrange(-prob) %&amp;gt;%
  #show first 15 rows
  .[1:15,]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 15 x 3
##    `Coventry City` Arsenal   prob
##              &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1               0       2 0.115 
##  2               0       1 0.109 
##  3               1       2 0.0983
##  4               1       1 0.0933
##  5               0       3 0.0806
##  6               1       3 0.0691
##  7               0       0 0.0516
##  8               1       0 0.0442
##  9               0       4 0.0425
## 10               2       2 0.0422
## 11               2       1 0.0400
## 12               1       4 0.0364
## 13               2       3 0.0296
## 14               2       0 0.0190
## 15               0       5 0.0179&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The probability for any single result is small (otherwise match betting would be easy), but the probabilities for a 2-0 and 1-0 Arsenal wins are highest (as we found earlier). Indeed all of the most likely results are within a goal or two for either side of these.&lt;/p&gt;
&lt;p&gt;To make sure these probabilities makes sense, we can sum them and see that the results space of 0:max_goals for either side sums to 1&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(nested_probabilities$probabilities[[1]]$prob)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can easily use this data to simulate results. We sample a single row (a ‘result’ of the match) weighted by the probability of it occurring. For instance, when we sample from the Coventry City vs Arsenal match it picks a 3-1 Arsenal away win (not the likeliest result, but not the most unlikely either).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nested_probabilities$probabilities[[1]] %&amp;gt;%
  rename(&amp;quot;Coventry_City&amp;quot; = sample_hgoal, &amp;quot;Arsenal&amp;quot; = sample_agoal) %&amp;gt;%
  sample_n(1, weight = prob)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 3
##   Coventry_City Arsenal   prob
##           &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1             1       3 0.0691&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can of course repeat this across every match and see that the probabilities of the chosen results vary (because we’re randomly sampling we won’t always choose the most likely, or even a likely result), but all are within a reasonable range given the team playing:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;nested_probabilities %&amp;gt;%
    mutate(sampled_result = map(probabilities, sample_n, 1, weight = prob)) %&amp;gt;%
    select(-probabilities) %&amp;gt;%
    unnest(cols = c(sampled_result))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##   home             away             gameweek sample_hgoal sample_agoal   prob
##   &amp;lt;chr&amp;gt;            &amp;lt;chr&amp;gt;               &amp;lt;int&amp;gt;        &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
## 1 Coventry_City    Arsenal                 9            0            5 0.0179
## 2 Blackburn_Rovers Dover_Athletic          9            1            1 0.0575
## 3 Frimley_Green    Enfield_Town            9            0            4 0.0418
## 4 Arsenal          Blackburn_Rovers       10            2            1 0.0966
## 5 Coventry_City    Frimley_Green          10            3            0 0.170 
## 6 Dover_Athletic   Enfield_Town           10            2            1 0.0839&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But when we are predicting what will happen, we want to find the &lt;em&gt;most likely&lt;/em&gt; result. As mentioned earlier, if we sample enough, our average will converge towards this, so we can repeat this sampling technique n times (here I’ve done it 10 times), depending on how much time we want to wait for it to process.&lt;/p&gt;
&lt;p&gt;You can see that as we do this many times, the results with the highest probability turn up more than others- as we would expect if we were to (e.g.) actually play Blackburn Rovers vs Arsenal many times.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;rerun(10, nested_probabilities %&amp;gt;%
    filter(home == &amp;quot;Coventry_City&amp;quot; &amp;amp; away == &amp;quot;Arsenal&amp;quot;) %&amp;gt;%
    mutate(sampled_result = map(probabilities, sample_n, 1, weight = prob)) %&amp;gt;%
    select(-probabilities) %&amp;gt;%
    unnest(cols = c(sampled_result))
) %&amp;gt;%
  bind_rows() %&amp;gt;%
  arrange(-prob)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 6
##    home          away    gameweek sample_hgoal sample_agoal   prob
##    &amp;lt;chr&amp;gt;         &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;        &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;
##  1 Coventry_City Arsenal        9            0            2 0.115 
##  2 Coventry_City Arsenal        9            1            2 0.0983
##  3 Coventry_City Arsenal        9            1            1 0.0933
##  4 Coventry_City Arsenal        9            0            3 0.0806
##  5 Coventry_City Arsenal        9            1            3 0.0691
##  6 Coventry_City Arsenal        9            1            0 0.0442
##  7 Coventry_City Arsenal        9            0            4 0.0425
##  8 Coventry_City Arsenal        9            0            4 0.0425
##  9 Coventry_City Arsenal        9            0            4 0.0425
## 10 Coventry_City Arsenal        9            1            5 0.0154&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we do this a few more times per fixture (here 100, for a better estimate I’d advise at least 10000- it should only take a few minutes), we can then start assigning points and goal difference to each team based upon the result we’ve sampled. E.g. if one sample predicts Arsenal to beat Blackburn Rovers 4-0, we assign 3 points to Arsenal and 0 points to Blackburn Rovers for that simulation and +4 and -4 goal difference respectively.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;n &amp;lt;- 100
fixture_sims &amp;lt;- rerun(n, nested_probabilities %&amp;gt;%
    mutate(sampled_result = map(probabilities, sample_n, 1, weight = prob)) %&amp;gt;%
    select(-probabilities) %&amp;gt;%
    unnest(cols = c(sampled_result)) %&amp;gt;%
  select(-gameweek, -prob) %&amp;gt;%
  pivot_longer(c(home, away), names_to = &amp;quot;location&amp;quot;, values_to = &amp;quot;team&amp;quot;) %&amp;gt;%
  mutate(points = case_when(
    location == &amp;quot;home&amp;quot; &amp;amp; sample_hgoal &amp;gt; sample_agoal ~ 3,
    location == &amp;quot;away&amp;quot; &amp;amp; sample_agoal &amp;gt; sample_hgoal ~ 3,
    sample_hgoal == sample_agoal ~ 1,
    TRUE ~ 0
  )) %&amp;gt;%
  mutate(gd = case_when(
    location == &amp;quot;home&amp;quot; ~ sample_hgoal - sample_agoal,
    location == &amp;quot;away&amp;quot; ~ sample_agoal - sample_hgoal
  )))

fixture_sims[1]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## # A tibble: 12 x 6
##    sample_hgoal sample_agoal location team             points    gd
##           &amp;lt;dbl&amp;gt;        &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;             &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
##  1            0            0 home     Coventry_City         1     0
##  2            0            0 away     Arsenal               1     0
##  3            4            0 home     Blackburn_Rovers      3     4
##  4            4            0 away     Dover_Athletic        0    -4
##  5            0            0 home     Frimley_Green         1     0
##  6            0            0 away     Enfield_Town          1     0
##  7            3            0 home     Arsenal               3     3
##  8            3            0 away     Blackburn_Rovers      0    -3
##  9            6            1 home     Coventry_City         3     5
## 10            6            1 away     Frimley_Green         0    -5
## 11            1            1 home     Dover_Athletic        1     0
## 12            1            1 away     Enfield_Town          1     0&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then average the points and goal difference won in these sims across each team and see what teams are predicted to win across their fixtures.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;fixture_sims %&amp;gt;%
  bind_rows() %&amp;gt;%
  group_by(team) %&amp;gt;%
  summarise(av_points = sum(points)/n,
            av_gd = sum(gd) / n)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 3
##   team             av_points av_gd
##   &amp;lt;chr&amp;gt;                &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 Arsenal               4.19  2.44
## 2 Blackburn_Rovers      3.16  0.7 
## 3 Coventry_City         3.61  2.42
## 4 Dover_Athletic        2.26 -1.26
## 5 Enfield_Town          2.95  0.23
## 6 Frimley_Green         0.6  -4.53&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where we can see that we expect Arsenal to win 4.19 out of a possible 6 points (with games remaining against Coventry and Blackburn Rovers they are expected to drop points but win at least one and probably draw the other). Coventry City are expected to also do well- probably because their final game is at home to Frimley Green, whereas Blackburn have tougher fixtures away at Arsenal and home to Dover Athletic.&lt;/p&gt;
&lt;p&gt;We can then add this to the calculated points teams have &lt;em&gt;already&lt;/em&gt; accrued to get a prediction of where teams will end the season position wise:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;table &amp;lt;- results %&amp;gt;%
  pivot_longer(c(home, away), names_to = &amp;quot;location&amp;quot;, values_to = &amp;quot;team&amp;quot;) %&amp;gt;%
  mutate(points = case_when(
    location == &amp;quot;home&amp;quot; &amp;amp; hgoal &amp;gt; agoal ~ 3,
    location == &amp;quot;away&amp;quot; &amp;amp; agoal &amp;gt; hgoal ~ 3,
    hgoal == agoal ~ 1,
    TRUE ~ 0
  )) %&amp;gt;%
  mutate(gd = case_when(
    location == &amp;quot;home&amp;quot; ~ hgoal - agoal,
    location == &amp;quot;away&amp;quot; ~ agoal - hgoal
  )) %&amp;gt;%
  group_by(team) %&amp;gt;%
  summarise(points = sum(points),
            gd = sum(gd))

predicted_finishes &amp;lt;- map_df(fixture_sims, function(simulated_fixtures, table) {
  simulated_fixtures %&amp;gt;%
    select(team, points, gd) %&amp;gt;%
    bind_rows(., table) %&amp;gt;%
    group_by(team) %&amp;gt;%
    summarise(points = sum(points),
              gd = sum(gd)) %&amp;gt;%
    arrange(-points, -gd) %&amp;gt;%
    mutate(predicted_finish = 1:n())
}, table) %&amp;gt;%
  group_by(team, predicted_finish) %&amp;gt;%
  summarise(perc = n() / n)

predicted_finishes&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 3
## # Groups:   team [6]
##    team             predicted_finish  perc
##    &amp;lt;chr&amp;gt;                       &amp;lt;int&amp;gt; &amp;lt;dbl&amp;gt;
##  1 Arsenal                         1  0.82
##  2 Arsenal                         2  0.18
##  3 Blackburn_Rovers                1  0.18
##  4 Blackburn_Rovers                2  0.82
##  5 Coventry_City                   3  0.97
##  6 Coventry_City                   4  0.03
##  7 Dover_Athletic                  3  0.03
##  8 Dover_Athletic                  4  0.97
##  9 Enfield_Town                    5  1   
## 10 Frimley_Green                   6  1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which gives Arsenal an 82% chance of finishing champions, with only a 18% chance Blackburn manage to leapfrog them into 1st place. Given there are only 2 matches left with teams designed to have fairly large gulfs in ability, it’s not surprising most of the final positions are nailed on- e.g. Enfield Town finish 5th in every single simulation:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p4 &amp;lt;- ggplot(predicted_finishes, aes(x = predicted_finish, y = perc, fill = team)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, colour = &amp;quot;black&amp;quot;) +
  scale_fill_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;skyblue&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;dodgerblue4&amp;quot;, &amp;quot;blue&amp;quot;)) +
  labs(
    title = &amp;quot;Predicted finish position of teams&amp;quot;,
    subtitle = &amp;quot;with two gameweeks left to play&amp;quot;,
    y = &amp;quot;fraction of finishes&amp;quot;,
    x = &amp;quot;final position&amp;quot;
  ) +
  theme_minimal() +
  facet_wrap(~team)

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-2_files/figure-html/plot_predicted_finishes-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;the-real-thing&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Real Thing&lt;/h2&gt;
&lt;p&gt;We’re now at the stage where we can start to look at real data. One of the motivating forces which drew me back to this putative blog series was the &lt;a href=&#34;https://www.theguardian.com/football/blog/2020/apr/25/finishing-premier-league-season-pointless-football&#34;&gt;current football situation&lt;/a&gt;- with season ending with games left to play.&lt;/p&gt;
&lt;p&gt;We can use the knowledge we’ve built up over these last posts to see what we expect to happen in these unplayed games, if they cannot be completed.&lt;/p&gt;
&lt;p&gt;To make code more concise, I’ve used Ben Torvaney’s code in his &lt;a href=&#34;https://github.com/Torvaney/regista&#34;&gt;regista&lt;/a&gt; package (he also has some nice usage blogs similar to this post at his &lt;a href=&#34;http://www.statsandsnakeoil.com/&#34;&gt;blog&lt;/a&gt;). The underlying maths is exactly the same as in my previous post though with a few different design choices. If we run the simulations using the code from the previous post we should get exactly the same answer.&lt;/p&gt;
&lt;p&gt;The code following is also extremely similar to the final chunks of one of my previous &lt;a href=&#34;https://www.robert-hickman.eu/post/five_min_trivia_invincibles/&#34;&gt;posts&lt;/a&gt; in analysing the current Liverpool team’s achievements.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rvest)
library(regista)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;First we need to download the data on the current English Premier League season. Once we have this we can split it into played matches (where we 100% know the result) and unplayed matches which we need to predict the result of. For the basis of the team strength estimates I’ve used the xg created and allowed per game, as I believe these give a better estimate of team strength (indeed Ben Torvaney has a &lt;a href=&#34;http://www.statsandsnakeoil.com/2019/01/06/predicting-the-premier-league-with-dixon-coles-and-xg/&#34;&gt;nice post on using even the shot-by-shot xg to produce Dixon-Coles models&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#download the match data from 2019/2020
fixtures_2020 &amp;lt;- &amp;quot;https://fbref.com/en/comps/9/schedule/Premier-League-Fixtures&amp;quot; %&amp;gt;%
  read_html() %&amp;gt;%
  html_nodes(&amp;quot;#sched_ks_3232_1&amp;quot;) %&amp;gt;%
  html_table() %&amp;gt;%
  as.data.frame() %&amp;gt;%
  separate(Score, into = c(&amp;quot;hgoal&amp;quot;, &amp;quot;agoal&amp;quot;), sep = &amp;quot;–&amp;quot;) %&amp;gt;%
  #only care about goals and expected goals
  select(home = Home, away = Away, home_xg = xG, away_xg = xG.1, hgoal, agoal) %&amp;gt;%
  filter(home != &amp;quot;&amp;quot;) %&amp;gt;%
  mutate(home = factor(home), away = factor(away)) %&amp;gt;%
  #round expected goals to nearest integer
  mutate_at(c(&amp;quot;home_xg&amp;quot;, &amp;quot;away_xg&amp;quot;, &amp;quot;hgoal&amp;quot;, &amp;quot;agoal&amp;quot;), .funs = funs(round(as.numeric(.))))

#matches with a known result
#used for modelling
played_matches &amp;lt;- fixtures_2020 %&amp;gt;%
  filter(!is.na(home_xg))

#matches with an unknown result
#used for simulation
unplayed_matches &amp;lt;- fixtures_2020 %&amp;gt;%
  filter(is.na(home_xg)) %&amp;gt;%
  select_if(negate(is.numeric))

#fit the dixon coles model
#use xg per game, not &amp;#39;actual&amp;#39; goals
fit_2020 &amp;lt;- dixoncoles(home_xg, away_xg, home, away, data = played_matches)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To get a look at what the team parameters in a real-life league look like we can extract them from the model and plot them:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#extract Dixon-Coles team strenth parameters
pars_2020 &amp;lt;- fit_2020$par %&amp;gt;%
  .[grepl(&amp;quot;def_|off_&amp;quot;, names(.))] %&amp;gt;%
  matrix(., ncol = 2) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  rename(attack = V1, defence = V2)
pars_2020$team &amp;lt;- unique(gsub(&amp;quot;def_*|off_*&amp;quot;, &amp;quot;&amp;quot;, names(fit_2020$par)))[1:20]

#plot as before
p5 &amp;lt;- pars_2020 %&amp;gt;%
  mutate(defence = 1 - defence) %&amp;gt;%
  ggplot(aes(x = attack, y = defence, colour = attack + defence, label = team)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_text_repel() +
  scale_colour_continuous(guide = FALSE) +
  labs(title = &amp;quot;Dixon-Coles parameters for the 2019/2020 EPL&amp;quot;,
       x = &amp;quot;attacking strength&amp;quot;,
       y = &amp;quot;defensive strength&amp;quot;) +
  theme_minimal()

p5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-2_files/figure-html/plot_real_params-1.png&#34; width=&#34;672&#34; /&gt;
It might surprise some that Manchester City are predicted to be better than Liverpool by this model, but it shouldn’t given the underlying numbers for both teams. Liverpool have run very hot and Manchester City have run very cold this season.&lt;/p&gt;
&lt;p&gt;Finally, we can then calculate the current Premier League table, and simulate remaining games to predict where teams will finish the season if the remainder of games were to be played. I’ve chosen 1000 sims just for sake of processing time, but you can scale up and down as desired.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate the current EPL table
current_epl_table &amp;lt;- played_matches %&amp;gt;%
  select(home, away, hgoal, agoal) %&amp;gt;%
  pivot_longer(c(home, away), names_to = &amp;quot;location&amp;quot;, values_to = &amp;quot;team&amp;quot;) %&amp;gt;%
  mutate(points = case_when(
    location == &amp;quot;home&amp;quot; &amp;amp; hgoal &amp;gt; agoal ~ 3,
    location == &amp;quot;away&amp;quot; &amp;amp; agoal &amp;gt; hgoal ~ 3,
    hgoal == agoal ~ 1,
    TRUE ~ 0
  )) %&amp;gt;%
  mutate(gd = case_when(
    location == &amp;quot;home&amp;quot; ~ hgoal - agoal,
    location == &amp;quot;away&amp;quot; ~ agoal - hgoal
  )) %&amp;gt;%
  group_by(team) %&amp;gt;%
  summarise(points = sum(points),
            gd = sum(gd))

#the number of sims to run
n &amp;lt;- 10000

#simulate remaining matches
fixture_sims_2020 &amp;lt;- rerun(
  n,
  augment.dixoncoles(fit_2020, unplayed_matches, type.predict = &amp;quot;scorelines&amp;quot;) %&amp;gt;%                     
    mutate(sampled_result = map(.scorelines, sample_n, 1, weight = prob)) %&amp;gt;%
    select(-.scorelines) %&amp;gt;%
    unnest(cols = c(sampled_result)) %&amp;gt;%
  pivot_longer(c(home, away), names_to = &amp;quot;location&amp;quot;, values_to = &amp;quot;team&amp;quot;) %&amp;gt;%
  mutate(points = case_when(
    location == &amp;quot;home&amp;quot; &amp;amp; hgoal &amp;gt; agoal ~ 3,
    location == &amp;quot;away&amp;quot; &amp;amp; agoal &amp;gt; hgoal ~ 3,
    hgoal == agoal ~ 1,
    TRUE ~ 0
  )) %&amp;gt;%
  mutate(gd = case_when(
    location == &amp;quot;home&amp;quot; ~ hgoal - agoal,
    location == &amp;quot;away&amp;quot; ~ agoal - hgoal
  )) %&amp;gt;%
    select(team, points, gd))

#calculate final EPL tables
predicted_finishes_2020 &amp;lt;- map_df(fixture_sims_2020, function(sim_fixtures, table) {
  sim_fixtures %&amp;gt;%
    select(team, points, gd) %&amp;gt;%
    bind_rows(., table) %&amp;gt;%
    group_by(team) %&amp;gt;%
    summarise(points = sum(points),
              gd = sum(gd)) %&amp;gt;%
    arrange(-points, -gd) %&amp;gt;%
    mutate(predicted_finish = 1:n())
}, current_epl_table) %&amp;gt;%
  group_by(team, predicted_finish) %&amp;gt;%
  summarise(perc = n() / n) %&amp;gt;%
  group_by(team) %&amp;gt;%
  mutate(mean_finish = mean(predicted_finish)) %&amp;gt;%
  arrange(mean_finish) %&amp;gt;%
  ungroup() %&amp;gt;%
  mutate(team = factor(team, levels = unique(team)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If we then plot these predicted finishes (ordered by the chance of their highest finish position), we can get an idea of where we expect teams to end the season:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#list of team colours
team_cols &amp;lt;- c(&amp;quot;red&amp;quot;, &amp;quot;skyblue&amp;quot;, &amp;quot;darkblue&amp;quot;, &amp;quot;darkblue&amp;quot;, &amp;quot;darkred&amp;quot;,
               &amp;quot;orange&amp;quot;, &amp;quot;red&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;maroon&amp;quot;, 
               &amp;quot;blue&amp;quot;, &amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;, &amp;quot;dodgerblue&amp;quot;, &amp;quot;yellow&amp;quot;, 
               &amp;quot;maroon&amp;quot;, &amp;quot;red&amp;quot;, &amp;quot;maroon&amp;quot;, &amp;quot;yellow&amp;quot;)

#plot the finishing position by chance based on these simualtions
p6 &amp;lt;- ggplot(predicted_finishes_2020, 
             aes(x = predicted_finish, y = perc, fill = team)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;, colour = &amp;quot;black&amp;quot;) +
  scale_fill_manual(values = team_cols, guide = FALSE) +
  labs(
    title = &amp;quot;Predicted finish position of teams&amp;quot;,
    subtitle = &amp;quot;for incomplete 2019/2020 EPL season&amp;quot;,
    y = &amp;quot;fraction of finishes&amp;quot;,
    x = &amp;quot;final position&amp;quot;
  ) +
  theme_minimal() +
  facet_wrap(~team)

p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-30-5-dixon-coles-2_files/figure-html/plot_2020_prediction-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So great news for Liverpool fans who the model believes have a 100% chance of finishing in first place. Leicester also might be happy with a nailed on 3rd place, with Chelsea or Manchester United probably rounding out the top four, and Wolves joining the loser of the two in the Europa League.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get the predictions for the 2019/2020 champion
winner &amp;lt;- predicted_finishes_2020 %&amp;gt;%
  filter(predicted_finish &amp;lt; 2)%&amp;gt;%
  mutate(prediction = &amp;quot;Champion chance&amp;quot;)

winner&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 2 x 5
##   team            predicted_finish   perc mean_finish prediction     
##   &amp;lt;fct&amp;gt;                      &amp;lt;int&amp;gt;  &amp;lt;dbl&amp;gt;       &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          
## 1 Liverpool                      1 1.00           1.5 Champion chance
## 2 Manchester City                1 0.0001         2.5 Champion chance&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get prediction for those who qualify for champions league
#and for europa league
champs_league &amp;lt;- predicted_finishes_2020 %&amp;gt;%
  filter(predicted_finish &amp;lt; 5) %&amp;gt;%
  group_by(team) %&amp;gt;%
  summarise(perc = sum(perc)) %&amp;gt;%
  arrange(-perc) %&amp;gt;%
  mutate(prediction = &amp;quot;Champions League chance&amp;quot;)

champs_league&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 3
##    team              perc prediction             
##    &amp;lt;fct&amp;gt;            &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                  
##  1 Liverpool       1      Champions League chance
##  2 Manchester City 1      Champions League chance
##  3 Leicester City  0.933  Champions League chance
##  4 Chelsea         0.479  Champions League chance
##  5 Manchester Utd  0.46   Champions League chance
##  6 Wolves          0.106  Champions League chance
##  7 Sheffield Utd   0.0155 Champions League chance
##  8 Tottenham       0.004  Champions League chance
##  9 Arsenal         0.0018 Champions League chance
## 10 Everton         0.0005 Champions League chance&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;europa_league  &amp;lt;- predicted_finishes_2020 %&amp;gt;%
  filter(predicted_finish &amp;lt; 7) %&amp;gt;%
  group_by(team) %&amp;gt;%
  summarise(perc = sum(perc)) %&amp;gt;%
  arrange(-perc) %&amp;gt;%
  mutate(prediction = &amp;quot;(at least) Europa League chance&amp;quot;)

europa_league&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 13 x 3
##    team              perc prediction                     
##    &amp;lt;fct&amp;gt;            &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                          
##  1 Liverpool       1      (at least) Europa League chance
##  2 Manchester City 1      (at least) Europa League chance
##  3 Leicester City  0.999  (at least) Europa League chance
##  4 Manchester Utd  0.954  (at least) Europa League chance
##  5 Chelsea         0.954  (at least) Europa League chance
##  6 Wolves          0.729  (at least) Europa League chance
##  7 Sheffield Utd   0.196  (at least) Europa League chance
##  8 Tottenham       0.096  (at least) Europa League chance
##  9 Arsenal         0.0479 (at least) Europa League chance
## 10 Everton         0.0139 (at least) Europa League chance
## 11 Burnley         0.0089 (at least) Europa League chance
## 12 Crystal Palace  0.0009 (at least) Europa League chance
## 13 Southampton     0.0008 (at least) Europa League chance&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(obviously this model does not account for any ramifications of &lt;a href=&#34;https://www.itv.com/news/2020-02-14/manchester-city-banned-from-champions-league-for-two-years-by-uefa/&#34;&gt;Manchester City’s European ban&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;At the foot of the table, the model is fairly bullish on Norwich being relegated, with Aston Villa probably joining them, and then probably West Ham rounding out the relegation spots.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get predictions for those who would be relegated
relegated  &amp;lt;- predicted_finishes_2020 %&amp;gt;%
  filter(predicted_finish &amp;gt; 17) %&amp;gt;%
  group_by(team) %&amp;gt;%
  summarise(perc = sum(perc)) %&amp;gt;%
  arrange(-perc) %&amp;gt;%
  mutate(prediction = &amp;quot;Relegation chance&amp;quot;)

relegated&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 8 x 3
##   team             perc prediction       
##   &amp;lt;fct&amp;gt;           &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;            
## 1 Norwich City  0.934   Relegation chance
## 2 Aston Villa   0.700   Relegation chance
## 3 Bournemouth   0.507   Relegation chance
## 4 West Ham      0.402   Relegation chance
## 5 Watford       0.270   Relegation chance
## 6 Brighton      0.171   Relegation chance
## 7 Newcastle Utd 0.0126  Relegation chance
## 8 Southampton   0.00270 Relegation chance&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;final-remarks&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Final Remarks&lt;/h2&gt;
&lt;p&gt;I want to make it clear at the end of this post that this probably isn’t the most sophisticated model for predicting football matches (more to come in a part 3, maybe this time within less than a year), but does a pretty good job!&lt;/p&gt;
&lt;p&gt;In any case though, I don’t think that running these sims is a good way to end the season- in truth, there’s probably no good way. This post is more about &lt;em&gt;how&lt;/em&gt; to use this technique than &lt;em&gt;whether&lt;/em&gt; to use it.&lt;/p&gt;
&lt;p&gt;Best, stay safe as always!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Papers Please! &#39;Wide Open Spaces A statistical technique for measuring space creation in professional soccer&#39; pt 1</title>
      <link>/post/fall_back_in_to_space/</link>
      <pubDate>Mon, 20 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/fall_back_in_to_space/</guid>
      <description>


&lt;p&gt;&lt;em&gt;written during lockdown so while I think it adds some value (and is useful to organise my thoughts on the paper for my own work on football) there are probably mistakes. E.g. the C++ code is still pretty inefficient and could well be improved and I’ve surely confused some maths concepts. To be honest, the post is just an excuse to practice writing LaTeX maths and some C++. Let me know my errors and I’ll correct&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=f9X1C7pTu-M&#34;&gt;Beach House - Space Song&lt;/a&gt;&lt;/p&gt;
&lt;div id=&#34;intropre-amble&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Intro/Pre-amble&lt;/h1&gt;
&lt;p&gt;When analysing football (whether as a scout watching games, or an analyst using data), we want the greatest sample size possible. During a single match a player might well make fewer than 100 ‘events’ (passes, tackles, interceptions, shots, …) and still play well enough that he might be a worthwhile purchase. As we increase the number of matches we watch that player play, a more accurate ‘smoothed’ representation of their game should emerge. However, time is very obviously a limited resource. If we assume a very hardworking scout can watch 6 football matches a day, it will probably take them a week to cover all of the games of one team in a season, and over 3 months to cover an entire season of a league.&lt;/p&gt;
&lt;p&gt;An obvious way to get around some of these limitations is augment scouting using data. If a player is obviously an &lt;a href=&#34;https://en.wikipedia.org/wiki/Filippo_Inzaghi&#34;&gt;Filipo Inzaghi&lt;/a&gt; style poacher, its feasible we might watch 5-6 games of his to get a feel of his ability, then check some basic stats such a shots, xG, … etc. per game over his last few seasons to see how representative our sample was and flesh out our scouting.&lt;/p&gt;
&lt;p&gt;When we build these models (even just counting shot numbers) we are in essence ‘teaching’ machines to do the scouting for us. We provide them with a model of how the game works and ask them to ‘watch’ a huge number of matches very quickly. The obvious pitfall of this is that ‘computers don’t play football’, and they don’t, so the output of our model is going to be proportional to the understanding of the game the computer has. For example, a computer who only counts shot numbers has a poorer understanding of football than a machine who weights these by xG per shot. Just as humans understand creating better shooting chances is important, the second computer has come to grasp that.&lt;/p&gt;
&lt;p&gt;Some of these computational models seem to work, even with simple inputs. The xG a striker produces per season does for instance align quite well with how good the human eye test thinks a striker is. However, many are &lt;em&gt;quite bad&lt;/em&gt;, especially as you move back through play away from shots on goal. To fix this, we need machines who understand the game better, and in the same ways humans do.&lt;/p&gt;
&lt;p&gt;This is really the idea behind a lot of modern football analytics research, but I think especially behind &lt;a href=&#34;http://www.sloansportsconference.com/wp-content/uploads/2018/03/1003.pdf&#34;&gt;Wide Open Spaces&lt;/a&gt;, a 2019 Sloan conference paper by Javier Fernandez and Luke Bornn. I’m not going to review the whole paper, but the key takeaway is that for every ‘event’ that a player takes, there are actually many more uncaptured events where players are continually creating and destroying space. Combining these gives us a better approximation of what the human brain does when evaluating players. If this seems confusing, a simpler way to think about this is consider &lt;a href=&#34;https://www.youtube.com/watch?v=sZsJo7ZKdjQ&#34;&gt;this Tifo football video on Thomas Mueller&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;It is probably more valuable to be able to create and exploit space, than it is to be able to technically execute a pass. The reverse is also clearly true for defenders; consider Maldini’s famous quote: “If I have to make a tackle then I have already made a mistake.”&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;The paper, while very clearly written, does not explain it’s maths as accessibly as I might like, so I thought a post going through exactly what the paper is doing might be of value. All the hard work for this post is reall done by &lt;a href=&#34;https://twitter.com/AnEnglishGoat&#34;&gt;Will Thomson’s&lt;/a&gt; whose implementation of the algorithm in python &lt;a href=&#34;https://colab.research.google.com/drive/1V75UgfJEfCWgbfxnG4OuB1WpvqahUJPU&#34;&gt;here&lt;/a&gt; forms the basis (and only has minor tweaks in my final code).&lt;/p&gt;
&lt;p&gt;As always, let’s first load some libraries we’ll need:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(3459)
#libraries
library(tidyverse)
library(ggsoccer)
library(mvtnorm) #might be possible with MASS
library(zoo)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;the-theory&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Theory&lt;/h1&gt;
&lt;p&gt;Imagine two teams, I and J. Each of these has 11 players (hopefully) on the pitch at any time chasing after one ball. We want to know which team controls which parts of the pitch for each point in the match. As ‘control’ in a football match really only refers to “will player on my team get to a potential pass there first”, we are just looking at where players i,j,k… are going to be at time t + n seconds.&lt;/p&gt;
&lt;p&gt;The easiest way to start to approximate this is to imagine a set of players who never change direction, they only speed up or slow down (and possibly reverse). E.g. a full back running up and down the wings like a rook in a chess game. Their location at t + 1 will be their current location plus the expected value of their velocity.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#make up some movement data
full_back_pos &amp;lt;- data.frame(x = 40, y = 70)
full_back_movement &amp;lt;- data.frame(
  pos = 40,
  x = c(10, 100),
  y_pos = 70)

next_x &amp;lt;- rnorm(10000, 60, 5)
next_x &amp;lt;- next_x - (next_x %% 5)
full_back_next_pos &amp;lt;- data.frame(table(next_x)) %&amp;gt;%
  mutate(y = 70, 
         next_x = as.numeric(as.character(next_x)),
         Freq = Freq / sum(Freq))
  

#plot fake movement data
p &amp;lt;- ggplot() +
  annotate_pitch(dimensions = pitch_statsbomb) +
  geom_tile(data = full_back_next_pos, 
            aes(x = next_x, y = y, fill = Freq),
            alpha = 0.7, height = 10) +
  scale_fill_viridis_c(name = &amp;quot;confidence&amp;quot;) +
  geom_segment(data = full_back_movement,
               aes(x = pos, xend = x, y = y_pos, yend = y_pos), size = 2) +
  geom_point(data = full_back_pos, 
             aes(x = x , y = y), 
             shape = 21, colour = &amp;quot;black&amp;quot;, fill = &amp;quot;red&amp;quot;, size = 5) +
  theme_pitch()

p&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-04-20-wide_open_spaces_1_files/figure-html/player_example-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;As we’re not fully confident in our assessment of how fast this full back is, we aren’t 100% sure where his next position will be (at time t + n seconds), but given how quick we &lt;em&gt;expect&lt;/em&gt; him to be, we can produce produce an expected distribution of his next x coordinate (here binned into boxes of 5m worth). This estimate will vary according to two parameters, the mean speed (μ) and the standard deviation of that speed (σ). If we make 10000 such estimates (assuming no bias and forgetting our previous estimate etc.) these will form the normal distribution probability density function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plot histogram of fake movement data
p2 &amp;lt;- ggplot(full_back_next_pos, aes(x = next_x, y = Freq)) +
  geom_bar(stat = &amp;quot;identity&amp;quot;) +
  ylab(&amp;quot;confidence&amp;quot;) +
  xlab(&amp;quot;next x coordinate&amp;quot;) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-04-20-wide_open_spaces_1_files/figure-html/player_example_hist-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;(here I’ve plotted the x axis as the next x coordinate which is just our estimate of the x speed + the original x coordinate [40]).&lt;/p&gt;
&lt;p&gt;But this is obviously an oversimplification because players can travel in a myriad different directions across the pitch- we need our normal distribution confidence interval to generalise across more than 1 dimension.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#fake data in 2 dimensions now
next_x &amp;lt;- rnorm(10000, 60, 5)
next_x &amp;lt;- next_x - (next_x %% 5)
next_y &amp;lt;- rnorm(10000, 65, 3)
next_y &amp;lt;- next_y - (next_y %% 5)

full_back_next_pos &amp;lt;- data.frame(next_x, next_y) %&amp;gt;%
  group_by(next_x, next_y) %&amp;gt;%
  summarise(Freq = n())

full_back_movement &amp;lt;- data.frame(x = 40, y = 70, next_x = 60, next_y = 60)

#plot
p3 &amp;lt;- ggplot() +
  annotate_pitch(dimensions = pitch_statsbomb) +
  geom_tile(data = full_back_next_pos, 
            aes(x = next_x, y = next_y, fill = Freq), 
            alpha = 0.7, height = 10) +
  scale_fill_viridis_c(name = &amp;quot;confidence&amp;quot;) +
  geom_segment(data = full_back_movement, 
               aes(x = x, xend = next_x, y = y, yend = next_y),
               size = 2, arrow = arrow(length = unit(0.03, &amp;quot;npc&amp;quot;))) +
  geom_point(data = full_back_pos,
             aes(x = x , y = y),
             shape = 21, colour = &amp;quot;black&amp;quot;, fill = &amp;quot;red&amp;quot;, size = 5) +
  theme_pitch()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-04-20-wide_open_spaces_1_files/figure-html/player_example_2d-1.png&#34; width=&#34;672&#34; /&gt;
So now we have a realistic of guess, based upon the players velocity vector, of where they will be in n seconds time. If we do the same for every player of the pitch, we get a (roughly) 22 layer raster detailing how likely any single player is to be able to be in location x, y at time t + n. If a football magically appeared at point x,y, we now know which player(s) are likely to be able to reach it. Therefore, we know we parts of the pitch team I or J ‘controls’- where their teammates can pass to and expect them to receive the ball.&lt;/p&gt;
&lt;p&gt;This really is the fundamental idea of the pitch control metric presented in &lt;a href=&#34;http://www.sloansportsconference.com/wp-content/uploads/2018/03/1003.pdf&#34;&gt;Wide Open Spaces&lt;/a&gt;- we can use the expected 2d position of each player in the next n seconds, to work out which team would win the ball if it were dropped on a specific coordinate. This is what we mean by ‘pitch control’.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-math&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Math&lt;/h1&gt;
&lt;p&gt;Now we have an idea of what we want to do, ‘we’ need to formalise it. Luckily the paper already does it for us and all we need to do is follow the derivation. First, need to define two terms. We’ll call the space of possible locations (120 x 80m for me) P(itch) and the range of times T(ime)&lt;/p&gt;
&lt;p&gt;For every single point p at time t pitch control (PC) is defined by equation 2&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[PC_{(p,t)} = \sigma \sum_{i} I_{(p,t)} - \sum_{j} I_{(p,t)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;where you sum across i (all the players on team I) and j (all the players on team J). This is then multiplied by a logistic function (σ). Due to the logistic function, the output of this (PC) will have a value from 0 to 1 where &amp;lt;0.5 is control by team J and &amp;gt;0.5 is control by team I. E.g. if you drop a ball at place p at time t, if PC(p,t) is greater than 0.5, team I is likelier to get the ball, and viceversa for &amp;lt;0.5.&lt;/p&gt;
&lt;p&gt;We’ll rewrite this with sigma replace with numbers as:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[PC(p,t) = \frac{1}{1 + (\sum_{i} I(p,t) - \sum_{j} I(p,t))}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;From here it should be obvious we need to calculate I(p,t) for each player. We do this in equation 1&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[I_{i}(p,t) = \frac{f_{i}(p,t)}{f_{i}(p_{i}(t), t)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The numerator here is the probability density function of the player influence. How much influence does a single player have over any single part of the pitch surface (p) at a time (t). This is normalised by the denominator which does the same thing only for the players current location at time t (p_i(t)).&lt;/p&gt;
&lt;p&gt;Ok so so far so good. Equations 4 and 5 in the paper we’ll come back to later but they define the value of having the ball at these locations. Don’t worry about that for now. We won’t really go into that in this post.&lt;/p&gt;
&lt;p&gt;If we then skip to the supplemental figures we hit the pretty rough equation 12 which tells us how to solve for f_i(p,t)&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[f_{i}(p,t) = \frac{1}{\sqrt{(2\pi)^2detCOV_{i}(t)}}exp(-\frac{1}{2}(p-\mu_{i}(\overrightarrow{s}_{i}(t)))^tCOV_{i}(t)^{-1}(p-\mu_{i}(t)))  \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It looks horrendous but it’s just the equation for the multivariate normal distribution. See for example &lt;a href=&#34;https://wikimedia.org/api/rest_v1/media/math/render/svg/c66e6f6abd66698181e114a4b00da97446efd3c4&#34;&gt;here&lt;/a&gt;. It’s not a surprise to see this equation because we know we need to solve a multivariate normal from the example using our full back above!&lt;/p&gt;
&lt;p&gt;All we need to do is find x, μ, and Σ, in the linked picture above. Then we’re going to use mvtnorm::dmvnorm to calculate the density function. If you run&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;?mvtnorm::dmvnorm&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;you can see that ‘coincidentally’ this also requires 3 arguments (ignore the 4th log = FALSE), x, μ (mean), and sigma. All we have to do is find out what each of these arguments are equal to.&lt;/p&gt;
&lt;p&gt;Firstly we want to find the covariance matrix (COV_i(t)). To calculate this, we can rewrite it as Sigma- the product of two matrices R and S such that:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \Sigma = R\cdot S \cdot S \cdot R^{-1}\]&lt;/span&gt;
where R is the rotation matrix around the euclidean plane:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[R = 
\begin{bmatrix}
cos(\theta) &amp;amp; -sin(\theta) \\
sin(\theta) &amp;amp; cos(\theta) \\
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and S is a scaling matrix&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[S = 
\begin{bmatrix}
s_{x} &amp;amp; 0 \\
0 &amp;amp; s_{y} \\
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;The details of this transformation aren’t really important, but a good explanation can be found &lt;a href=&#34;https://www.visiondummy.com/2014/04/geometric-interpretation-covariance-matrix/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After resolving these matrices, we then only need to find the mean value of the distribution (μ_i(t)) which is defined in equation 21 of the paper&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_{i}(t) = p_{i}(t) + \overrightarrow{\widehat{s}}_{i}(t) \cdot 0.5 \]&lt;/span&gt;
(we’ll go over the details of this equation later)&lt;/p&gt;
&lt;p&gt;and also the pitch area, p, which is just an area of the pitch we want to find the control a player exerts over. We define this by dividing the total pitch area into many ‘pixels’ sampling each in our multivariate normal function. For example, in you split a 120m x 80m pitch into 1m^2 boxes, there are 120 * 80 = 9600 ‘pixels’ to run across.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;the-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;The Data&lt;/h1&gt;
&lt;p&gt;Now we’ve (briefly) gone through the theory, we can start working with the data and build our way back up. First we need to get our hands on the data itself. As part of the Friends of Tracking project during lockdown, Metrica Sports have kindly provided 2 sample matches (I’m using match 1 here) of tracking and event data which can be found &lt;a href=&#34;https://github.com/metrica-sports/sample-data&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The function below downloads, melts and organises the data.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#func to download and melt tracking data
#will use game 1
get_tracking_data &amp;lt;- function(file, directory = &amp;quot;metrica-sports/sample-data&amp;quot;, x_adj = 120, y_adj = 80) {
  #build url
  url &amp;lt;- paste0(&amp;quot;https://raw.githubusercontent.com/&amp;quot;, directory, &amp;quot;/master/data/&amp;quot;, file)
  #read data
  data &amp;lt;- read_csv(url, skip = 2)
  
  #fix names
  names(data)[grep(&amp;quot;^X[0-9]*$&amp;quot;, names(data))-1] &amp;lt;- paste0(names(data)[grep(&amp;quot;^X[0-9]*$&amp;quot;, names(data))-1], &amp;quot;_x&amp;quot;)
  names(data)[grep(&amp;quot;^X[0-9]*$&amp;quot;, names(data))] &amp;lt;- gsub(&amp;quot;_x$&amp;quot;, &amp;quot;_y&amp;quot;, names(data)[grep(&amp;quot;^X[0-9]*$&amp;quot;, names(data))-1])
  
  #melt it from long to wide
  melted_data &amp;lt;- data %&amp;gt;%
    pivot_longer(cols = starts_with(&amp;quot;Player&amp;quot;)) %&amp;gt;%
    separate(name, into = c(&amp;quot;player&amp;quot;, &amp;quot;coord&amp;quot;), sep = &amp;quot;_&amp;quot;) %&amp;gt;%
    pivot_wider(names_from = &amp;quot;coord&amp;quot;, values_from = &amp;quot;value&amp;quot;) %&amp;gt;%
    rename(time = `Time [s]`) %&amp;gt;%
    rename_all(tolower) %&amp;gt;%
    #add the team info
    #scale coords to statsbomb spec
    mutate(team = gsub(&amp;quot;(.*)(Home_Team|Away_Team)(\\..*)&amp;quot;, &amp;quot;\\2&amp;quot;, file)) %&amp;gt;%
    mutate_at(vars(ends_with(&amp;quot;x&amp;quot;)), ~.x * x_adj) %&amp;gt;%
    mutate_at(vars(ends_with(&amp;quot;y&amp;quot;)), ~.x * y_adj) %&amp;gt;%
    arrange(player, frame) %&amp;gt;%
    #some missing values on the ball location
    #will just say ball stays where it is when no location data
    #could interpolate but w/e
    mutate(ball_x = na.locf(ball_x),
           ball_y = na.locf(ball_y))
  return(melted_data)
}

#run
tracking_data &amp;lt;- map_df(
  c(&amp;quot;Sample_Game_1/Sample_Game_1_RawTrackingData_Away_Team.csv&amp;quot;, 
    &amp;quot;Sample_Game_1/Sample_Game_1_RawTrackingData_Home_Team.csv&amp;quot;),
  get_tracking_data) %&amp;gt;%
  filter(!is.na(x) &amp;amp; !is.na(y))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To calculate pitch control, we only need 4 pieces on information on each player to calculate their relative pitch control:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;their x,y location on the pitch&lt;/li&gt;
&lt;li&gt;the x,y location of the ball&lt;/li&gt;
&lt;li&gt;the time at which they were at that location&lt;/li&gt;
&lt;li&gt;and also, their location x,y at time t + n&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(tracking_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 9
##   period frame  time ball_x ball_y player       x     y team     
##    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    
## 1      1     1  0.04   54.6   31.0 Player15  70.1  16.6 Away_Team
## 2      1     2  0.08   59.6   32.5 Player15  70.1  16.6 Away_Team
## 3      1     3  0.12   64.5   34.0 Player15  70.1  16.6 Away_Team
## 4      1     4  0.16   66.4   33.8 Player15  70.0  16.7 Away_Team
## 5      1     5  0.2    66.6   32.5 Player15  69.9  16.8 Away_Team
## 6      1     6  0.24   66.8   31.1 Player15  69.9  16.9 Away_Team&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and from this we can build up everything we need. We’ll also want the team data at the end to sum across all players but for now that isn’t important.&lt;/p&gt;
&lt;p&gt;First lets do the two simplest: the speed and trajectory of a player’s movement. To ease processing, first we’ll put all the information needed per frame on one line. Not strictly necessary, but allows for neater functions when we really get processing&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#first add in the lead x/y to ease processing 
tracking_data &amp;lt;- tracking_data %&amp;gt;%
  group_by(player, team, period) %&amp;gt;%
  #player x,y and time at t + n
  mutate(next_x = lead(x), next_y = lead(y), next_time = lead(time)) %&amp;gt;%
  #to develop velocity arrows per player
  mutate(forward_x = lead(x, 10), forward_y = lead(y, 10)) %&amp;gt;%
  ungroup() &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We calculate the speed in the x and y dimensions simply as the change in position divided by the time taken, and can calculate theta using either this speed vector, or the change in position (defined as the angle from the x axis the vector takes).&lt;/p&gt;
&lt;p&gt;For an example, here is the data for 4 seconds on Player15 in the sample dataset. It’s taken from about 4 minutes into the match.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#filters for some data to plot
player_spec &amp;lt;- &amp;quot;Player15&amp;quot;
#each frame is 0.04s apart, take 100 frames worth from t = 250
times_spec &amp;lt;- seq(250, by = 0.04, length.out = 100)

#filter
example_data &amp;lt;- tracking_data %&amp;gt;%
  filter(player == player_spec &amp;amp; time %in% times_spec)

#plot the players trajectory over this time
#and the velocity and theta derived from it
p4 &amp;lt;- ggplot(example_data) +
  geom_point(aes(x = x, y = y, colour = time), alpha = 0.6, size = 3) +
  #plot the x-axis as a green line
  geom_hline(yintercept = first(example_data$y), colour = &amp;quot;green&amp;quot;, alpha = 0.5, size = 3) +
  #plot the x-axis movement
  geom_segment(aes(x = first(x), xend = last(x), y = first(y), yend = first(y)), 
               arrow = arrow(length = unit(0.03, &amp;quot;npc&amp;quot;))) +
  #plot the y axis movement
  geom_segment(aes(x = last(x), xend = last(x), y = first(y), yend = last(y)), 
               arrow = arrow(length = unit(0.03, &amp;quot;npc&amp;quot;))) +
  #plot the hypotenuse
  geom_segment(aes(x = first(x), xend = last(x), y = first(y), yend = last(y)),
               size = 2, colour = &amp;quot;red&amp;quot;, arrow = arrow(length = unit(0.03, &amp;quot;npc&amp;quot;))) +
  #anotate speeds and theta
  annotate(&amp;quot;text&amp;quot;, x = 105.5, y = 17.3, label = &amp;quot;x speed = 0.95 m/s&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = 106.75, y = 16.25, label = &amp;quot;y speed =\n0.56m/s&amp;quot;) +
  annotate(&amp;quot;text&amp;quot;, x = 104.25, y = 16.9, label = &amp;quot;theta = -30.4°&amp;quot;) +
  labs(x = &amp;quot;pitch x coord (/m)&amp;quot;,
       y = &amp;quot;pitch y coord (/m)&amp;quot;,
       title = &amp;quot;example player movement over 4 seconds&amp;quot;) +
  #scale manually so it isn&amp;#39;t distorted
  scale_x_continuous(limits = c(103.5, 107.5)) +
  scale_y_continuous(limits = c(14, 18)) +
  theme_minimal()

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-04-20-wide_open_spaces_1_files/figure-html/example_data-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;So we get a good idea of the players trajectory over those 4 seconds and the average velocity and angle he is travelling at.&lt;/p&gt;
&lt;p&gt;We can now start building up all the calculations we need to do to work out the pitch control any one player (and then whole teams) exert from basics. Through this I’m going to define each sum as a function to make it &lt;em&gt;extremely&lt;/em&gt; clear what’s going on. Some of those functions will be ridiculously simple, but I don’t want to skip over anything.&lt;/p&gt;
&lt;p&gt;Starting with the speed in any dimension and the angle from the x axis (theta) the player is travelling at:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#no real reason for these to be functions, but just to
#make it more obvious what we&amp;#39;re doing
get_speed &amp;lt;- function(coord, next_coord, time, next_time) {
  #speed in meters per second
  speed = (next_coord - coord) / (next_time - time)
  return(speed)
}

#again very simple for illustrative purposes
get_theta &amp;lt;- function(x_speed, y_speed) {
  hypotenuse_speed = sqrt(x_speed^2 + y_speed^2)
  theta = acos(x_speed / hypotenuse_speed)
  return(theta)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;if we plug our data from graph p4 into these very verbose-ly we get&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;x_start &amp;lt;- first(example_data$x)
x_end &amp;lt;- last(example_data$x)
y_start &amp;lt;- first(example_data$y)
y_end &amp;lt;- last(example_data$y)
t_start &amp;lt;- first(example_data$time)
t_end &amp;lt;- last(example_data$time)

#in m/s
speed_x &amp;lt;- get_speed(x_start, x_end, t_start, t_end)
speed_y &amp;lt;- get_speed(y_start, y_end, t_start, t_end)

#convert to degrees
theta &amp;lt;- get_theta(speed_x, speed_y)
theta_deg &amp;lt;- theta * (180/pi)

results &amp;lt;- c(speed_x, speed_y, theta_deg)
names(results) &amp;lt;- c(&amp;quot;speed_x&amp;quot;, &amp;quot;speed_y&amp;quot;, &amp;quot;theta&amp;quot;)
print(results)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    speed_x    speed_y      theta 
##  0.9496970 -0.5575758 30.4175840&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;(the calculations will use theta in radians, but I think it makes more sense to show it here in degrees).&lt;/p&gt;
&lt;p&gt;We can now very trivially solve equation 21 right off the bat&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\mu_{i}(t) = p_{i}(t) + \overrightarrow{\widehat{s}}_{i}(t) \cdot 0.5 \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Where p is the location of player i at time t, and s_hat is the speed of the player in either dimension. The mean of the distribution (where we expect the player to have the most pitch control) is his current position + (where he will be / 2)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#another simple function to find mu
get_mu &amp;lt;- function(location, speed) {
  mu = location + speed / 2
  return(mu)
}

mu_x &amp;lt;- get_mu(x_start, speed_x)
mu_y &amp;lt;- get_mu(y_start, speed_y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which means we now have the first of our variables for our big multivariate normal distribution equation (paper equation 12)&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[f_{i}(p,t) = \frac{1}{\sqrt{(2\pi)^2detCOV_{i}(t)}}exp(-\frac{1}{2}(p-\mu_{i}(\overrightarrow{s}_{i}(t)))^tCOV_{i}(t)^{-1}(p-\mu_{i}(t)))  \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and just need to define p, and calculate the covariance matrix COV.&lt;/p&gt;
&lt;p&gt;We can start calculating the components of the covariance matrix with equation 18 (calculating the speed as a ratio of max speed) which is also trivial to solve now. Instead of using the speed in either direction, this relies on the total velocity , which we can find using school trigonometry&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ Srat_{i}(t) = \frac{s^2}{ 13^2 } \]&lt;/span&gt;
The 13m/s constant is the assumed maximum possible speed of a player (averaging this over 100m would break the world record by ~2 seconds)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_srat &amp;lt;- function(speed_x, speed_y) {
  #find total velocity
  speed &amp;lt;- sqrt(speed_x^2 + abs(speed_y)^2)
  srat = (speed / 13)^2
  return(srat)
}

srat &amp;lt;- get_srat(speed_x, speed_y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can also find the constant Ri- the radius of a players influence- which isn’t listed in the paper but gives rise to figure 9. Given the formula isn’t listed, the numeric constants in the equation might be slightly off. They’re all taken from Will Thomson’s work &lt;a href=&#34;https://colab.research.google.com/drive/1V75UgfJEfCWgbfxnG4OuB1WpvqahUJPU?pli=1&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[R_{i}(t) = 
\begin{cases} 
4 + \frac{(p_{i}(t) - p_{b}(t))^3}{18^3 / 6} &amp;amp; \text{if &amp;lt; 10} \\
10 &amp;amp; \text{else}
\end{cases}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;It specifies that a player has an influence radius of 10 metres, unless they are within ~15metres of the ball, in which case their influence radius decreases with ball_distance to a minimum of 4 metres. The idea behind this is that a player nearer the ball is much more geographically focused in their movement- as they either posses the ball or are trying to win it back.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#allocate a few more variables from our example data
ball_x &amp;lt;- first(example_data$ball_x)
ball_y &amp;lt;- first(example_data$ball_y)

#little bit more complicated but still easy
get_ri &amp;lt;- function(x, y, ball_x, ball_y) {
  ball_diff &amp;lt;- sqrt((x - ball_x) ^ 2 + (y - ball_y)^2)
  ri = 4 + ((ball_diff^3) / ((18^3) / 6))
  return(min(ri, 10))  
}

ri &amp;lt;- get_ri(x_start, y_start, ball_x, ball_y)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can test this function in the range of distance to the ball 0-30m and compare it to figure 9 in the paper&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p5 &amp;lt;- data.frame(
  x = 0:30,
  y = map_dbl(0:30, get_ri,
    #set all other args to 0
    y = 0, ball_x = 0, ball_y = 0)) %&amp;gt;%
  ggplot(aes(x = x, y = y)) +
  geom_line(colour = &amp;quot;maroon&amp;quot;, size = 2) +
  geom_point(size = 3, alpha = 0.5) +
  scale_y_continuous(limits = c(0, 12)) +
  labs(title = &amp;quot;paper figure 9 (approx)&amp;quot;,
       x = &amp;quot;distance to the ball (/m)&amp;quot;,
       y = &amp;quot;influence radius (/m)&amp;quot;) +
  theme_minimal() 

p5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-04-20-wide_open_spaces_1_files/figure-html/test_function-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We’re really getting there now. We just need to define our covariance matrix and we’re done with equations. Remember earlier with redefined&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \Sigma = R\cdot S \cdot S \cdot R^{-1}\]&lt;/span&gt;
in paper equation 14, where R is the rotation matrix, and S is the scaling matrix.&lt;/p&gt;
&lt;p&gt;To rotate in Euclidean space clockwise from the x-axis, the rotation matrix &lt;a href=&#34;https://en.wikipedia.org/wiki/Rotation_matrix&#34;&gt;is just&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[R = 
\begin{bmatrix}
cos(\theta) &amp;amp; -sin(\theta) \\
sin(\theta) &amp;amp; cos(\theta) \\
\end{bmatrix}
\]&lt;/span&gt;
as also defined in the paper in equation 16. Easy enough to define, we just need to put the right transform of theta in the right space&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_R &amp;lt;- function(theta) {
  #R fills down first so these aren&amp;#39;t the wrong way round
  R = matrix(c(cos(theta), sin(theta), -sin(theta), cos(theta)), nrow = 2)
  return(R)
}

R &amp;lt;- get_R(theta)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For simplicity, I earlier said that the scaling matrix (S) was equivalent to the speed of the player in x and y dimensions, which was a bit of a white lie. It &lt;em&gt;is&lt;/em&gt; derived from that, but itself scaled by the influence radius of the player (Ri)&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[S = 
\begin{bmatrix}
s_{x} &amp;amp; 0 \\
0 &amp;amp; s_{y} \\
\end{bmatrix}
\]&lt;/span&gt;
&lt;span class=&#34;math display&#34;&gt;\[S_{i}(t) = 
\begin{bmatrix}
\frac{R_{i}(t) \cdot (1 + Srat_{i}(\overrightarrow{s}_{i}(t)))}{2} &amp;amp; 0 \\
0 &amp;amp; \frac{R_{i}(t) \cdot (1-Srat_{i}(\overrightarrow{s}_{i}(t)))}{2} \\
\end{bmatrix}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;This is the same as equation 19, I’ve just taken the Ri outside the brackets. As with the rotation matrix R, this is just matrix building and putting the right variables in the right place&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_S &amp;lt;- function(ri, srat) {
  top_left &amp;lt;- ri * (1 + srat) / 2
  bottom_right &amp;lt;- ri * (1-srat) / 2
  S = matrix(c(top_left, 0, 0, bottom_right), nrow = 2)
}

S &amp;lt;- get_S(ri, srat)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once we have R and S, Σ is just equal to the dot product of these as in equation 15&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;get_Sigma &amp;lt;- function(R, S) {
  inv_R &amp;lt;- solve(R)
  Sigma = R %*% S %*% S %*% inv_R
  return(Sigma)
}

Sigma &amp;lt;- get_Sigma(R, S)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now we have the mean (μ), sigma (Σ) arguments to our dmvnorm function to calculate a players pitch control. We just to plug in the p term (corresponding to x in the R function arguments).&lt;/p&gt;
&lt;p&gt;As in equation 1 (and 13), we actually need &lt;em&gt;two&lt;/em&gt; p terms:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[I_{i}(p,t) = \frac{f_{i}(p,t)}{f_{i}(p_{i}(t), t)} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;the first (p) account for every ‘unit’ of the pitch (we divide the pitch up into each squares and calculate a players influence on each) and a second (p_i) which is the control of a player on their own area of pitch p. The denominator (control of pitch at player i’s x,y) is used to normalise the control they exert across the pitch from 0-1.&lt;/p&gt;
&lt;p&gt;To create the matrix of pitch zones, we can simply use seq and expand.grid on the dimensions of the pitch. Splitting each dimension 200 ways leaves us with a 40000 x 2 data.frame to apply as p. For p_i, we just use the player’s x and y coordinates.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#use statsbomb coords - 120m x 80m pitch
#split into 200x200 rectangles
pitch &amp;lt;- expand.grid(seq(0, 120, length.out = 200), seq(0, 80, length.out = 200)) %&amp;gt;%
    rename(x = Var1, y = Var2)

#function to calculate I as in equation 1/13
calc_I &amp;lt;- function(pitch_area, x, y, mu_x, mu_y, Sigma) {
  #create vectors
  mu &amp;lt;- c(mu_x, mu_y)
  player_loc &amp;lt;- c(x, y)
  
  numerator &amp;lt;- dmvnorm(as.matrix(pitch_area), mu, Sigma)
  denominator &amp;lt;- dmvnorm(t(matrix(player_loc)), mu, Sigma)
  #and normalise
  norm_pdf = numerator/denominator
  return(norm_pdf)
}

#column I is the control on pitch area x,y of player I
I &amp;lt;- calc_I(pitch, x_start, y_start, mu_x, mu_y, Sigma)
head(mutate(pitch, I))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##           x y            I
## 1 0.0000000 0 4.256184e-96
## 2 0.6030151 0 5.076124e-95
## 3 1.2060302 0 5.967198e-94
## 4 1.8090452 0 6.914091e-93
## 5 2.4120603 0 7.896343e-92
## 6 3.0150754 0 8.888804e-91&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We of course need to do this across the whole team, summing the pitch influence per team then finding the difference between them as per equation 2 in the paper&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[PC_{(p,t)} = \sigma \sum_{i} I_{(p,t)} - \sum_{j} I_{(p,t)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;I’ve neatly nested all the functions we’ve written into one larger function which every row of a team is then applied to using pmap from the purrr package.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test our functions on one frame of the tracking data
testing_data &amp;lt;- tracking_data %&amp;gt;%
  filter(time == 600) 

#sum all our little functions into one bigger function
calc_PC &amp;lt;- function(time, next_time, ball_x, ball_y, x, y, next_x, next_y, team, player, pitch_area) {
  speed_x &amp;lt;- get_speed(x, next_x, time, next_time)
  speed_y &amp;lt;- get_speed(y, next_y, time, next_time)
  srat &amp;lt;- get_srat(speed_x, speed_y)
  theta &amp;lt;- get_theta(speed_x, speed_y)
  
  mu_x &amp;lt;- get_mu(x, speed_x)
  mu_y &amp;lt;- get_mu(y, speed_y)
  
  ri &amp;lt;- get_ri(x, y, ball_x, ball_y)

  R &amp;lt;- get_R(theta)
  S &amp;lt;- get_S(ri, srat)
  
  Sigma &amp;lt;- get_Sigma(R, S)
  
  pitch_area$I &amp;lt;- calc_I(as.matrix(pitch), x, y, mu_x, mu_y, Sigma)
  pitch_area$team &amp;lt;- team
  pitch_area$time &amp;lt;- time
  pitch_area$player &amp;lt;- player
  return(pitch_area)
}

#run the pitch control function
pitch_control &amp;lt;- testing_data %&amp;gt;%
  select(time, next_time, ball_x, ball_y, x, y, next_x, next_y, player, team) %&amp;gt;%
  #run func
  pmap_df(., calc_PC, pitch_area = pitch) %&amp;gt;%
  #sum by team and area
  group_by(team, x, y) %&amp;gt;%
  summarise(team_sum = sum(I)) %&amp;gt;%
  pivot_wider(names_from = team, values_from = team_sum) %&amp;gt;%
  #σ - logistic function
  mutate(PC = 1 / (1 + exp(Home_Team - Away_Team)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After calculating the individual pitch control metrics, we sum by team and pixel and then subtract the away team sum from the home team sum and run it through a simple logistic function (σ)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get the position of the ball for this frame
ball_location &amp;lt;- testing_data %&amp;gt;%
  select(ball_x, ball_y) %&amp;gt;%
  unique()

#plot it all
p6 &amp;lt;- ggplot() +
  #pitch layout background
  annotate_pitch(dimensions = pitch_statsbomb) +
  #pitch control raster
  geom_tile(data = pitch_control, aes(x = x, y = y, fill = PC), alpha = 0.7) +
  scale_fill_gradient2(low = &amp;quot;blue&amp;quot;, high = &amp;quot;red&amp;quot;, mid = &amp;quot;white&amp;quot;, midpoint = 0.5) +
  #players for each team
  #also add in little vector arrows
  geom_segment(data = testing_data, aes(x = x, y = y, xend = forward_x, yend = forward_y, colour = team),
               size = 1, arrow = arrow(length = unit(0.01, &amp;quot;npc&amp;quot;))) +
  geom_point(data = testing_data, aes(x = x, y = y, colour = team), size = 3) +
  scale_colour_manual(values = c(&amp;quot;black&amp;quot;, &amp;quot;gold&amp;quot;), guide = FALSE) +
  #ball location
  geom_point(data = ball_location, aes(x = ball_x, y = ball_y),
             colour = &amp;quot;black&amp;quot;, fill = &amp;quot;white&amp;quot;, shape = 21, size = 2.5, stroke = 2) +
  theme_pitch()

p6&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-04-20-wide_open_spaces_1_files/figure-html/plot_PC-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It looks pretty good! We can see which areas on the pitch the yellow and black (blue and red areas respectively) control (the ball here is the white circle outlined in black). In theory we can now run this function over the whole tracking_data data frame and calculate the control of each time over every part of the pitch at any time.&lt;/p&gt;
&lt;p&gt;If we know this, we can work out (e.g.) the potential of an attack by multiplying the pitch control by a second layer, the value of every area of the pitch. For a very good intro into why/how you might value pitch areas, see &lt;a href=&#34;https://karun.in/blog/expected-threat.html&#34;&gt;Karun Singh’s explanation of Expected Threat&lt;/a&gt;. The paper itself uses a neural network based on the ball location. It can be best understood as imaging that you only know the location of the ball and are asked where the best place to pass it to would be? Moving it towards the centre of the opposition goal (reducing distance and angle) is always better, but you also want to maximise the chance of the pass being successful. The paper includes a great mp4 of modeled real life play hosted on &lt;a href=&#34;http://www.lukebornn.com/sloan/field_value.mp4&#34;&gt;Luke Bornn’s website&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This post is already long enough so I’m not going to go into pitch value more here, but will hopefully write a followup combining the two at some point.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;premature-optimisation&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;(premature) optimisation&lt;/h1&gt;
&lt;p&gt;(There’s not really much gain from reading beyond here, but I attempted to implement it in Rcpp for some optimisation which worked a little bit- I’m sure this function could be vastly improved though so it might be of value leaving it here for others to run with)&lt;/p&gt;
&lt;p&gt;So this is all fine and good, but we probably want to run this at least over every frame in the game, and possibly many games! To do this we’re really going to want to optimise the crap out of this function. I’ve had a first go at this using Rcpp and RcppArmadillo to implement the whole pitch control algorithm. It actually didn’t speed things up as much as I wanted*, but does remove 20-30% of the time the R function takes. (it’s also just good practice to write more C++ for myself).&lt;/p&gt;
&lt;p&gt;*lots more low hanging fruit to take out of it, but it does the job for now&lt;/p&gt;
&lt;p&gt;We’ll need a few Rcpp libraries to implement this:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(Rcpp)
library(RcppArmadillo)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And then can use a Rcpp chunk to export a compiled function that R can access&lt;/p&gt;
&lt;pre class=&#34;cpp&#34;&gt;&lt;code&gt;//namespaces
#include &amp;lt;RcppArmadillo.h&amp;gt;
// [[Rcpp::depends(RcppArmadillo)]]

using namespace Rcpp;

/* C++ version of the dtrmv BLAS function */
// stolen from https://gallery.rcpp.org/articles/dmvnorm_arma/
void inplace_tri_mat_mult(arma::rowvec &amp;amp;x, arma::mat const &amp;amp;trimat){
  arma::uword const n = trimat.n_cols;
  
  for(unsigned j = n; j-- &amp;gt; 0;){
    double tmp(0.);
    for(unsigned i = 0; i &amp;lt;= j; ++i)
      tmp += trimat.at(i, j) * x[i];
    x[j] = tmp;
  }
}

//set log(2pi) as a constant
static double const log2pi = std::log(2.0 * M_PI);

//replaces the dmvnorm() multivariate sampling
arma::vec dmvnrm_arma_fast(arma::mat const &amp;amp;x,  
                           arma::rowvec const &amp;amp;mean,  
                           arma::mat const &amp;amp;sigma, 
                           bool const logd = false) { 
    using arma::uword;
    uword const n = x.n_rows, 
             xdim = x.n_cols;
    arma::vec out(n);
    arma::mat const rooti = arma::inv(trimatu(arma::chol(sigma)));
    double const rootisum = arma::sum(log(rooti.diag())), 
                constants = -(double)xdim/2.0 * log2pi, 
              other_terms = rootisum + constants;
    
    arma::rowvec z;
    for (uword i = 0; i &amp;lt; n; i++) {
        z = (x.row(i) - mean);
        inplace_tri_mat_mult(z, rooti);
        out(i) = other_terms - 0.5 * arma::dot(z, z);     
    }  
      
    if (logd)
      return out;
    return exp(out);
}

//does all the calculations in the paper
//outputs a vector
// [[Rcpp::export]]
arma::vec calc_I_cpp(arma::vec coords, arma::vec next_coords, arma::vec ball_coords, double t, double next_t, arma::mat pitch, arma::mat coord_mat) {
  arma::vec rng = runif(1);
  arma::vec velocity = ((next_coords - coords) + (rng[0] / 10000)) / (next_t - t);
  double speed = norm(velocity);
  double srat =pow((speed / 13), 2.0);
  double theta = acos(velocity[0] / speed);
  
  //sometimes players reach &amp;#39;impossible&amp;#39; speeds
  if(srat &amp;gt; 1) {
    velocity = {(12.5 * cos(theta)), (12.5 * sin(theta))};
    speed = norm(velocity);
    srat = pow((speed / 13), 2.0);
  }
  
  arma::mat R = {{+cos(theta), -sin(theta)},
                 {+sin(theta), +cos(theta)}};
  
  arma::vec m = coords + velocity / 2;
  arma::rowvec mu = arma::conv_to&amp;lt;arma::rowvec&amp;gt;::from(m);

  
  double ri_val = 4.0 + (pow(norm(ball_coords - coords), 3.0) / (pow(18.0, 3) / 6));
  double ri = std::min(ri_val, 10.0);
  arma::mat S = {{ri * (1 + srat) / 2, 0},
                 {0, ri * (1 - srat) / 2}};
  arma::mat inv_R = arma::inv(R);
  arma::mat Sigma = R * S * S * inv_R;
  
  arma::vec numerator = dmvnrm_arma_fast(pitch, mu, Sigma);
  arma::vec denominator = dmvnrm_arma_fast(coord_mat, mu, Sigma);
  arma::vec I = numerator / denominator[0];
  return I;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can now start running this over multiple frames. My laptop is pretty hideously falling apart at the moment, so I’ve limited it here, but really you could for sure run it over many frames. For plotting as a single object, remember, we’re using a 40000 (200 * 200) row df to store stuff which is surely less than optimal, but even cutting that down as much as feasible, with 25 frames a second, memory bloat is going to happen fast.&lt;/p&gt;
&lt;p&gt;In a future post at some point I’d like to actually try some analysis using this work, and I think the key is really to analyse within frame and output a condensed pitch area controlled * value for each player.&lt;/p&gt;
&lt;p&gt;For now though, I’ve posted a plot of ten seconds (not consecutive frames) of data. If you click on that, it links to an imgur of the gif of the proper combination of those frames.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#ugly packaged up function
calc_PC_cpp &amp;lt;- function(time, next_time, ball_x, ball_y, x, y, next_x, next_y, team, player, pitch_area) {
  #blargh terribly written- run out of energy to improve
  pitch_area$I &amp;lt;- calc_I_cpp(c(x, y), c(next_x, next_y), c(ball_x, ball_y), time, next_time, as.matrix(pitch_area), t(c(x, y)))
  pitch_area$team &amp;lt;- team
  pitch_area$time &amp;lt;- time
  pitch_area$player &amp;lt;- player
  return(pitch_area)
}

#sample 10 seconds worth of data
animation_data &amp;lt;- tracking_data %&amp;gt;%
  filter(time %in% 600:610) %&amp;gt;%
  dplyr::select(time, next_time, ball_x, ball_y, x, y, next_x, next_y, team, player) 

#run the function over the data
anim_pitch_control &amp;lt;- animation_data %&amp;gt;%
  #run func
  pmap_df(., calc_PC_cpp, pitch_area = pitch) %&amp;gt;%
  #sum by team and area
  group_by(team, x, y, time) %&amp;gt;%
  summarise(team_sum = sum(I)) %&amp;gt;%
  pivot_wider(names_from = team, values_from = team_sum) %&amp;gt;%
  #σ - logistic function
  mutate(PC = 1 / (1 + exp(Home_Team - Away_Team)))

#plot
p7 &amp;lt;- ggplot(anim_pitch_control, aes(x = x, y = y, colour = PC)) +
  annotate_pitch(dimensions = pitch_statsbomb) +
  geom_point(alpha = 0.7, shape = 15) +
  scale_colour_gradient2(low = &amp;quot;blue&amp;quot;, high = &amp;quot;red&amp;quot;, mid = &amp;quot;white&amp;quot;, midpoint = 0.5) +
  theme_pitch() +
  labs(title = &amp;quot;pitch control rasters by match time (s)&amp;quot;) +
  facet_wrap(~time)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://i.imgur.com/fYIfjaR.mp4&#34; title=&#34;plot of surface control&#34;&gt;&lt;img src=&#34;/img/pitch_control_raster.png&#34; alt=&#34;plot of surface control&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;(click for link to gif)&lt;/p&gt;
&lt;p&gt;I actually really like these plots of just the surface control; they remind me of high dimensional (e.g. biological sample) sorting and I think just look pretty funky&lt;/p&gt;
&lt;p&gt;I mentioned I benchmarked the functions themselves earlier, here’s some sample code of benchmarking. It’s not really apples to oranges because of the tweaks to the cpp function, and obviously calling pmap_df on a single row of a data.frame isn’t really what it’s for… it’s more just to document a little bit (also please ignore the spaghetti passing of functions).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(microbenchmark)
microbenchmark(
  pmap_calc_pc = pmap_df(animation_data[1,], calc_PC, pitch_area = pitch),
  pmap_calc_pc_cpp = pmap_df(animation_data[1,], calc_PC_cpp, pitch_area = pitch),
  calc_pc = calc_PC(animation_data$time[1], animation_data$next_time[1], animation_data$ball_x[1], animation_data$ball_y[1], animation_data$x[1], animation_data$y[1], animation_data$next_x[1], animation_data$next_y[1], &amp;quot;teamA&amp;quot;, &amp;quot;playera&amp;quot;, pitch),
  calc_pc_cpp = calc_PC_cpp(animation_data$time[1], animation_data$next_time[1], animation_data$ball_x[1], animation_data$ball_y[1], animation_data$x[1], animation_data$y[1], animation_data$next_x[1], animation_data$next_y[1], &amp;quot;teamA&amp;quot;, &amp;quot;playera&amp;quot;, pitch),
  times = 1000
)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: milliseconds
##              expr    min      lq     mean  median      uq      max neval
##      pmap_calc_pc 4.5347 5.95505 7.129008 6.30795 6.84670 125.7230  1000
##  pmap_calc_pc_cpp 3.8280 4.93920 5.608463 5.20625 5.64985 126.1780  1000
##           calc_pc 3.1482 4.16710 5.136463 4.38575 4.82170 127.3604  1000
##       calc_pc_cpp 2.4537 3.15150 4.023492 3.31625 3.63570 212.4050  1000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That’s all for this post! As I said at some point (soon? later? who knows) I’d like to include the value term because conceptually it’s not hard to get a stupid version of it going. Hopefully this is of use to some people. As I said up top, written in evenings locked inside during quarantine so probably maths mistakes/ huge coding errors etc. If people point them out and get in touch I’ll fix them.&lt;/p&gt;
&lt;p&gt;Best!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Five Minute Football Trivia - Trans-Europe Express</title>
      <link>/post/five_min_trivia_kraftwerk/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/five_min_trivia_kraftwerk/</guid>
      <description>


&lt;p&gt;&lt;em&gt;generally as I have less and less time to waste on meaningless football stats I get halfway through a post and abandon it. To remedy this, I want to start pushing out posts that give a reasonable half-guess at an answer within an hour or so without needing to really check my working or write good prose. This is the third of these&lt;/em&gt;&lt;/p&gt;
For this weeks question, I’m stealing straight from the source of most of my posts, &lt;a href=&#34;https://www.theguardian.com/football/series/theknowledge&#34;&gt;The Knowledge column&lt;/a&gt; at The Guardian:
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
What is the shortest total distance a club has had to travel in a Champions League winning campaign? (Perhaps average distance per (away) fixture to balance out changes in format over the years.)
&lt;/p&gt;
— JBfaeDundee (&lt;span class=&#34;citation&#34;&gt;@JBfaeDundee&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/JBfaeDundee/status/1242529510735720448?ref_src=twsrc%5Etfw&#34;&gt;March 24, 2020&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
I’m going to turn it on it’s head a bit, and find the longest distance campaigns, mostly because I find it more interesting, but also because it reminded me of this tweet from a few years ago
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
The longest away trip in the world took place today as Baltika Kaliningrad travelled about 10,000 km to meet Luch Vladivostok in the second division in Russia. &lt;br&gt;The gamed ended 0-0, of course. &lt;a href=&#34;https://t.co/EsSpmWzddk&#34;&gt;pic.twitter.com/EsSpmWzddk&lt;/a&gt;
&lt;/p&gt;
— Michael Yokhin (&lt;span class=&#34;citation&#34;&gt;@Yokhin&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/Yokhin/status/980050993810493440?ref_src=twsrc%5Etfw&#34;&gt;March 31, 2018&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;p&gt;And generally I love weird quirks of geography that lead to commutes of 13 hours like this.&lt;/p&gt;
&lt;p&gt;As always, first load the libraries we need. Having looked around, the most organised dataset seemed to be at &lt;a href=&#34;https://www.worldfootball.net&#34;&gt;worldfootball.net&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#scrape
library(rvest)
#using data from worldfootbal.net
base_url &amp;lt;- &amp;quot;https://www.worldfootball.net&amp;quot;

#tidy
library(tidyverse)
library(magrittr)
#map
library(sf)
library(rnaturalearth)
library(ggthemes)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To find the location of every team, we need a data.frame of every team to have competed in the Champions League (and Qualifying) since it’s inception. We can get that by sprintf’ing a list of urls and scraping the links to each team page from there. For this, and most of the scraping jobs below, I saved the data from the first time I scrape so that I don’t have to continually re-stress the worldfootball server. The datasets can be found in the static folder of my website GitHub.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#the years each competition took place
years &amp;lt;- 1955:2018
qual_years &amp;lt;- c(1966, 1969:1971, 1978:1982, 1992:2018)

#sprintf the correct urls together
all_urls &amp;lt;- c(sprintf(&amp;quot;/champions-league-%d-%d&amp;quot;, years, years+1),
      sprintf(&amp;quot;/champions-league-qualifikation-%d-%d&amp;quot;, qual_years, qual_years+1))

#some exceptions
all_urls[grepl(&amp;quot;champions-league-2010-2011&amp;quot;, all_urls)] %&amp;lt;&amp;gt;% paste0(., &amp;quot;_3&amp;quot;)
all_urls[grepl(&amp;quot;champions-league-2008-2009&amp;quot;, all_urls)] %&amp;lt;&amp;gt;% paste0(., &amp;quot;_2&amp;quot;)
all_urls[grepl(&amp;quot;qualifikation-2008-2009&amp;quot;, all_urls)] %&amp;lt;&amp;gt;% gsub(&amp;quot;qualifikation&amp;quot;, &amp;quot;qf&amp;quot;, .)
all_urls[grepl(&amp;quot;qualifikation&amp;quot;, all_urls) &amp;amp; as.numeric(gsub(&amp;quot;.*-&amp;quot;,&amp;quot;&amp;quot;,all_urls)&amp;gt;2009)]  %&amp;lt;&amp;gt;%
  gsub(&amp;quot;qualifikation&amp;quot;, &amp;quot;qual&amp;quot;, .)

#scrape the list of each team&amp;#39;s links
teams &amp;lt;- map_df(all_urls, function(competition_link) {
  #read once and scrape from there
  read &amp;lt;- read_html(paste0(base_url, &amp;quot;/players&amp;quot;, competition_link))
  #get the useful info
  competition &amp;lt;- read %&amp;gt;% html_nodes(&amp;quot;h1&amp;quot;) %&amp;gt;% html_text() %&amp;gt;% gsub(&amp;quot; » .*&amp;quot;, &amp;quot;&amp;quot;, .)
  team_name &amp;lt;- read %&amp;gt;% html_nodes(&amp;quot;td:nth-child(2) a&amp;quot;) %&amp;gt;% html_text()
  team_info &amp;lt;- read %&amp;gt;% html_nodes(&amp;quot;td:nth-child(4) a&amp;quot;) %&amp;gt;% html_attr(&amp;quot;href&amp;quot;)
  #compile into a df to return
  df &amp;lt;- data.frame(competition, team_name, team_info)
  return(df)
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;we can then take a look at what we have on our hands&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(teams)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                  competition              team_name
## 1 Champions League 1955/1956      1. FC Saarbrücken
## 2 Champions League 1955/1956              Aarhus GF
## 3 Champions League 1955/1956               AC Milan
## 4 Champions League 1955/1956 Budapesti Vörös Lobogó
## 5 Champions League 1955/1956         Djurgårdens IF
## 6 Champions League 1955/1956       Gwardia Warszawa
##                     team_info
## 1 /teams/1-fc-saarbruecken/1/
## 2         /teams/aarhus-gf/1/
## 3          /teams/ac-milan/1/
## 4      /teams/mtk-budapest/1/
## 5    /teams/djurgardens-if/1/
## 6  /teams/gwardia-warszawa/1/&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As a short aside, one of the things I really enjoy about posts like this one is it exposes you to lots of history from the ‘early’ days of organised football and the teams (some of which remain, some do not) that were present then.&lt;/p&gt;
&lt;p&gt;After this, we then want to scrape the data on every match played in the Champions League in a similar manner:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;match_data &amp;lt;- map_df(all_urls, function(competition_link) {
  #read once
  read &amp;lt;- read_html(paste0(base_url, &amp;quot;/all_matches&amp;quot;, competition_link))
  #get the competition/season id from the url
  season &amp;lt;- gsub(&amp;quot;(^.*-)([0-9]{4}-[0-9]{4})(.*)&amp;quot;, &amp;quot;\\2&amp;quot;, competition_link)
  competition &amp;lt;- ifelse(grepl(&amp;quot;-qual|-qf&amp;quot;, competition_link), &amp;quot;ucl-quals&amp;quot;, &amp;quot;ucl&amp;quot;)
  
  #scrape the links to each match- we&amp;#39;ll need some of these later
  match_link &amp;lt;- read %&amp;gt;%
    html_nodes(&amp;quot;td:nth-child(6) a&amp;quot;) %&amp;gt;%
    html_attr(&amp;quot;href&amp;quot;)
  
  #save the champions league matches into a df
  matches_df &amp;lt;- read %&amp;gt;% 
    html_nodes(&amp;quot;#site &amp;gt; div.white &amp;gt; div.content &amp;gt; div &amp;gt; div.box &amp;gt; div &amp;gt; table&amp;quot;) %&amp;gt;% 
    html_table(fill = TRUE, header = FALSE) %&amp;gt;%
    as.data.frame() %&amp;gt;%
    #rename
    select(date = X1, round = X4, home = X3, away = X5, result = X6) %&amp;gt;%
    #mutate the correct round to matches
    mutate(round = case_when(
      round != &amp;quot;-&amp;quot; ~ round
    )) %&amp;gt;%
    mutate(date = case_when(
      date != &amp;quot;&amp;quot; ~ date
    )) %&amp;gt;%
    mutate(round = zoo::na.locf(round)) %&amp;gt;%
    #filter out valid matches
    filter(grepl(&amp;quot;^[0-9]*:[0-9]*|abor.&amp;quot;, result)) %&amp;gt;%
    mutate(date = zoo::na.locf(date)) %&amp;gt;%
    #few exceptions of matches that wern&amp;#39;t played
    filter(!(grepl(&amp;quot;dec.&amp;quot;, result) &amp;amp; date == &amp;quot;01/12/1965&amp;quot;)) %&amp;gt;%
    filter(!(home == &amp;quot;FK Partizani&amp;quot; &amp;amp; date == &amp;quot;30/09/1987&amp;quot;)) %&amp;gt;%
    mutate(match_link, season, competition)
  return(matches_df)
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Which we can glimpse to see that there are 7206 matches listed across the competition proper and qualification rounds since the 1950s. This resolves down to 2875 unique team-seasons (from ~561 unique teams) who have been involved in either competition.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(match_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##         date    round                   home             away    result
## 1 04/09/1955 1. Round            Sporting CP         Partizan 3:3 (1:1)
## 2 07/09/1955 1. Round Budapesti Vörös Lobogó   RSC Anderlecht 6:3 (3:2)
## 3 08/09/1955 1. Round        Servette Genève      Real Madrid 0:2 (0:0)
## 4 14/09/1955 1. Round        Rot-Weiss Essen     Hibernian FC 0:4 (0:2)
## 5 20/09/1955 1. Round         Djurgårdens IF Gwardia Warszawa 0:0 (0:0)
## 6 21/09/1955 1. Round              Aarhus GF      Stade Reims 0:2 (0:1)
##                                                                    match_link
## 1            /report/champions-league-1955-1956-1-runde-sporting-cp-partizan/
## 2     /report/champions-league-1955-1956-1-runde-mtk-budapest-rsc-anderlecht/
## 3     /report/champions-league-1955-1956-1-runde-servette-geneve-real-madrid/
## 4    /report/champions-league-1955-1956-1-runde-rot-weiss-essen-hibernian-fc/
## 5 /report/champions-league-1955-1956-1-runde-djurgardens-if-gwardia-warszawa/
## 6           /report/champions-league-1955-1956-1-runde-aarhus-gf-stade-reims/
##      season competition
## 1 1955-1956         ucl
## 2 1955-1956         ucl
## 3 1955-1956         ucl
## 4 1955-1956         ucl
## 5 1955-1956         ucl
## 6 1955-1956         ucl&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To work out the distances travelled, we then need to find the locations of each of these matches. The easiest way would be to run through each of those match links and scrape the location data, but that would put a lot of load on the worldfootball servers, so we can be smarter than that.&lt;/p&gt;
&lt;p&gt;Matches generally take place at the home location (or in some exceptions, very close to) of every team (e.g. Arsenal’s home matches take place in North London). However, in the history of the competition, 2-legged matches that ended as a draw used to go to a third leg at a neutral location (for example &lt;a href=&#34;https://www.worldfootball.net/report/champions-league-1992-1993-1-runde-vfb-stuttgart-leeds-united_2/&#34;&gt;Leeds United vs. VFB Stuttgart in 1992 took place at the Nou Camp&lt;/a&gt;). Also, each final is played at a pre-selected venue that is independent of the eventual finalists.&lt;/p&gt;
&lt;p&gt;We can find the data for these matches and scrape the exact location from the match link, while taking the rest from the location of the home team in the tie.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#split data by neutral venue or not
match_locations &amp;lt;- match_data %&amp;gt;%
  split(f = (.$round == &amp;quot;Final&amp;quot; | 
               duplicated(paste(.$home, .$away, .$round, .$season))))

#function for scraping the location of the neutral matches
#uses a link to a specific match
get_neutral_location &amp;lt;- function(link) {
  full_url &amp;lt;- paste0(base_url, link)
  
  #get and munge the location
  node &amp;lt;- &amp;quot;.standard_tabelle tr:nth-child(1) .dunkel~ .dunkel+ .dunkel&amp;quot;
  read &amp;lt;- read_html(full_url)
  location &amp;lt;- read %&amp;gt;% html_nodes(node) %&amp;gt;% html_text() %&amp;gt;%
    gsub(&amp;quot;\\(|\\)|\\/&amp;quot;, &amp;quot;&amp;quot;, .)
  return(location)
}

#run through this function to locate all neutral matches
neutral_matches &amp;lt;- match_locations[[2]] %&amp;gt;%
  mutate(location = unlist(lapply(match_link, get_neutral_location))) %&amp;gt;%
  mutate(type = &amp;quot;neutral&amp;quot;) %&amp;gt;%
  select(-match_link)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can see we’ve gathered a few extra matches that wern’t actually neutral, but given we get their correct location anyway, it’s not big deal.&lt;/p&gt;
&lt;p&gt;We then have to use the information on each team to get the location of thier home ground. For larger teams we can get this to within an exct postcode if we so wish, but many (e.g. &lt;a href=&#34;https://www.worldfootball.net/teams/szombierki-bytom/1/&#34;&gt;former Polish champions Szombierki Bytom&lt;/a&gt;) all we can get from their page is the country. This is fine because we’ll combine this with the team name to use a google search to get more exact locations later. (in any case it’s probably fine because the proportion of teams with poor geographic data probably gets lost in noise overall).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#scrape the information on the teams location from their
#worldfootball profile page
get_team_location &amp;lt;- function(link) {
  read &amp;lt;- read_html(paste0(base_url, link))
  
  stadium_link &amp;lt;- read %&amp;gt;%
    html_nodes(&amp;quot;.yellow tr:nth-child(5) a&amp;quot;) %&amp;gt;%
    html_attr(&amp;quot;href&amp;quot;)
  
  #if the link contains a link to a stadium scrape from there
  if(length(stadium_link) &amp;gt; 0) {
    stadium_link &amp;lt;- paste0(base_url, stadium_link)
    location &amp;lt;- read_html(stadium_link) %&amp;gt;%
      html_nodes(&amp;quot;.yellow tr:nth-child(1) td , .yellow tr:nth-child(2) td&amp;quot;) %&amp;gt;%
      html_text() %&amp;gt;%
      .[c(2,4)] %&amp;gt;%
      gsub(&amp;quot;\\r|\\t|\\n&amp;quot;, &amp;quot;&amp;quot;, .) %&amp;gt;%
      paste0(collapse  = &amp;quot; &amp;quot;)
    return(location)
  #otherwise get a best approximation
  } else {
    country &amp;lt;- read %&amp;gt;%
      html_nodes(&amp;quot;.portfolio tr:nth-child(3) .hell+ .hell&amp;quot;) %&amp;gt;%
      html_text() %&amp;gt;%
      gsub(&amp;quot;\\r|\\t|\\n&amp;quot;, &amp;quot;&amp;quot;, .)
    return(country)
  }
}

#run the function over each team
team_info &amp;lt;- teams %&amp;gt;%
  filter(!duplicated(team_name)) %&amp;gt;%
  mutate(location = unlist(lapply(team_info, get_team_location)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(team_info)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                  competition              team_name
## 1 Champions League 1955/1956      1. FC Saarbrücken
## 2 Champions League 1955/1956              Aarhus GF
## 3 Champions League 1955/1956               AC Milan
## 4 Champions League 1955/1956 Budapesti Vörös Lobogó
## 5 Champions League 1955/1956         Djurgårdens IF
## 6 Champions League 1955/1956       Gwardia Warszawa
##                     team_info            location
## 1 /teams/1-fc-saarbruecken/1/ Saarbrücken Germany
## 2         /teams/aarhus-gf/1/      Aarhus Denmark
## 3          /teams/ac-milan/1/        Milano Italy
## 4      /teams/mtk-budapest/1/    Budapest Hungary
## 5    /teams/djurgardens-if/1/    Stockholm Sweden
## 6  /teams/gwardia-warszawa/1/         Poland 0000&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have a rough location for each team we can join everything back together to get a complete list of matches and where (to a best approximation sometimes) they took place.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#join the team location into the non-neutral matches
nonneutral_matches &amp;lt;- match_locations[[1]] %&amp;gt;%
  left_join(., select(team_info, -competition), by = c(&amp;quot;home&amp;quot; = &amp;quot;team_name&amp;quot;)) %&amp;gt;%
  mutate(type = &amp;quot;normal&amp;quot;) %&amp;gt;%
  select(names(neutral_matches)) 

#join neutral and non neutral matches back together
all_matches &amp;lt;- rbind(neutral_matches, nonneutral_matches) %&amp;gt;%
  mutate(match_location = case_when(
    type == &amp;quot;normal&amp;quot; ~ paste(home, &amp;quot;football club&amp;quot;, location),
    type == &amp;quot;neutral&amp;quot; ~ location
  ))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have the locations for each match, but not in a quantative form. For that, we’ll use the &lt;a href=&#34;https://cran.r-project.org/web/packages/googleway/vignettes/googleway-vignette.html&#34;&gt;googleway&lt;/a&gt; package that provides access to a variety of Google APIs to access the map geolocation feature of Google Mapes. Obviously, I haven’t included my unique key for this below, but you can get one for free using &lt;a href=&#34;https://developers.google.com/maps/documentation/javascript/tutorial&#34;&gt;this link&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;For each location we’ll return a latitude and longitude that will allow us to calculate exactly the distances between a teams home location and each match they played.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#fake key
google_key &amp;lt;- &amp;quot;myGooGLeKEy1234567&amp;quot;

#function to get lat/lon data from Google Maps
googleway_geocode &amp;lt;- function(location, key){
  data &amp;lt;- google_geocode(location, key = key)
  latlon &amp;lt;- data$results$geometry$location[1,]
  
  if(length(latlon) == 0) {
    return(data.frame(lat = NA, lng = NA, location))
  } else {
    return(latlon %&amp;gt;% mutate(location))
  }
}

#run the function over each unique location
locations &amp;lt;- unique(all_matches$match_location) %&amp;gt;%
  map_df(., googleway_geocode, key = google_key)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This gets us 99% of the way there, though the API does miss a few smaller/less well formatted clubs (e.g. Monaco is not ‘in’ France per se, but an enclave in the French territory, which fucks Google Maps up)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;locations %&amp;gt;%
  filter(is.na(lat))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##    lat lng                                           location
## 1   NA  NA              AS Monaco football club Monaco France
## 2   NA  NA St Patrick&amp;#39;s Athletic football club Dublin Ireland
## 3   NA  NA  FK Sloga Jugomagnat football club North Macedonia
## 4   NA  NA        Tsement Ararat football club Ararat Armenia
## 5   NA  NA        NK Brotnjo football club Bosnia-Herzegovina
## 6   NA  NA             Dunaferr SE football club Hungary 0000
## 7   NA  NA          Araks Ararat football club Ararat Armenia
## 8   NA  NA                FK Gomel football club Belarus 1959
## 9   NA  NA                Sioni Bolnisi football club Georgia
## 10  NA  NA                 SS Murata football club San Marino
## 11  NA  NA      KF Shkëndija 79 football club North Macedonia
## 12  NA  NA              SP Tre Penne football club San Marino
## 13  NA  NA                   Ulisses FC football club Armenia
## 14  NA  NA             SP La Fiorita football club San Marino
## 15  NA  NA      Lincoln Red Imps football club Gibraltar 0000
## 16  NA  NA                    Dila Gori football club Georgia
## 17  NA  NA                  KF Trepça&amp;#39;89 football club Kosovo
## 18  NA  NA                  Europa FC football club Gibraltar
## 19  NA  NA                   FK Spartaks football club Latvia
## 20  NA  NA                    FK Kukësi football club Albania&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To solve this, the best way sometimes is just the stupidest, so here are the manually found locations of these clubs&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#manually enter lat lon for the missing locations
missing_locs &amp;lt;- data.frame(
  lat = c(43.73, 53.34, 42.02, 39.86, 43.2, 46.96, 39.86, 52.44, 41.44, 43.93, 42.01, 43.93, 40.17, 43.93, 36.14, 41.98, 42.88, 36.14, 56.94, 42.07),
  lng = c(7.41, -6.27, 21.44, 44.69, 17.7, 18.94, 44.69, 31.01, 44.53, 12.44, 20.97, 12.44, 44.52, 12.44, -5.35, 44.10, 20.86, -5.35, 23.61, 20.42),
  location = locations$location[is.na(locations$lat)]
)

#bind everything together
all_locations &amp;lt;- locations %&amp;gt;%
  filter(!is.na(lat)) %&amp;gt;%
  rbind(., missing_locs) %&amp;gt;%
  #convert to an sf object with worldwide projection
  st_as_sf(coords = c(&amp;quot;lng&amp;quot;, &amp;quot;lat&amp;quot;), crs = st_crs(&amp;quot;+init=epsg:4326&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;At the end, I also cast the object to an &lt;a href=&#34;https://r-spatial.github.io/sf/articles/sf1.html&#34;&gt;simple features&lt;/a&gt; (sf) data.frame to allow for easier manipulation of geographic data and add the reference for Earth’s lat/lon coordinate system (epsg:4326).&lt;/p&gt;
&lt;p&gt;We can then merge the geographic data into our dataframe of every match and see the location of every club to have played in (some stage) of the Champions League over the last ~60 years&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#join in the geographic information
all_matches %&amp;lt;&amp;gt;% left_join(., all_locations, by = c(&amp;quot;match_location&amp;quot; = &amp;quot;location&amp;quot;))

#plot the home locations of all teams
p1 &amp;lt;- all_matches %&amp;gt;%
  filter(type == &amp;quot;normal&amp;quot;) %&amp;gt;%
  filter(!duplicated(home)) %&amp;gt;%
  ggplot(.) +
  geom_sf(data = st_as_sf(ne_countries(scale=110), st_crs(&amp;quot;+init:epsg=4326&amp;quot;)),
          colour = NA) +
  geom_sf_text(aes(label = home, geometry = geometry), alpha = 0.5) +
  #taken from st_bbox(all_matches$geometry)
  coord_sf(xlim = c(-24, 78), ylim = c(30, 67)) +
  ggtitle(&amp;quot;Home location of every Champions League team&amp;quot;,
          subtitle = &amp;quot;1955-2019, includes qualifying rounds&amp;quot;) +
  theme_map()

#plot 
p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-29-ucl_distance_files/figure-html/plot_locations-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It’s quite nice to see the distribution- hubs around large cities with competitive leagues (e.g. Denmark, Czech Republic, The Rhine), with extremes in the north in Iceland/Faroe Islands, to the south in Israel, and the far far East with the Central Asian UEFA countries.&lt;/p&gt;
&lt;p&gt;The first thing to then work out is the matches per team, which can be done via a simple gather. (in theory you’d want to use pivot_long which has deprecated gather but afaik it doesnt play well with geometry data yet). We also mutate in 2 variables for the home and away teams to keep the matches for data presentation purposes.&lt;/p&gt;
&lt;p&gt;Once we have that, we have each match played by each team, each season. A nice little result is we can see which teams have had the longest campaigns (in terms of number of matches), which it turns out are the Valencia and Bayer Leverkusen teams that qualified and got to the finals of the Champions League during the longer two-group-stage format at the turn of the century.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#melt the mach data by team
team_campaigns &amp;lt;- all_matches %&amp;gt;%
  select(season, date, competition, round, home, away, result, geometry) %&amp;gt;%
  #keep the home and away columns for later
  mutate(home_keep = home, away_keep = away) %&amp;gt;%
  gather(&amp;quot;location&amp;quot;, &amp;quot;team_name&amp;quot;,
         -season, -competition, -round, -result, -geometry, -date,
         -home_keep, -away_keep)

#get the longest campaigns in terms of n matches
longest_campaigns &amp;lt;- team_campaigns %&amp;gt;%
  group_by(season, team_name) %&amp;gt;%
  summarise(matches = n()) %&amp;gt;%
  arrange(-matches)

head(longest_campaigns)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 3
## # Groups:   season [4]
##   season    team_name        matches
##   &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;              &amp;lt;int&amp;gt;
## 1 1999-2000 Valencia CF           19
## 2 2000-2001 Valencia CF           19
## 3 2001-2002 Bayer Leverkusen      19
## 4 2002-2003 AC Milan              19
## 5 2000-2001 Leeds United          18
## 6 2001-2002 FC Barcelona          18&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But we want to work out the distance to each match, not the number. To do this, first we want to work backwards and get the lat/lon of each clubs home ground. We can then merge this with the match location data and find the difference between these two locations (in metres). I.e. for every home game, a team will travel 0m to the game, whereas the away club will travel probably many kilometres.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#work backwards and get the home location of each team
team_locations &amp;lt;- all_matches %&amp;gt;%
  filter(type == &amp;quot;normal&amp;quot;) %&amp;gt;%
  filter(!duplicated(home)) %&amp;gt;%
  select(team_name = home, location = match_location) %&amp;gt;%
  left_join(., all_locations, by = &amp;quot;location&amp;quot;)

#merge this in
#for each team match have location of match and home location of team
match_travel &amp;lt;- team_campaigns %&amp;gt;%
  left_join(., select(team_locations, team_name, geometry), by = &amp;quot;team_name&amp;quot;) %&amp;gt;%
  #calculate the distance between each teams home location the match
  mutate(distance = st_distance(geometry.x, geometry.y, by_element = TRUE))

head(match_travel)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##      season       date competition       round             result
## 1 1955-1956 13/06/1956         ucl       Final          4:3 (2:2)
## 2 1956-1957 16/09/1956         ucl    1. Round          7:0 (4:0)
## 3 1956-1957 28/11/1956         ucl Round of 16          3:1 (1:0)
## 4 1956-1957 12/12/1956         ucl Round of 16          2:0 (2:0)
## 5 1956-1957 30/05/1957         ucl       Final          2:0 (0:0)
## 6 1957-1958 15/10/1957         ucl    1. Round 1:1 (0:1, 1:1) aet
##                   geometry.x                 home_keep        away_keep
## 1  POINT (2.253049 48.84144)               Real Madrid      Stade Reims
## 2  POINT (7.453112 51.49276)         Borussia Dortmund  Spora Luxemburg
## 3  POINT (2.253049 48.84144)                  OGC Nice       Rangers FC
## 4 POINT (-3.688344 40.45305)               Real Madrid       Rapid Wien
## 5 POINT (-3.688344 40.45305)               Real Madrid   ACF Fiorentina
## 6  POINT (13.40849 52.54356) SC Wismut Karl-Marx-Stadt Gwardia Warszawa
##   location                 team_name                 geometry.y
## 1     home               Real Madrid POINT (-3.688344 40.45305)
## 2     home         Borussia Dortmund  POINT (7.450945 51.49807)
## 3     home                  OGC Nice  POINT (7.195828 43.68232)
## 4     home               Real Madrid POINT (-3.688344 40.45305)
## 5     home               Real Madrid POINT (-3.688344 40.45305)
## 6     home SC Wismut Karl-Marx-Stadt  POINT (12.69902 50.58733)
##           distance
## 1 1043745.9567 [m]
## 2     609.3633 [m]
## 3  688197.6337 [m]
## 4       0.0000 [m]
## 5       0.0000 [m]
## 6  223136.3518 [m]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then all we need to do is group by each team and season and calculate the total distance travelled by that team. I then printed the top 10 total distances (in km) that team had to travel to complete all of their matches&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;longest_distance_campaigns &amp;lt;- match_travel %&amp;gt;%
  group_by(season, team_name) %&amp;gt;%
  mutate(total_travel = sum(distance), 
         date = as.Date(gsub(&amp;quot;\\/&amp;quot;, &amp;quot;-&amp;quot;, date), &amp;quot;%d-%m-%Y&amp;quot;)) %&amp;gt;%
  select(season, date, competition, round, team = team_name,
         home = home_keep, away = away_keep, result, distance, total_travel) %&amp;gt;%
  arrange(-total_travel, date) 

longest_distance_campaigns %&amp;gt;%
  filter(!duplicated(paste(season, team))) %&amp;gt;%
  select(season, team, total_travel) %&amp;gt;%
  mutate(total_travel = total_travel / 1000) %&amp;gt;%
  head(., n = 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 3
## # Groups:   season, team [10]
##    season    team             total_travel
##    &amp;lt;chr&amp;gt;     &amp;lt;chr&amp;gt;                   &amp;lt;dbl&amp;gt;
##  1 2015-2016 FK Astana              25874.
##  2 2011-2012 APOEL Nikosia          19112.
##  3 2009-2010 APOEL Nikosia          18649.
##  4 2011-2012 SL Benfica             17817.
##  5 2009-2010 Maccabi Haifa          17808.
##  6 2000-2001 Galatasaray            17371.
##  7 2010-2011 Hapoel Tel Aviv        17350.
##  8 2017-2018 Qarabag FK             17286.
##  9 2015-2016 Maccabi Tel Aviv       17041.
## 10 2002-2003 Lokomotiv Moskva       16732.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Perhaps unsurprisingly &lt;a href=&#34;https://en.wikipedia.org/wiki/2015_FC_Astana_season&#34;&gt;FK Astana&lt;/a&gt; from the capital of Kazakhstan come out top (by far), having worked through the qualifying round and making it to the group stages (where they were unbeaten at home). After that, succesful teams from the far corners of Europe (Benfica, APOEL, Hapoel Tel Aviv) come out on top. I was surprised that Lokomotiv are the only Russian team in the list, and as far back as 2002-2003. Also that all of these seasons are from this century (perhaps due to the ever increasing number of fixtures in the Champions League).&lt;/p&gt;
&lt;p&gt;I select the matches FK Astana played in their record-breaking 2015-2016 below:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;longest_distance_campaigns %&amp;gt;%
  filter(season == &amp;quot;2015-2016&amp;quot; &amp;amp; team == &amp;quot;FK Astana&amp;quot;) %&amp;gt;%
  select(-team)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 12 x 10
## # Groups:   season, team [1]
##    team  season date       competition round home  away  result distance
##    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;       [m]
##  1 FK A… 2015-… 2015-07-14 ucl-quals   2. R… NK M… FK A… 1:0 (…  4025459
##  2 FK A… 2015-… 2015-07-22 ucl-quals   2. R… FK A… NK M… 3:1 (…        0
##  3 FK A… 2015-… 2015-07-29 ucl-quals   3. R… HJK … FK A… 0:0 (…  3022119
##  4 FK A… 2015-… 2015-08-05 ucl-quals   3. R… FK A… HJK … 4:3 (…        0
##  5 FK A… 2015-… 2015-08-18 ucl-quals   Play… FK A… APOE… 1:0 (…        0
##  6 FK A… 2015-… 2015-08-26 ucl-quals   Play… APOE… FK A… 1:1 (…  3510897
##  7 FK A… 2015-… 2015-09-15 ucl         Grou… SL B… FK A… 2:0 (…  6180579
##  8 FK A… 2015-… 2015-09-30 ucl         Grou… FK A… Gala… 2:2 (…        0
##  9 FK A… 2015-… 2015-10-21 ucl         Grou… Atlé… FK A… 4:0 (…  5713668
## 10 FK A… 2015-… 2015-11-03 ucl         Grou… FK A… Atlé… 0:0 (…        0
## 11 FK A… 2015-… 2015-11-25 ucl         Grou… FK A… SL B… 2:2 (…        0
## 12 FK A… 2015-… 2015-12-08 ucl         Grou… Gala… FK A… 1:1 (…  3421522
## # … with 1 more variable: total_travel &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, one of the real niche joys in my love is making maps and what better oppurtunity than to map these long distance Champions League campaigns. It’s a bit of a munge to get the lines from point data but sf does at least make it possible.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get the top ten longest campaigns
data &amp;lt;- filter(longest_distance_campaigns,
               !duplicated(paste(season, team)))[1:10,] %&amp;gt;%
  ungroup() %&amp;gt;%
  select(season, team_name = team, total_travel) %&amp;gt;%
  left_join(., match_travel) %&amp;gt;%
  #munge the geometry
  filter(st_geometry(.$geometry.x) != st_geometry(.$geometry.y)) %&amp;gt;%
    mutate(versus = case_when(
        location == &amp;quot;home&amp;quot; ~ away_keep,
        location == &amp;quot;away&amp;quot; ~ home_keep
    )) %&amp;gt;%
    select(season, team_name, versus, round, total_travel,
           geometry.x, geometry.y) %&amp;gt;%
  split(f = rownames(.)) %&amp;gt;%
  #calculate lines from points
  lapply(., function(row) {
    coords1 &amp;lt;- st_coordinates(row$geometry.x) %&amp;gt;%
      split(f = rownames(.))
    coords2 &amp;lt;- st_coordinates(row$geometry.y) %&amp;gt;%
      split(f = rownames(.))
    
    lines &amp;lt;- map2(coords1, coords2, ~st_linestring(rbind(.x, .y)))
    row$lines &amp;lt;- st_as_sfc(lines, crs = st_crs(&amp;quot;+init=epsg:4326&amp;quot;))
    return(row)
  }) %&amp;gt;%
  do.call(rbind, .) %&amp;gt;%
  mutate(title = paste(season, team_name, &amp;quot;=&amp;quot;, round(total_travel/1000), &amp;quot;km&amp;quot;))

#plot the travel of each team
p2 &amp;lt;- ggplot() +
  geom_sf(data = st_as_sf(ne_countries(scale=110), st_crs(&amp;quot;+init:epsg=4326&amp;quot;)), 
          colour = NA) +
  geom_sf(data = data, aes(geometry = lines),
          colour = &amp;quot;red&amp;quot;, size = 2) +
  geom_sf_text(data = data, aes(geometry = geometry.x, label = versus),
               size = 4, nudge_y = 2) +
  #again taken from st_bbox
  coord_sf(xlim = c(-23, 77), ylim = c(66, 30)) +
  theme_map() +
  theme(
    strip.background = element_rect(fill = &amp;quot;white&amp;quot;),
    strip.text = element_text(size = 10)
  ) +
  facet_wrap(~title)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&#34;https://www.robert-hickman.eu/img/longest_distances_plot.svg&#34; title=&#34;plot of the longest UCL campaigns&#34;&gt;&lt;img src=&#34;/img/longest_distance_campaigns.png&#34; alt=&#34;plot of the longest UCL campaigns&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Click on the image for a higher-res version :)&lt;/p&gt;
&lt;p&gt;Two quick finishing pieces:&lt;/p&gt;
&lt;p&gt;Firstly, what is the single longest journey in the history of the Champions League? Unsurprisingly it involves the 2015-2016 FK Astana season travelling to Benfica on the coast of Portugal (and of course the return fixture).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;match_travel[which.max(match_travel$distance),]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##          season       date competition   round    result
## 12000 2015-2016 15/09/2015         ucl Group C 2:0 (0:0)
##                       geometry.x  home_keep away_keep location team_name
## 12000 POINT (-9.184503 38.75253) SL Benfica FK Astana     away FK Astana
##                      geometry.y    distance
## 12000 POINT (71.40261 51.10822) 6180579 [m]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And secondly, answering the original question- what the shortest average commute for a winning side?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get UCL champions
winners &amp;lt;- match_travel %&amp;gt;%
  filter(round == &amp;quot;Final&amp;quot;) %&amp;gt;%
  mutate(result = gsub(&amp;quot; .*&amp;quot;, &amp;quot;&amp;quot;, result)) %&amp;gt;%
  separate(result, into = c(&amp;quot;h_goal&amp;quot;, &amp;quot;a_goal&amp;quot;), sep = &amp;quot;:&amp;quot;) %&amp;gt;%
  filter((location == &amp;quot;home&amp;quot; &amp;amp; h_goal &amp;gt; a_goal) | (location == &amp;quot;away&amp;quot; &amp;amp; a_goal &amp;gt; h_goal)) %&amp;gt;%
  select(season, team_name)

#find the matches played by champions
winners_matches &amp;lt;- left_join(winners, match_travel, by = c(&amp;quot;season&amp;quot;, &amp;quot;team_name&amp;quot;)) %&amp;gt;%
  group_by(season, team_name) %&amp;gt;%
  mutate(matches = n(), total_travel = sum(distance/1000)) %&amp;gt;%
  ungroup() %&amp;gt;%
  #calculate average travel per game
  mutate(average_travel = total_travel / matches,
         date = as.Date(gsub(&amp;quot;\\/&amp;quot;, &amp;quot;-&amp;quot;, date), &amp;quot;%d-%m-%Y&amp;quot;)) %&amp;gt;%
  select(season, date, round, home = home_keep, away = away_keep, result, distance, average_travel) %&amp;gt;%
  arrange(average_travel, date)

#print the 3 campaigns with the lowest average travel
head(winners_matches, n = 27)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 8
##    season  date       round   home    away   result distance average_travel
##    &amp;lt;chr&amp;gt;   &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;  &amp;lt;chr&amp;gt;       [m]          &amp;lt;dbl&amp;gt;
##  1 1963-1… 1963-09-18 1. Rou… Everto… Inter  0:0 (… 1247112…           410.
##  2 1963-1… 1963-09-25 1. Rou… Inter   Evert… 1:0 (…       0…           410.
##  3 1963-1… 1963-11-27 Round … Inter   AS Mo… 1:0 (…       0…           410.
##  4 1963-1… 1963-12-04 Round … AS Mon… Inter  1:3 (…  236127…           410.
##  5 1963-1… 1964-02-26 Quarte… Partiz… Inter  0:2 (…  891298…           410.
##  6 1963-1… 1964-03-04 Quarte… Inter   Parti… 2:1 (…       0…           410.
##  7 1963-1… 1964-04-15 Semi-f… Boruss… Inter  2:2 (…  684493…           410.
##  8 1963-1… 1964-04-29 Semi-f… Inter   Borus… 2:0 (…       0…           410.
##  9 1963-1… 1964-05-27 Final   Inter   Real … 3:1 (…  632859…           410.
## 10 1971-1… 1971-09-15 1. Rou… AFC Aj… Dynam… 2:0 (…       0…           433.
## # … with 17 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where the top three are Inter’s 1963-1964, Ajax’s 1971-1972, and Bayern Munich’s 1973-1974 seasons all of which have an average travel of just over 400km per game. It’s fairly striking how many more Central European teams there are further in the competitions in these seasons comapred to today.&lt;/p&gt;
&lt;p&gt;And that’s all for now! Thanks for reading and I’ll try and put out another post soon :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Five Minute Football Trivia - Birthday Five-A-Side</title>
      <link>/post/five_min_trivia_birthdays/</link>
      <pubDate>Sat, 14 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/five_min_trivia_birthdays/</guid>
      <description>


&lt;p&gt;&lt;em&gt;generally as I have less and less time to waste on meaningless football stats I get halfway through a post and abandon it. To remedy this, I want to start pushing out posts that give a reasonable half-guess at an answer within an hour or so without needing to really check my working or write good prose. This is the second of these&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;A semi-common question I’ve come across when doing stupid football trivia is ‘Which Birthday could field the best 5-a-side team?’. That is, if you could only select 5 players all born on the same date, which date would you pick in order to allow for the strongest team. For an example, see &lt;a href=&#34;https://www.theguardian.com/football/2014/feb/19/best-team-players-born-same-day&#34;&gt;the Guardian’s knowledge blog&lt;/a&gt; from 2014. However, this was based on gut feel of the team, and this blog (however flawed) deals in data, so let’s go.&lt;/p&gt;
&lt;p&gt;As always, we’ll start by loading some libraries&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#munging
library(tidyverse)
#regression (later)
library(glmnet)
#plots (at the end)
library(ggsoccer)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll then load our data to compare players’ ability. For this I’m using a database I put together of every character in the FIFA database I scraped from &lt;a href=&#34;https://www.fifaindex.com/&#34;&gt;FIFAindex.com&lt;/a&gt;. The database goes back 15 years to the ‘05’ version of the game so we won’t have to limit ourselves to current players. The scraped db can be found at &lt;a href=&#34;https://github.com/RobWHickman/fifadb&#34;&gt;my github&lt;/a&gt;*&lt;/p&gt;
&lt;p&gt;*it’s still very beta version at the moment and needs a lot more munging but should work for most applications&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;player_data &amp;lt;- map_df(
  #load female and male player data from the github repo
  c(&amp;quot;male_players.rds&amp;quot;), function(x) {
    data &amp;lt;- readRDS(paste0(&amp;quot;path/to/file/&amp;quot;, x)) %&amp;gt;%
      mutate(version = as.character(version), dob = as.Date(dob, &amp;quot;%Y-%B-%D&amp;quot;))
    return(data)
}) %&amp;gt;%
  #munge date of birth in day and month of birth (don&amp;#39;t care about year)
  mutate(day_of_birth = gsub(&amp;quot;^[0-9]{4}-&amp;quot;, &amp;quot;&amp;quot;, dob)) %&amp;gt;%
  separate(day_of_birth, into = c(&amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;), sep = &amp;quot;-&amp;quot;, remove = FALSE) %&amp;gt;%
  mutate(month = as.numeric(month), day = as.numeric(day), ability = as.numeric(ability))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This should give us a 145536 observation df for 65 variables (!). I.e. the information on, and stats of, every character to appear over the last decade and half. We can then look at the spread of birthdays in the dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plot the numbers of players per day of birth in the dataset
p1 &amp;lt;- ggplot(player_data, aes(x = day, fill = factor(month))) +
  geom_histogram(stat = &amp;quot;count&amp;quot;) +
  scale_fill_discrete(guide = FALSE) +
  labs(title = &amp;quot;Number of players sharing birthday by day of year&amp;quot;,
       x = &amp;quot;day of month&amp;quot;) +
  facet_wrap(~month) +
  theme_minimal()

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-14-birthdays_files/figure-html/plot_birthdays-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Two peaks that pop out are the massive spike on February 29th and the smaller one of January 1st. On inspection, it looks like these are used as placeholders when true date of birth isn’t known. FOr the reaminer of the post we’re going to exclude them&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#filter out 1st January and 29th February (placeholders for unknown dob?)
player_data &amp;lt;- filter(player_data,
                      !(day == 1 &amp;amp; month == 1) &amp;amp; !(day == 29 &amp;amp; month == 2))

#replot
p2 &amp;lt;- player_data %&amp;gt;%
  ggplot(., aes(x = day, fill = factor(month))) +
  geom_histogram(stat = &amp;quot;count&amp;quot;) +
  scale_fill_discrete(guide = FALSE) +
  labs(title = &amp;quot;Number of players sharing birthday by day of year&amp;quot;,
       subtitle = &amp;quot;placeholder dates removed&amp;quot;,
       x = &amp;quot;day of month&amp;quot;) +
  facet_wrap(~month) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-14-birthdays_files/figure-html/plot_birthdays2-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Then we can put teams together by taking the top 5 players by the ‘overall ability’ stat for each date of birth:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;by_day &amp;lt;- player_data %&amp;gt;%
  #take only relevant data
  select(name = name2, ability, day, month, version) %&amp;gt;%
  arrange(-ability) %&amp;gt;%
  #group by day and take each players best ability score
  group_by(day, month) %&amp;gt;%
  filter(!duplicated(name)) %&amp;gt;%
  #get the top five by day
  split(f = paste(.$day, .$month)) %&amp;gt;%
  map(., function(dat) dat[1:5,] %&amp;gt;% mutate(team_ability = sum(ability)))

#glimpse the first two teams (1/10 and 1/11)
by_day[1:2]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $`1 10`
## # A tibble: 5 x 6
## # Groups:   day, month [1]
##   name           ability   day month version team_ability
##   &amp;lt;chr&amp;gt;            &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 Anthony Lopes       85     1    10 19               418
## 2 Mirko Vucinic       84     1    10 07               418
## 3 Julio Baptista      83     1    10 05               418
## 4 Vitor Baía          83     1    10 06               418
## 5 Ümit Karan          83     1    10 07               418
## 
## $`1 11`
## # A tibble: 5 x 6
## # Groups:   day, month [1]
##   name                  ability   day month version team_ability
##   &amp;lt;chr&amp;gt;                   &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 Miloš Krasic               83     1    11 11               403
## 2 Filip Kostic               82     1    11 20               403
## 3 Mahler Tressor Moreno      80     1    11 06               403
## 4 Vaclav Sverkos             79     1    11 06               403
## 5 Dimo Wache                 79     1    11 07               403&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then to find the best 5 of these teams, we can push it through two quick functions as follows:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get the top 5 teams by summed ability
top_teams &amp;lt;- by_day %&amp;gt;%
  #sum the ability per team
  map_dbl(., function(dat) return(unique(dat$team_ability))) %&amp;gt;%
  sort() %&amp;gt;%
  #return the top n teams
  tail(n = 5) %&amp;gt;%
  names(.) %&amp;gt;%
  map(., function(date) return(by_day[date]))

top_teams&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
## [[1]]$`7 10`
## # A tibble: 5 x 6
## # Groups:   day, month [1]
##   name                   ability   day month version team_ability
##   &amp;lt;chr&amp;gt;                    &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 Dida                        91     7    10 06               436
## 2 Gilberto                    89     7    10 05               436
## 3 Sami Hyypiä                 86     7    10 05               436
## 4 Diego Costa                 86     7    10 17               436
## 5 Santiago Hernán Solari      84     7    10 05               436
## 
## 
## [[2]]
## [[2]]$`17 8`
## # A tibble: 5 x 6
## # Groups:   day, month [1]
##   name           ability   day month version team_ability
##   &amp;lt;chr&amp;gt;            &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 Thierry Henry       97    17     8 05               437
## 2 Ederson             88    17     8 20               437
## 3 William Gallas      87    17     8 05               437
## 4 Güiza               83    17     8 09               437
## 5 Phil Jagielka       82    17     8 10               437
## 
## 
## [[3]]
## [[3]]$`22 9`
## # A tibble: 5 x 6
## # Groups:   day, month [1]
##   name                 ability   day month version team_ability
##   &amp;lt;chr&amp;gt;                  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 Ronaldo                   94    22     9 06               437
## 2 Thiago Silva              89    22     9 17               437
## 3 Harry Kewell              86    22     9 05               437
## 4 Javier López Vallejo      84    22     9 06               437
## 5 Maarten Stekelenburg      84    22     9 12               437
## 
## 
## [[4]]
## [[4]]$`24 6`
## # A tibble: 5 x 6
## # Groups:   day, month [1]
##   name                ability   day month version team_ability
##   &amp;lt;chr&amp;gt;                 &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 Lionel Messi             94    24     6 12               439
## 2 Juan Román Riquelme      88    24     6 07               439
## 3 Luis García              86    24     6 06               439
## 4 David Alaba              86    24     6 17               439
## 5 Shunsuke Nakamura        85    24     6 08               439
## 
## 
## [[5]]
## [[5]]$`5 2`
## # A tibble: 5 x 6
## # Groups:   day, month [1]
##   name                     ability   day month version team_ability
##   &amp;lt;chr&amp;gt;                      &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;          &amp;lt;dbl&amp;gt;
## 1 Cristiano Ronaldo             94     5     2 17               439
## 2 Neymar Jr                     92     5     2 17               439
## 3 Carlos Tévez                  87     5     2 06               439
## 4 Stefan de Vrij                84     5     2 18               439
## 5 Giovanni Van Bronckhorst      82     5     2 05               439&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So our top team is comprised of &lt;a href=&#34;https://en.wikipedia.org/wiki/Carli_Lloyd&#34;&gt;2017 Carli Lloyd&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Vicente_Rodr%C3%ADguez&#34;&gt;2005 Vincente&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Gareth_Bale&#34;&gt;2017 Gareth Bale&lt;/a&gt;, &lt;a href=&#34;https://en.wikipedia.org/wiki/Sergio_Busquets&#34;&gt;2019 Sergio Busquets&lt;/a&gt;, and &lt;a href=&#34;https://en.wikipedia.org/wiki/Mousa_Demb%C3%A9l%C3%A9_(Belgian_footballer)&#34;&gt;2018 Moussa Dembele&lt;/a&gt;, all of whom were born on July 16th.&lt;/p&gt;
&lt;p&gt;However, it’s pretty clear this isn’t a very satisfactory answer; the best team here has 5 midfielders. To get a little deeper, we need to bust out a bit of machine learning. First we want to see what are all the positions in the dataset:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#take the primary position for each player
unique(as.character(sapply(player_data$positions, &amp;quot;[[&amp;quot;, 1)))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;ST&amp;quot;   &amp;quot;GK&amp;quot;   &amp;quot;CAM&amp;quot;  &amp;quot;CDM&amp;quot;  &amp;quot;CB&amp;quot;   &amp;quot;LCAM&amp;quot; &amp;quot;CM&amp;quot;   &amp;quot;LM&amp;quot;   &amp;quot;CF&amp;quot;   &amp;quot;LWM&amp;quot; 
## [11] &amp;quot;RM&amp;quot;   &amp;quot;RB&amp;quot;   &amp;quot;RWB&amp;quot;  &amp;quot;RWM&amp;quot;  &amp;quot;LB&amp;quot;   &amp;quot;LCB&amp;quot;  &amp;quot;LS&amp;quot;   &amp;quot;LF&amp;quot;   &amp;quot;RCB&amp;quot;  &amp;quot;LAM&amp;quot; 
## [21] &amp;quot;LWB&amp;quot;  &amp;quot;LCDM&amp;quot; &amp;quot;RS&amp;quot;   &amp;quot;LCM&amp;quot;  &amp;quot;RAM&amp;quot;  &amp;quot;RCM&amp;quot;  &amp;quot;RF&amp;quot;   &amp;quot;SW&amp;quot;   &amp;quot;RCDM&amp;quot; &amp;quot;RCAM&amp;quot;
## [31] &amp;quot;LDM&amp;quot;  &amp;quot;RDM&amp;quot;  &amp;quot;RW&amp;quot;   &amp;quot;LW&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So a fair few, but a lot of these (e.g. RW and LW) are basically the same position, just played of the opposite side of the pitch. We’d expect a left winger to &lt;em&gt;mostly&lt;/em&gt; have the same skills as a right winger.&lt;/p&gt;
&lt;p&gt;To fix this we can make these positions ‘symmetric’ by replacin the left/right with a W (for wide):&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#add in the symmetric position column
player_data$position &amp;lt;- sapply(player_data$positions, &amp;quot;[[&amp;quot;, 1)
player_data &amp;lt;- player_data %&amp;gt;%
  mutate(symmetric_position = gsub(&amp;quot;L|R&amp;quot;, &amp;quot;W&amp;quot;, position))

unique(player_data$symmetric_position)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;ST&amp;quot;   &amp;quot;GK&amp;quot;   &amp;quot;CAM&amp;quot;  &amp;quot;CDM&amp;quot;  &amp;quot;CB&amp;quot;   &amp;quot;WCAM&amp;quot; &amp;quot;CM&amp;quot;   &amp;quot;WM&amp;quot;   &amp;quot;CF&amp;quot;   &amp;quot;WWM&amp;quot; 
## [11] &amp;quot;WB&amp;quot;   &amp;quot;WWB&amp;quot;  &amp;quot;WCB&amp;quot;  &amp;quot;WS&amp;quot;   &amp;quot;WF&amp;quot;   &amp;quot;WAM&amp;quot;  &amp;quot;WCDM&amp;quot; &amp;quot;WCM&amp;quot;  &amp;quot;SW&amp;quot;   &amp;quot;WDM&amp;quot; 
## [21] &amp;quot;WW&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We then want to use the attributes for each player at various skills (e.g. Shot Power, Ball Control, GK Rushing [out], Free Kicks,…) to work out how they interact with the palyer’s chosen position to create their overall ability score in the game.&lt;/p&gt;
&lt;p&gt;For example, in &lt;a href=&#34;https://www.fifaindex.com/player/158023/lionel-messi/fifa20/&#34;&gt;FIFA 2020, Lionel Messi&lt;/a&gt; has rather poor defensive stats (e.g. only 26/100 for sliding tackles). Any reasonable person would reognise that sliding tackles just &lt;em&gt;aren’t important&lt;/em&gt; for Lionel Messi’s role in the Barcelona team. However, we can use these stats to work out what his overall ability would be &lt;em&gt;if he were a defender&lt;/em&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#attribute variables we&amp;#39;ll need to use to work out player position ability
attribute_vars &amp;lt;- grep(&amp;quot;Ball_Control&amp;quot;, names(player_data)):
  grep(&amp;quot;GK_Rushing&amp;quot;, names(player_data))

names(player_data)[attribute_vars]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] &amp;quot;Ball_Control&amp;quot;       &amp;quot;Dribbling&amp;quot;          &amp;quot;Marking&amp;quot;           
##  [4] &amp;quot;Slide_Tackle&amp;quot;       &amp;quot;Stand_Tackle&amp;quot;       &amp;quot;Aggression&amp;quot;        
##  [7] &amp;quot;Reactions&amp;quot;          &amp;quot;Attack_Positioning&amp;quot; &amp;quot;Interceptions&amp;quot;     
## [10] &amp;quot;Vision&amp;quot;             &amp;quot;Crossing&amp;quot;           &amp;quot;Short_Pass&amp;quot;        
## [13] &amp;quot;Long_Pass&amp;quot;          &amp;quot;Acceleration&amp;quot;       &amp;quot;Stamina&amp;quot;           
## [16] &amp;quot;Strength&amp;quot;           &amp;quot;Balance&amp;quot;            &amp;quot;Sprint_Speed&amp;quot;      
## [19] &amp;quot;Agility&amp;quot;            &amp;quot;Jumping&amp;quot;            &amp;quot;Heading&amp;quot;           
## [22] &amp;quot;Shot_Power&amp;quot;         &amp;quot;Long_Shots&amp;quot;         &amp;quot;Finishing&amp;quot;         
## [25] &amp;quot;FK_Accuracy&amp;quot;        &amp;quot;Curve&amp;quot;              &amp;quot;Penalties&amp;quot;         
## [28] &amp;quot;Volleys&amp;quot;            &amp;quot;GK_Reflexes&amp;quot;        &amp;quot;GK_Handling&amp;quot;       
## [31] &amp;quot;GK_Positioning&amp;quot;     &amp;quot;GK_Diving&amp;quot;          &amp;quot;GK_Kicking&amp;quot;        
## [34] &amp;quot;Tackling&amp;quot;           &amp;quot;Anticipation&amp;quot;       &amp;quot;Composure&amp;quot;         
## [37] &amp;quot;Creativity&amp;quot;         &amp;quot;Passing&amp;quot;            &amp;quot;Long_Balls&amp;quot;        
## [40] &amp;quot;Pace&amp;quot;               &amp;quot;Shot_Accuracy&amp;quot;      &amp;quot;GK_Rushing&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll then run a &lt;a href=&#34;https://www.statisticshowto.datasciencecentral.com/lasso-regression/&#34;&gt;LASSO regression&lt;/a&gt; to calculate exactly how important each of these variables are to players of each position, and then use these weights to calculate the hypothetical ability of players in positions they would never play. For some more explanation, a lot of this is taken from some old blog posts &lt;a href=&#34;https://www.robert-hickman.eu/post/yorkshire_world_cup_2/&#34;&gt;here&lt;/a&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to do the lasso regression
get_player_position_abilities &amp;lt;- function(model_pos, model_vers) {
  #id players by their link to fifaindex
  ids &amp;lt;- player_data$player_link[player_data$version == model_vers]
  
  #train on players who play each position
  train_data &amp;lt;- player_data %&amp;gt;%
    filter(symmetric_position == model_pos &amp;amp; version == model_vers) %&amp;gt;%
    select(&amp;quot;ability&amp;quot;, attribute_vars) %&amp;gt;%
    mutate(ability = as.numeric(ability)) %&amp;gt;%
    #some variables aren&amp;#39;t in all versions of FIFA
    #get rid of any that are all NA
    purrr::discard(~all(is.na(.)))
  #if no examples of this position for a version of FIFA, return NULL
  if(length(train_data) == 0) return(NULL)
  #convert to a matrix and train the regression
  train_matrix &amp;lt;- model.matrix(ability~., train_data)
  cv_model &amp;lt;- cv.glmnet(train_matrix, train_data$ability)
  
  #use these weights on every player from that version of FIFA
  test_data &amp;lt;- player_data %&amp;gt;%
    filter(version == model_vers) %&amp;gt;%
    select(&amp;quot;ability&amp;quot;, attribute_vars) %&amp;gt;%
    mutate(ability = as.numeric(ability)) %&amp;gt;%
    purrr::discard(~all(is.na(.)))
  #calculate the ability score for each player for that position
  test_matrix &amp;lt;- model.matrix(ability~., test_data)
  position_ability &amp;lt;- predict(cv_model, newx = test_matrix, s = &amp;quot;lambda.min&amp;quot;, type=&amp;quot;response&amp;quot;)
  
  #return the positional scores
  df &amp;lt;- data.frame(
    player_link = ids,
    ability = as.numeric(position_ability),
    version = model_vers,
    position = model_pos
  )
  return(df)
}

#get all combinations of position and FIFA version
crossed_vars &amp;lt;- crossing(
  pos = unique(player_data$symmetric_position), 
  vers = unique(player_data$version)
)

#get all players ability in every position
position_abilities &amp;lt;- map2_df(crossed_vars$pos, crossed_vars$vers, get_player_position_abilities) %&amp;gt;%
  left_join(select(player_data, name = name2, day, month, player_link), by = &amp;quot;player_link&amp;quot;) %&amp;gt;%
  pivot_wider(names_from = position, values_from = ability) %&amp;gt;%
  select(-player_link)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So once we’ve run that we can see how each player is expected to perform in any position. For instance, if we take the first three players in the dataset we can see how Thierry Henry&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;head(position_abilities, n = 3)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 3 x 25
##   version name    day month   CAM    CB   CDM    CF    CM    GK    ST    SW
##   &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1 05      Thie…    17     8  88.8  53.1  70.9  96.5  76.4  24.2  96.5  55.2
## 2 05      Gian…    28     1  34.3  39.5  34.7  39.0  34.3  96.3  39.2  34.5
## 3 05      Zine…    23     6  96.1  72.1  86.8  93.9  91.1  26.7  93.9  75.2
## # … with 13 more variables: WAM &amp;lt;dbl&amp;gt;, WB &amp;lt;dbl&amp;gt;, WCAM &amp;lt;dbl&amp;gt;, WCB &amp;lt;dbl&amp;gt;,
## #   WCDM &amp;lt;dbl&amp;gt;, WCM &amp;lt;dbl&amp;gt;, WDM &amp;lt;dbl&amp;gt;, WF &amp;lt;dbl&amp;gt;, WM &amp;lt;dbl&amp;gt;, WS &amp;lt;dbl&amp;gt;,
## #   WW &amp;lt;dbl&amp;gt;, WWB &amp;lt;dbl&amp;gt;, WWM &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also plot the relative abilities of each player to see if they make sense. In the below I’ve excluded the names of each playey on the y axis to save space, but every slither is a separate player:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p3 &amp;lt;- position_abilities %&amp;gt;%
  #arrange ordering
  arrange(-ST) %&amp;gt;%
  filter(!duplicated(name)) %&amp;gt;%
  mutate(name = factor(name, levels = unique(name),)) %&amp;gt;%
  select(name, 5:ncol(.)) %&amp;gt;%
  #melt data
  pivot_longer(cols = c(2:ncol(.)), names_to = &amp;quot;position&amp;quot;, values_to = &amp;quot;ability&amp;quot;) %&amp;gt;%
  arrange(name, -ability) %&amp;gt;%
  mutate(position = factor(position, levels = unique(position))) %&amp;gt;%
  ggplot(aes(y = name, x = position)) +
  geom_tile(aes(fill = ability)) +
  labs(title = &amp;quot;Relative abilities of all players in all positions&amp;quot;,
       x = &amp;quot;position&amp;quot;,
       y = &amp;quot;player&amp;quot;) +
  theme_minimal() +
  #get rid of y axis text
  theme(axis.text.y = element_blank()) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-14-birthdays_files/figure-html/plot_position_abilities-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And it’s clear that players that excel in the attacking positions towards the left are weaker at the defensive positions towards the right (also not the big section of dark blue for weakness in the goalkeepers column).&lt;/p&gt;
&lt;p&gt;In building a 5-a-side team, I’m going to assume you want at least one defencer, one midfielder, one attacker, one goalkeeper, and then one extra outfield player in whatever position. It’s important to note that this not have to be ‘player traditionally thought of as a defender’, a particularly skilled striker could very well take up the defensive space if they had the requisite abilities.&lt;/p&gt;
&lt;p&gt;To do this, we have to bin the positions into attack/defense and then find the highest value for each for every player&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;gk_cols &amp;lt;- c(&amp;quot;GK&amp;quot;)
def_cols &amp;lt;- c(&amp;quot;CB&amp;quot;, &amp;quot;SW&amp;quot;, &amp;quot;WCB&amp;quot;, &amp;quot;CDM&amp;quot;, &amp;quot;WCDM&amp;quot;, &amp;quot;WDM&amp;quot;)
mid_cols &amp;lt;- c(&amp;quot;CM&amp;quot;, &amp;quot;WCM&amp;quot;, &amp;quot;CAM&amp;quot;, &amp;quot;WCAM&amp;quot;, &amp;quot;WM&amp;quot;, &amp;quot;WWM&amp;quot;, &amp;quot;WB&amp;quot;, &amp;quot;WWB&amp;quot;)
attack_cols &amp;lt;- c(&amp;quot;CF&amp;quot;, &amp;quot;WF&amp;quot;, &amp;quot;ST&amp;quot;, &amp;quot;WS&amp;quot;, &amp;quot;WAM&amp;quot;, &amp;quot;WW&amp;quot;)

#find the best defensive/attack position for each player
fiveaside_abilities &amp;lt;- map(list(gk_cols, def_cols, mid_cols, attack_cols),
               function(cols) position_abilities %&amp;gt;% select(cols) %&amp;gt;% apply(., 1, max, na.rm = TRUE)) %&amp;gt;%
  do.call(cbind, .) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  #bind this back to the original data
  cbind(position_abilities, .) %&amp;gt;%
  #select the necessary columns
  select(name, version, gk = V1, def = V2, mid = V3, att = V4, day, month)

head(fiveaside_abilities)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                  name version       gk      def      mid      att day
## 1       Thierry Henry      05 24.24627 70.91822 88.87479 96.60456  17
## 2    Gianluigi Buffon      05 96.29510 40.01513 39.58011 39.76021  28
## 3     Zinedine Zidane      05 26.66050 86.77503 96.06867 96.11257  23
## 4 Ruud van Nistelrooy      05 22.75526 75.99536 86.59128 94.70145   1
## 5          Roy Makaay      05 23.52925 65.63241 78.20789 93.82865   9
## 6       Iker Casillas      05 94.11531 54.33178 45.29751 51.61508  20
##   month
## 1     8
## 2     1
## 3     6
## 4     7
## 5     3
## 6     5&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have the player abilities, combining them into a team is not quite trivial, but not far off&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#melt data back down for team selection
team_selection_dat &amp;lt;- fiveaside_abilities %&amp;gt;%
  pivot_longer(cols = names(fiveaside_abilities)[3:6],
               names_to = &amp;quot;pos&amp;quot;, values_to = &amp;quot;ability&amp;quot;)

#fun on a function to select optimal five a side teams
best_teams &amp;lt;- 
  #run for each date we want to select for
  map_df(unique(paste(team_selection_dat$day, team_selection_dat$month, sep = &amp;quot;-&amp;quot;)), 
         function(select_dob, data) {
           #filter only players with that birth date
           bday_dat &amp;lt;- data %&amp;gt;%
             mutate(dob = paste(day, month, sep = &amp;quot;-&amp;quot;)) %&amp;gt;%
             filter(dob == select_dob) %&amp;gt;%
             arrange(-ability)
           
           #take positions in order of highest ability score
           #in order to pick optimally
           position_order &amp;lt;- unique(bday_dat$pos)
           
           #init a data frame
           team &amp;lt;- data.frame(
             name = NULL,
             version = NULL,
             day = NULL,
             month = NULL,
             pos = NULL,
             ability = NULL
           )
           
           #for loop through the positions to be picked
           #probably a better way to write this but
           #by now my brain was melting
           for(position in position_order) {
             #select the best player for that position
             selected_player &amp;lt;- bday_dat %&amp;gt;%
               filter(pos == position) %&amp;gt;%
               top_n(1, ability) %&amp;gt;%
               select(-dob)
             team &amp;lt;- rbind(team, selected_player)
             
             #remove selected player from later choices
             bday_dat &amp;lt;- bday_dat %&amp;gt;%
               filter(!name %in% team$name)
           }
           
           #pick the last last player
           team &amp;lt;- bday_dat %&amp;gt;%
             filter(pos != &amp;quot;gk&amp;quot;) %&amp;gt;%
             top_n(1, ability) %&amp;gt;%
             select(-dob) %&amp;gt;%
             rbind(team, .)
           
           return(team)
  }, data = team_selection_dat)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then plot the best teams by taking the mean of each teams positional ability and finding the top 10 teams. I then plotted these on half pitches using Ben Torvaney’s (mentoned in 2/2 posts so far…) &lt;a href=&#34;https://github.com/Torvaney/ggsoccer&#34;&gt;ggsoccer&lt;/a&gt; package:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p4 &amp;lt;- best_teams %&amp;gt;%
  #work out total ability by team
  group_by(day, month) %&amp;gt;%
  mutate(team_ability = mean(ability)) %&amp;gt;%
  group_by(day, month, pos) %&amp;gt;%
  mutate(total_pos = n(), pos_n = 1:n()) %&amp;gt;%
  #calculate the x and y coordinates for each player on a pitch
  mutate(x = case_when(
    pos == &amp;quot;gk&amp;quot; ~ 5,
    pos == &amp;quot;def&amp;quot; ~ 22,
    pos == &amp;quot;mid&amp;quot; ~ 35,
    pos == &amp;quot;att&amp;quot; ~ 52
  )) %&amp;gt;%
  mutate(y = case_when(
    pos_n == 1 &amp;amp; total_pos == 2 ~ 20,
    pos_n == 2 ~ 60,
    TRUE ~ 40
  )) %&amp;gt;%
  ungroup() %&amp;gt;%
  select(-pos_n, -total_pos) %&amp;gt;%
  #take the 10 best teams
  top_n(50, team_ability) %&amp;gt;%
  #add in a column for the faceting
  mutate(dob = paste0(day, &amp;quot;/&amp;quot;, month, &amp;quot;: &amp;quot;, round(team_ability, 2))) %&amp;gt;%
  ggplot(aes(x = x, y = y)) +
  annotate_pitch(dimensions = pitch_statsbomb,
                 colour = &amp;quot;black&amp;quot;,
                 fill   = &amp;quot;white&amp;quot;,
                 limits = FALSE) +
  coord_flip(xlim = c(0, 60)) +
  geom_text(aes(
    label = gsub(&amp;quot;( )([A-Z])&amp;quot;, &amp;quot;\n\\2&amp;quot;, paste(name, version, sep = &amp;quot;-&amp;quot;)),
    colour = ability), size = 5.5) +
  scale_colour_gradient(low = &amp;quot;darkblue&amp;quot;, high = &amp;quot;red&amp;quot;, name = &amp;quot;player\n ability&amp;quot;) +
  labs(title = &amp;quot;Ten Best Birthday Teams&amp;quot;) +
  theme_pitch() +
  theme(strip.text.x = element_text(size = 14)) +
  facet_wrap(~dob) &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/img/birthday_teams.svg&#34; /&gt;&lt;/p&gt;
&lt;p&gt;All the top 10 teams have fairly similar total abilities- around 86-87. These best of which is an average of 87.51 for a team of
- 2006 Dida (GK)
- 2005 Sami Hyypia (Def)
- 2005 Gilberto Silva (Mid)
- 2005 Santiago Solari (Att)
- 2017 Diego Costa (Att)&lt;/p&gt;
&lt;p&gt;who all share a birthday on the 7th October. Many of the top teams we found earlier also show up, though surprisingly the 1st November which has players such as Neymar Jr., Christiano Ronaldo, Carlos Tevez, and Stefan De Vrij, doesn’t make the cut.&lt;/p&gt;
&lt;p&gt;That’s all for the second of these posts. The first one can be found &lt;a href=&#34;https://www.robert-hickman.eu/post/five_min_trivia_invincibles/&#34;&gt;here&lt;/a&gt;. Hopefully it provides some relief from the madness that is a complete lack of football. Stay safe, and wash your hands.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Five Minute Football Trivia - Invincibles</title>
      <link>/post/five_min_trivia_invincibles/</link>
      <pubDate>Sat, 07 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>/post/five_min_trivia_invincibles/</guid>
      <description>


&lt;p&gt;&lt;em&gt;generally as I have less and less time to waste on meaningless football stats I get halfway through a post and abandon it. To remedy this, I want to start pushing out posts that give a reasonable half-guess at an answer within an hour or so without needing to really check my working or write good prose. This is the first of these&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Liverpool Football Club have had a pretty impressive season until recently, winning &lt;a href=&#34;https://www.google.com/search?client=firefox-b-d&amp;amp;q=premier+league+table#sie=lg;/g/11fj6snmjm;2;/m/02_tc;st;fp;1;;&#34;&gt;26 of the first 27 games&lt;/a&gt; and remaining unbeaten. Last weekend however, they lost &lt;a href=&#34;https://www.bbc.co.uk/sport/football/51595064&#34;&gt;3-0 to Watford&lt;/a&gt; which means that Arsenal remain the only team to have gone a full (modern) season of top flight English football unbeaten (in &lt;a href=&#34;https://en.wikipedia.org/wiki/The_Invincibles_(football)&#34;&gt;2003/2004&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;Modern football twitter being what it is, a lot of debate has sprung up about which would be more impressive- going to whole season unbeaten like Arsenal, or winning 100 (out of a max 114) points in a single season, as Manchester City did in 2017-2018 and both Manchester City and Liverpool &lt;em&gt;almost&lt;/em&gt; did last season. (A third option also is the treble won by Manchester United in &lt;a href=&#34;https://en.wikipedia.org/wiki/1998%E2%80%9399_Manchester_United_F.C._season&#34;&gt;1998/1999&lt;/a&gt; but since Liverpool have also lost to Chelsea in the FA cup this week, that too remains unbeaten).&lt;/p&gt;
&lt;p&gt;As usual, first we need some libraries&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#munging
library(tidyverse)
#plotting
library(ggrepel)
#football data
library(engsoccerdata)
library(rvest)
#Ben Torvaney&amp;#39;s excellend package to model football
library(regista)

#set seed for reproducibility
set.seed(22081992)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we can get going loading up the data on English football results up until the end of the 2018/2019 season. We’ll also take some time to find the winners each season which will be useful later. There’s a lot of repetitive munging in this post so bear in mind the 3 main things we’ll be doing are:
+ pivoting data to longer to get the results for each team (not each match)
+ working out the goals for and against each team using case_when()
+ working out the points for each team using case_when()&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data &amp;lt;- engsoccerdata::england %&amp;gt;%
  #only care about the top flight in the premier league era
  dplyr::filter(Season &amp;gt; 1991 &amp;amp; Season &amp;lt; 2019 &amp;amp; division == 1) %&amp;gt;%
  select(season = Season, home, away = visitor, hgoal, agoal = vgoal)

league_winners &amp;lt;- data %&amp;gt;%
  #pivot data to longer to get team (rather than match) data
  pivot_longer(c(&amp;quot;home&amp;quot;, &amp;quot;away&amp;quot;), names_to = &amp;quot;location&amp;quot;, values_to = &amp;quot;team&amp;quot;) %&amp;gt;%
  #find goals for and goals against per team
  mutate(g_for = case_when(
    location == &amp;quot;home&amp;quot; ~ hgoal,
    location == &amp;quot;away&amp;quot; ~ agoal
  )) %&amp;gt;%
  mutate(g_ag = case_when(
    location == &amp;quot;home&amp;quot; ~ agoal,
    location == &amp;quot;away&amp;quot; ~ hgoal
  )) %&amp;gt;%
  #get the team&amp;#39;s points per match
  mutate(points = case_when(
    g_for &amp;gt; g_ag ~ 3,
    g_for == g_ag ~ 1,
    g_ag &amp;gt; g_for ~ 0
  )) %&amp;gt;%
  mutate(gd = g_for - g_ag) %&amp;gt;%
  group_by(team, season) %&amp;gt;%
  #calculate total points and goal difference
  summarise(total_points = sum(points),
            total_gd = sum(gd)) %&amp;gt;%
  #get the winners of each league season
  arrange(season, -total_points, -total_gd) %&amp;gt;%
  group_by(season) %&amp;gt;%
  mutate(league_position = 1:n()) %&amp;gt;%
  ungroup() %&amp;gt;%
  mutate(winner = case_when(
    league_position == 1 ~ &amp;quot;y&amp;quot;,
    TRUE ~ &amp;quot;n&amp;quot;
  ))

head(league_winners)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##   team                season total_points total_gd league_position winner
##   &amp;lt;chr&amp;gt;                &amp;lt;int&amp;gt;        &amp;lt;dbl&amp;gt;    &amp;lt;int&amp;gt;           &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; 
## 1 Manchester United     1992           84       36               1 y     
## 2 Aston Villa           1992           74       17               2 n     
## 3 Norwich City          1992           72       -4               3 n     
## 4 Blackburn Rovers      1992           71       22               4 n     
## 5 Queens Park Rangers   1992           63        8               5 n     
## 6 Liverpool             1992           59        7               6 n&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then use the match data to calculate the offensive and defensive strength of each teams over the whole season using the &lt;a href=&#34;https://rss.onlinelibrary.wiley.com/doi/pdf/10.1111/1467-9876.00065&#34;&gt;Dixon-Coles method&lt;/a&gt;. I’ve previously written an introduction to this method &lt;a href=&#34;https://www.robert-hickman.eu/post/dixon_coles_1/&#34;&gt;here&lt;/a&gt; (which I need to finish part two of) but suffice to say it takes the goals scored and goals conceded per game and gives a good estimation of how good a team is. It’s similar in concept to &lt;a href=&#34;https://projects.fivethirtyeight.com/soccer-predictions/&#34;&gt;fivethirtyeight’s Soccer SPI&lt;/a&gt;.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#split data by seasons
fit_data &amp;lt;- data %&amp;gt;%
  split(f = .$season) %&amp;gt;%
  lapply(., function(x) x %&amp;gt;% mutate(home = factor(home), away = factor(away)))

#model using dixoncoles() from the regista package
fits &amp;lt;- lapply(fit_data, function(x) dixoncoles(hgoal, agoal, home, away, x))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then extract the parameters from this model to see how teams have performed in each season of the Premier League. I also flip the defence axis (higher being a better defence) as I think it makes a little more sense&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;parameters &amp;lt;- fits %&amp;gt;%
  #extract the team parameters per fit
  lapply(., function(f) {
    par_data &amp;lt;- f$par[grepl(&amp;quot;def_|off_&amp;quot;, names(f$par))]
    teams &amp;lt;- unique(gsub(&amp;quot;def_*|off_*&amp;quot;, &amp;quot;&amp;quot;, names(par_data)))
    par_df &amp;lt;- matrix(par_data, ncol = 2) %&amp;gt;%
      as.data.frame() %&amp;gt;%
      rename(attack = V1, defence = V2)
    rownames(par_df) &amp;lt;- teams
    return(par_df)
  }) %&amp;gt;%
  do.call(rbind, .) %&amp;gt;%
  rownames_to_column() %&amp;gt;%
  separate(rowname, c(&amp;quot;season&amp;quot;, &amp;quot;team&amp;quot;), sep = &amp;quot;\\.&amp;quot;) %&amp;gt;%
  mutate(season = as.numeric(season)) %&amp;gt;%
  #flip the defence parameter (higher = better)
  mutate(defence = defence * -1) %&amp;gt;%
  left_join(., league_winners, by = c(&amp;quot;season&amp;quot;, &amp;quot;team&amp;quot;))

#plot the parameters with season performance (points) as the colour
p1 &amp;lt;- parameters %&amp;gt;%
  ggplot(aes(x = attack, y = defence, fill = total_points, colour = winner)) +
  geom_point(shape = 21, size = 3, alpha = 0.7, stroke = 2) +
  #label exceptional teams
  geom_text_repel(data = filter(parameters, winner == 1 | attack + defence &amp;gt; 1),
            aes(label = paste(team, season))) +
  labs(title = &amp;quot;Dixon Coles parameters per team per Premier League Season&amp;quot;,
       subtitle = &amp;quot;league winners and exceptional teams labelled&amp;quot;,
       x = &amp;quot;attacking strength&amp;quot;,
       y = &amp;quot;defensive strength&amp;quot;) +
  scale_colour_manual(values = c(&amp;quot;blue&amp;quot;, &amp;quot;red&amp;quot;)) +
  theme_minimal()

p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-04-invincibles_files/figure-html/get_dc_parameters-1.png&#34; width=&#34;1152&#34; /&gt;
We can then use these parameters as ‘true estimates’ of how good each team was each season, and go back and simulate results from each match to work out how likely a win/lose/draw for any team was in any match. This is questionably a good idea but as I said up top, this is stream of consciousness first-guesses at answering stupid trivia questions so I’m going to go along with it.&lt;/p&gt;
&lt;p&gt;The regista package’s augment.dixoncoles easily gives us the chance of a win/lose/draw per match based on the attacking/defensive strength of each team (see above) that season&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#split the matches by season
matches &amp;lt;- data %&amp;gt;%
  select(season, home, away) %&amp;gt;%
  split(f = .$season)

#function to predict the results per match
predict_matches &amp;lt;- function(dc_fit, fixtures) {
  augment.dixoncoles(x = dc_fit, newdata = fixtures, type = &amp;quot;outcomes&amp;quot;) %&amp;gt;% 
    unnest() %&amp;gt;%
    spread(outcome, prob)
}

#run the prediction function
predictions &amp;lt;- map2_df(fits, matches,
                       predict_matches)

head(predictions)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
##   season home    away             away_win  draw home_win
##    &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;               &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;    &amp;lt;dbl&amp;gt;
## 1   1992 Arsenal Aston Villa         0.294 0.379    0.327
## 2   1992 Arsenal Blackburn Rovers    0.319 0.344    0.337
## 3   1992 Arsenal Chelsea             0.220 0.342    0.437
## 4   1992 Arsenal Coventry City       0.214 0.333    0.454
## 5   1992 Arsenal Crystal Palace      0.188 0.322    0.490
## 6   1992 Arsenal Everton             0.223 0.338    0.439&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So e.g. based on Dixon-Coles estimates, given how well Arsenal and Aston Villa did over the &lt;em&gt;whole&lt;/em&gt; of the 1992/1993 season, Arsenal had a 32.6% chance of beating Aston Villa at home on the opening day of the season.&lt;/p&gt;
&lt;p&gt;We can then use these probability estimates to calculate the chance of any one team going unbeaten over the whole league (multiply out the probabilities of not losing each game)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;invincible_chance &amp;lt;- predictions %&amp;gt;%
  #get match predictions per team
  pivot_longer(c(&amp;quot;home&amp;quot;, &amp;quot;away&amp;quot;), names_to = &amp;quot;location&amp;quot;, values_to = &amp;quot;team&amp;quot;) %&amp;gt;%
  mutate(nonloss_chance = case_when(
    location == &amp;quot;home&amp;quot; ~ 1 - away_win,
    location == &amp;quot;away&amp;quot; ~ 1 - home_win
  )) %&amp;gt;%
  select(season, team, nonloss_chance) %&amp;gt;%
  group_by(team, season) %&amp;gt;%
  #chance of going invincible = product sum of chance of not drawing
  summarise(invincible_chance = prod(nonloss_chance)) %&amp;gt;%
  arrange(-invincible_chance)

head(invincible_chance, n = 10)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 10 x 3
## # Groups:   team [6]
##    team              season invincible_chance
##    &amp;lt;chr&amp;gt;              &amp;lt;int&amp;gt;             &amp;lt;dbl&amp;gt;
##  1 Chelsea             2004           0.0494 
##  2 Manchester City     2017           0.0362 
##  3 Manchester City     2018           0.0286 
##  4 Liverpool           2018           0.0232 
##  5 Arsenal             1998           0.0164 
##  6 Manchester City     2011           0.0124 
##  7 Manchester United   2007           0.0123 
##  8 Tottenham Hotspur   2016           0.00846
##  9 Arsenal             2003           0.00529
## 10 Chelsea             2009           0.00475&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So it turns out that the team most likely to have gone invincible over a whole season was Chelsea in 2004/2005 (not surprising given their &lt;a href=&#34;https://en.wikipedia.org/wiki/2004%E2%80%9305_Chelsea_F.C._season#Results_by_round&#34;&gt;excellent defensive record that year&lt;/a&gt;), but with only a ~5% chance.&lt;/p&gt;
&lt;p&gt;Arsenal’s &lt;em&gt;actual&lt;/em&gt; invincible year is estimated that have had a 0.05% chance based on the team’s results (surprisingly low!). Another notable team is Tottenham Hotspur who only finished 2nd in 2016/2017 but perhaps went under the radar as a very good team that year (with a 0.08% chance of finishing unbeaten).&lt;/p&gt;
&lt;p&gt;So we can assume* that the very best ‘unbeatable’ teams have ~5% chance of finishing a season invincible. We can use this baseline to see how hard this seems compared to the expectation a team gets 100 points.&lt;/p&gt;
&lt;p&gt;*not really, but for this post yes&lt;/p&gt;
&lt;p&gt;We’re going to simulate every Premier League season 1000 times and calculate the total points expected of a team based on their Dixon-Coles parameters. To narrow down the search a bit, I’m going to limit it to only exceptional teams with an attack and defence parameter &amp;gt; 0.25 (which gives 33 season-teams).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;result_probs &amp;lt;- predictions %&amp;gt;%
  #pivoting and case_when to get result probabilities per team
  pivot_longer(c(&amp;quot;home&amp;quot;, &amp;quot;away&amp;quot;), names_to = &amp;quot;location&amp;quot;, values_to = &amp;quot;team&amp;quot;) %&amp;gt;%
  mutate(win = case_when(
    location == &amp;quot;home&amp;quot; ~ home_win,
    location == &amp;quot;away&amp;quot; ~ away_win
  )) %&amp;gt;%
  mutate(lose = 1 - draw - win) %&amp;gt;%
  select(season, team, win, lose, draw) %&amp;gt;%
  group_by(team, season) %&amp;gt;%
  mutate(game = 1:n()) %&amp;gt;%
  nest(probs = c(win, lose, draw))

#filter down to only the very best teams to save processing
selected_teams &amp;lt;- parameters %&amp;gt;%
  filter(attack &amp;gt; 0.25 &amp;amp; defence &amp;gt; 0.25) %&amp;gt;%
  select(season, team) %&amp;gt;%
  left_join(., result_probs, by = c(&amp;quot;team&amp;quot;, &amp;quot;season&amp;quot;))

sim_result &amp;lt;- function(probabilities) {
  chosen_results &amp;lt;- gather(probabilities) %&amp;gt;%
    sample_n(., 1, weight = value)
  result &amp;lt;- chosen_results$key
}

simulate_all_games &amp;lt;- function(data) {
  data$result &amp;lt;- unlist(lapply(data$probs, sim_result))
  return(data)
}

#will simulate 1000 seasons for each of these teams
n_sims &amp;lt;- 1000

#run simulations - will take ~10mins
simulated_results &amp;lt;- rerun(n_sims, simulate_all_games(selected_teams))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Calculating the total points won per season, we can work out the percentage of simulations in which each team exceed 100 points quite easily&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;simulated_points &amp;lt;- simulated_results %&amp;gt;%
  #for each sim, get the points won by each team
  lapply(., function(data) {
    data &amp;lt;- data %&amp;gt;%
      mutate(points = case_when(
        result == &amp;quot;win&amp;quot; ~ 3,
        result == &amp;quot;draw&amp;quot; ~ 1,
        result == &amp;quot;lose&amp;quot; ~ 0
      )) %&amp;gt;%
      group_by(season, team) %&amp;gt;%
      mutate(total_points = sum(points)) %&amp;gt;%
      select(season, team, total_points) %&amp;gt;%
      unique()
  }) %&amp;gt;%
  do.call(rbind, .)

#probability of reaching 100 points is no. of sims &amp;gt; 100 points / n_sims
centurion_probs &amp;lt;- simulated_points %&amp;gt;%
  filter(total_points &amp;gt; 99) %&amp;gt;%
  group_by(season, team) %&amp;gt;%
  summarise(centurion_prob = n() / n_sims) %&amp;gt;%
  arrange(-centurion_prob)

print(centurion_probs)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 27 x 3
## # Groups:   season [16]
##    season team              centurion_prob
##     &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                      &amp;lt;dbl&amp;gt;
##  1   2017 Manchester City            0.17 
##  2   2018 Manchester City            0.107
##  3   2018 Liverpool                  0.076
##  4   1994 Manchester United          0.069
##  5   2004 Chelsea                    0.046
##  6   2009 Chelsea                    0.039
##  7   2011 Manchester City            0.029
##  8   2007 Manchester United          0.023
##  9   2016 Tottenham Hotspur          0.023
## 10   2006 Manchester United          0.011
## # … with 17 more rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As expected, the two recent Manchester City teams come top, with the one that actually did reach 100 points (2017) given a 14.5% chance of reaching that milestone, given their strength.&lt;/p&gt;
&lt;p&gt;So now we have a baseline that the best team at accumulating points (Manchester City 2017/2018) has ~3x as much chance of winning 100 points in that season than the very best (potentially) invincible team (Chelsea 2004/2005). I.e. we have some (not super strong) evidence that it is ~3x as hard to go a season unbeaten than it is to become a ‘centurion’.&lt;/p&gt;
&lt;p&gt;We can calculate how many points our threshold needs to be set at to have an equal chance using top_frac() on our 1000 simulations.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find the points threshold for Man City 2017 that would reach n points 
#as often as Chelsea 2004 would go unbeaten
invincible_equivalent &amp;lt;- simulated_points %&amp;gt;%
  ungroup() %&amp;gt;%
  filter(season == 2017 &amp;amp; team == &amp;quot;Manchester City&amp;quot;) %&amp;gt;%
  top_frac(max(invincible_chance$invincible_chance)) %&amp;gt;%
  arrange(total_points)

#print the lowest threshold
head(invincible_equivalent, n = 1)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 3
##   season team            total_points
##    &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                  &amp;lt;dbl&amp;gt;
## 1   2017 Manchester City          103&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we might presume that the equivalent achievement to going the season unbeaten is to win 103 points in the Premier League. To see how the 2017/2018 Manchester City team compare to this we can plot the expected final points total of that season (given league team strengths) in a histogram:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p2 &amp;lt;-  simulated_points %&amp;gt;%
  ungroup() %&amp;gt;%
  filter(season == 2017 &amp;amp; team == &amp;quot;Manchester City&amp;quot;) %&amp;gt;%
  ggplot(., aes(x = total_points)) +
  geom_histogram(fill = &amp;quot;skyblue&amp;quot;, alpha = 0.7) +
  #invincle equivalent achievement in red
  geom_vline(xintercept = min(invincible_equivalent$total_points),
             colour = &amp;quot;red&amp;quot;, linetype = &amp;quot;dashed&amp;quot;, size = 2) +
  #actual achievement in blue
  geom_vline(xintercept = filter(league_winners, season == 2017 &amp;amp; league_position == 1)$total_points,
             colour = &amp;quot;blue&amp;quot;, linetype = &amp;quot;dashed&amp;quot;, size = 2) +
  labs(title = &amp;quot;Man C. expected 2017/2018 performance c.f. invincible equivalent threshold&amp;quot;,
       subtitle = &amp;quot;invincible equivalent achievement = 103 points, actual = 100 points&amp;quot;,
       x = &amp;quot;season expected total points&amp;quot;,
       y = paste(&amp;quot;times achieved over&amp;quot;, n_sims, &amp;quot;simulations&amp;quot;)) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-04-invincibles_files/figure-html/plot_threshold-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The original question was really if this years Liverpool team might achieve this 103 point threshold (given they have now failed to go unbeaten). We can test this by doing exactly the same procedure on their season so far.&lt;/p&gt;
&lt;p&gt;First we need to download all the match data from fbref. Handily, fbref doesn’t just gives us the goals scored per match but the &lt;a href=&#34;https://fbref.com/en/expected-goals-model-explained/&#34;&gt;&lt;em&gt;expected goals&lt;/em&gt;&lt;/a&gt; each team managed to put up. We’re going to use that to model team strengths as we might assume* this is a better measure of how good a team really is. In order to fit the model using the regista package I need to supply an integer, so I’ve simply rounded those xG numbers to the nearest whole number**&lt;/p&gt;
&lt;p&gt;*lets ignore game state and other such important thing- this is &lt;em&gt;five minute&lt;/em&gt; football trivia
**you actually can use expected goals in a regista::dixoncoles model, see &lt;a href=&#34;https://www.robert-hickman.eu/post/wsl-prediction-1/&#34;&gt;here&lt;/a&gt;, but this is &lt;em&gt;five minute&lt;/em&gt; football trivia&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#download the match data from 2019/2020
fixtures_2020 &amp;lt;- &amp;quot;https://fbref.com/en/comps/9/schedule/Premier-League-Fixtures&amp;quot; %&amp;gt;%
  read_html() %&amp;gt;%
  html_nodes(&amp;quot;#sched_ks_3232_1&amp;quot;) %&amp;gt;%
  html_table() %&amp;gt;%
  as.data.frame() %&amp;gt;%
  separate(Score, into = c(&amp;quot;hgoal&amp;quot;, &amp;quot;agoal&amp;quot;), sep = &amp;quot;–&amp;quot;) %&amp;gt;%
  #only care about goals and expected goals
  select(home = Home, away = Away, home_xg = xG, away_xg = xG.1, hgoal, agoal) %&amp;gt;%
  filter(home != &amp;quot;&amp;quot;) %&amp;gt;%
  mutate(home = factor(home), away = factor(away)) %&amp;gt;%
  #round expected goals to nearest integer
  mutate_at(c(&amp;quot;home_xg&amp;quot;, &amp;quot;away_xg&amp;quot;, &amp;quot;hgoal&amp;quot;, &amp;quot;agoal&amp;quot;), .funs = funs(round(as.numeric(.))))

#matches with a known result
#used for modelling
played_matches &amp;lt;- fixtures_2020 %&amp;gt;%
  filter(!is.na(home_xg))

#matches with an unknown result
#used for simulation
unplayed_matches &amp;lt;- fixtures_2020 %&amp;gt;%
  filter(is.na(home_xg)) %&amp;gt;%
  select_if(negate(is.numeric))

#fit the dixon coles model
fit_2020 &amp;lt;- dixoncoles(home_xg, away_xg, home, away, data = played_matches)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And as before we can plot the team strength in attacking and defending dimensions&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#extract parameters from the model
pars_2020 &amp;lt;- fit_2020$par %&amp;gt;%
  .[grepl(&amp;quot;def_|off_&amp;quot;, names(.))] %&amp;gt;%
  matrix(., ncol = 2) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  rename(attack = V1, defence = V2)
pars_2020$team &amp;lt;- unique(gsub(&amp;quot;def_*|off_*&amp;quot;, &amp;quot;&amp;quot;, names(fit_2020$par)))[1:20]

#plot as before
p3 &amp;lt;- pars_2020 %&amp;gt;%
  mutate(defence = 1 - defence) %&amp;gt;%
  ggplot(aes(x = attack, y = defence, colour = attack + defence, label = team)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_text_repel() +
  labs(title = &amp;quot;Dixon Coles parameters per team 2019/2020&amp;quot;,
       x = &amp;quot;attacking strength&amp;quot;,
       y = &amp;quot;defensive strength&amp;quot;) +
  scale_colour_continuous(guide = FALSE) +
  labs(title = &amp;quot;Dixon Coles parameters per team for the 2019/2020 Premier League Season&amp;quot;,
       x = &amp;quot;attacking strength&amp;quot;,
       y = &amp;quot;defensive strength&amp;quot;) +
  theme_minimal()

p3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-04-invincibles_files/figure-html/2020_dc_parameters-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Surprisingly, a distant 2nd place Manchester City actually rate higher than Liverpool using this model, and Manchester United (by all accounts having a very middling season) aren’t far off either.&lt;/p&gt;
&lt;p&gt;Now we just need to simulate the remaining games of Liverpool’s season to see how likely they are to hit are 103 points target. We can then add the points we expect Liverpool to win to the number of points we know they already have to get an estimate of final total points.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#calculate points we know Liverpool have
liverpool_points &amp;lt;- played_matches %&amp;gt;%
  filter(home == &amp;quot;Liverpool&amp;quot; | away == &amp;quot;Liverpool&amp;quot;) %&amp;gt;%
  mutate(points = case_when(
    hgoal == agoal ~ 1,
    home == &amp;quot;Liverpool&amp;quot; &amp;amp; (hgoal &amp;gt; agoal) ~ 3,
    away == &amp;quot;Liverpool&amp;quot; &amp;amp; (agoal &amp;gt; hgoal) ~ 3,
    TRUE ~ 0
  )) %&amp;gt;%
  summarise(total_points = sum(points))

#estimate the chance of results in all remaining games
unplayed_results &amp;lt;-
  augment.dixoncoles(fit_2020, unplayed_matches, type.predict = &amp;quot;outcomes&amp;quot;) %&amp;gt;%
  unnest() %&amp;gt;%
  #filter out the liverpool ones
  filter(home == &amp;quot;Liverpool&amp;quot; | away == &amp;quot;Liverpool&amp;quot;)

#function to simulate a season by making weighted samples
simulate_season &amp;lt;- function(result_probabilities) {
  result_probabilities %&amp;gt;%
    nest(outcome, prob, .key = &amp;quot;results&amp;quot;) %&amp;gt;%
    mutate(sampled = map(results, ~ sample_n(., 1, weight = prob))) %&amp;gt;%
    select(-results) %&amp;gt;%
    unnest()
}

#simulate the rest of liverpool&amp;#39;s season
liverpool_2020_simulated &amp;lt;- rerun(n_sims, simulate_season(unplayed_results)) %&amp;gt;%
  bind_rows(.id = &amp;quot;simulation_id&amp;quot;) %&amp;gt;%
  #find the sampled points won per game
  mutate(points = case_when(
    home == &amp;quot;Liverpool&amp;quot; &amp;amp; outcome == &amp;quot;home_win&amp;quot; ~ 3,
    away == &amp;quot;Liverpool&amp;quot; &amp;amp; outcome == &amp;quot;away_win&amp;quot; ~ 3,
    outcome == &amp;quot;draw&amp;quot; ~ 1,
    TRUE ~ 0
  )) %&amp;gt;%
  group_by(simulation_id) %&amp;gt;%
  #calculate Liverpool&amp;#39;s total season points for this simulation
  summarise(total_points = sum(points) + as.numeric(liverpool_points))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It’s then very easy to find the fraction of sims in which Liverpool break this 103 point challenge&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;length(which(liverpool_2020_simulated$total_points &amp;gt; 102)) / 1000&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.157&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we can plot it as before to see how many points we expect Liverpool to win this season:
(this time the 103 point threshold is in blue to stand out against the red that Liverpool play in)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p4 &amp;lt;- liverpool_2020_simulated %&amp;gt;%
  ggplot(., aes(x = total_points)) +
  geom_histogram(fill = &amp;quot;red&amp;quot;, alpha = 0.7) +
  #invincle equivalent achievement in red
  geom_vline(xintercept = min(invincible_equivalent$total_points),
             colour = &amp;quot;blue&amp;quot;, linetype = &amp;quot;dashed&amp;quot;, size = 2) +
  labs(title = &amp;quot;Liverpool&amp;#39;s expected 2019/2020 performance c.f. invincible equivalent threshold&amp;quot;,
       subtitle = &amp;quot;invincible equivalent achievement = 103 points in blue this time&amp;quot;,
       x = &amp;quot;season expected total points&amp;quot;,
       y = paste(&amp;quot;times achieved over&amp;quot;, n_sims, &amp;quot;simulations&amp;quot;)) +
  theme_minimal()

p4&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2020-03-04-invincibles_files/figure-html/plot_liverpool_expectation-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Anyway, that’s that for the first of these (hopefully? of many!). Did we learn anything? probably not. But did we at least do something interesting? also probably not. But I do like doing these silly little analyses in my spare time and by not limiting myself to things like rigor, I can pump them out faster. I’ll probably aim for one post (smaller than this) a week to start building a little bit of a public portfolio up again (I’m unemployed in 5 months- hire me!!). Hope you enjoyed reading it :)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Advent Calendar of Football Trivia Analyses</title>
      <link>/post/advent_calendar_trivia/</link>
      <pubDate>Sun, 01 Dec 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/advent_calendar_trivia/</guid>
      <description>


&lt;p&gt;One of the most consistent &lt;a href=&#34;https://www.robert-hickman.eu/project/guardian_knowledge/&#34;&gt;fonts of posts on this blog&lt;/a&gt; is The Guardian’s football trivia page &lt;a href=&#34;https://www.theguardian.com/football/series/theknowledge&#34;&gt;The Knowledge&lt;/a&gt;. A particular reason for this is that the small contained questions lend themselves to small blogposts that I can turn around in an hour or two, as opposed to being endlessly redrafted until I lose interest.&lt;/p&gt;
&lt;p&gt;However, I still sometimes don’t quite get round to finishing some of these posts, or have trouble justifying a blog post on a very small and ‘trivial’ answer to a question. Therefore, as a sort of end-of-year round up, and a Christmas present to myself, I wanted to push out answers to questions I found particularly interesting over the last year and hadn’t quite got round to &lt;sup&gt;1&lt;/sup&gt;. I’ll probably add them all to this post as I finish them up.&lt;/p&gt;
&lt;div id=&#34;nd-december---everything-in-its-right-place&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;2nd December - Everything in its right place&lt;/h1&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
I wonder if any of any sporting leagues have ever ended in alphabetical order? &lt;a href=&#34;https://t.co/you6u8Uzwz&#34;&gt;pic.twitter.com/you6u8Uzwz&lt;/a&gt;
&lt;/p&gt;
— P A Hunt (&lt;span class=&#34;citation&#34;&gt;@TeachFMaths&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/TeachFMaths/status/1139832761295024128?ref_src=twsrc%5Etfw&#34;&gt;June 15, 2019&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;answer---yes-kind-of.-but-also-no.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Answer - yes, kind of. But also no.&lt;/h2&gt;
&lt;p&gt;This question has actually &lt;a href=&#34;https://www.theguardian.com/football/2011/mar/09/has-league-ever-finished-alphabetical-order&#34;&gt;been answered&lt;/a&gt; (as many of these will have been). For a league of 20 teams (like the English Premier League), we might imagine if would have happened over the last ~150 years, but it’s almost certain from some basic maths that it won’t have, and moreover, will never happen.&lt;/p&gt;
&lt;p&gt;Let’s load some data and see why.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#as per usual, going to heavily rely on tidyverse 
#and engsoccerdata throughout these posts
library(tidyverse)
library(engsoccerdata)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#load English league data
league_data &amp;lt;- engsoccerdata::england %&amp;gt;%
  #select and gather match results
  select(season = Season, division, home, visitor, hgoal, vgoal) %&amp;gt;%
  gather(&amp;quot;location&amp;quot;, &amp;quot;team&amp;quot;, -season, -division, -hgoal, -vgoal) %&amp;gt;%
  mutate(
    g_for = case_when(
      location == &amp;quot;home&amp;quot; ~ hgoal,
      location == &amp;quot;visitor&amp;quot; ~ vgoal
    ),
    g_ag = case_when(
      location == &amp;quot;home&amp;quot; ~ vgoal,
      location == &amp;quot;visitor&amp;quot; ~ hgoal
    )) %&amp;gt;%
  #get correct point for a win/loss
  mutate(
    points = case_when(
      g_for &amp;gt; g_ag &amp;amp; season &amp;lt; 1981 ~ 2,
      g_for &amp;gt; g_ag &amp;amp; season &amp;gt; 1980 ~ 3,
      g_for == g_ag ~ 1,
      g_for &amp;lt; g_ag ~ 0
    ),
    gd = g_for - g_ag
  ) %&amp;gt;%
  #group by season and league and get final tables
  group_by(season, division, team) %&amp;gt;%
  summarise(points = sum(points),
            gd = sum(gd),
            g_for = sum(g_for)) %&amp;gt;%
  arrange(-points, -gd, -g_for) %&amp;gt;%
  #rank league order and alphabetical order
  mutate(league_pos = rank(-points, ties.method = &amp;quot;first&amp;quot;),
         alph_order = rank(team, ties.method = &amp;quot;first&amp;quot;)) %&amp;gt;%
  select(season, division, team, league_pos, alph_order) %&amp;gt;%
  #split by league and season
  split(., f = list(.$season, .$division)) %&amp;gt;%
  keep(function(x) nrow(x) &amp;gt; 0)

#print the top of the first league table
head(league_data[[1]])&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 5
## # Groups:   season, division [1]
##   season division team                    league_pos alph_order
##    &amp;lt;int&amp;gt;    &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;                        &amp;lt;int&amp;gt;      &amp;lt;int&amp;gt;
## 1   1888        1 Preston North End                1          9
## 2   1888        1 Aston Villa                      2          2
## 3   1888        1 Wolverhampton Wanderers          3         12
## 4   1888        1 Blackburn Rovers                 4          3
## 5   1888        1 Bolton Wanderers                 5          4
## 6   1888        1 West Bromwich Albion             6         11&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then run a load of Spearman’s rank correlation tests on the data to see which ones are perfectly correlated or anti-correlated in both league and alphabetical ranking. We’ll use the very handy &lt;a href=&#34;https://cran.r-project.org/web/packages/broom/vignettes/broom.html&#34;&gt;broom&lt;/a&gt; package to tidy the results of our many tests into one data.frame (remove the filter at the end of the pipe chain to see what gets output).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#use broom to tidily do stats
library(broom)

#correlate league and alphabetical order by year
exact_correlations &amp;lt;- league_data %&amp;gt;%
  map_df(., function(data) {
    cor.test(
      data$league_pos,
      data$alph_order,
      method = &amp;quot;spearman&amp;quot;
    ) %&amp;gt;%
      tidy() %&amp;gt;%
      mutate(season = unique(data$season),
             division = unique(data$division))
  }) %&amp;gt;%
  #take only significantly 
  filter(abs(statistic) == 1)

print(exact_correlations)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 0 x 7
## # ... with 7 variables: estimate &amp;lt;dbl&amp;gt;, statistic &amp;lt;dbl&amp;gt;, p.value &amp;lt;dbl&amp;gt;,
## #   method &amp;lt;chr&amp;gt;, alternative &amp;lt;chr&amp;gt;, season &amp;lt;int&amp;gt;, division &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And so we find no exact correlations. There are no instances in 363 separate seasons of English league football where teams line up in either alphabetical, or anti-alphabetical order.&lt;/p&gt;
&lt;p&gt;Let’s see why this is. To make things simpler, I’m going to imagine a cutdown league of only 6 teams using teams starting with each of the first 6 letter of the alphabet:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;first_letter_names &amp;lt;- league_data %&amp;gt;%
  bind_rows() %&amp;gt;%
  ungroup() %&amp;gt;%
  #get first letter of a team name
  mutate(first_letter = gsub(&amp;quot;(^.)(.*)&amp;quot;, &amp;quot;\\1&amp;quot;, team)) %&amp;gt;%
  filter(season &amp;gt; 1992 &amp;amp;
           division == 1 &amp;amp;
           first_letter %in% toupper(letters[1:6])
         ) %&amp;gt;%
  #get one team beginning with A, B, C...
  filter(!duplicated(first_letter)) %&amp;gt;%
  select(team) %&amp;gt;%
  arrange(team) %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 1
##   team            
##   &amp;lt;chr&amp;gt;           
## 1 Arsenal         
## 2 Blackburn Rovers
## 3 Coventry City   
## 4 Derby County    
## 5 Everton         
## 6 Fulham&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For the league to finish in alphabetical order, we first need the team that is first alphabetically (Arsenal) to finish in first position. Assuming all teams have an equal chance of winning the league, the chance of this is obviously&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ p(Arsenal = 1) =  \frac{1}{n}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Then we need the second team (Blackburn Rovers), to finish in second. This is predicated on Arsenal already finishing in first position, so the chance becomes&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ p(Blackburn = 2 | Arsenal = 1) = \frac{1}{n-1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;and so on until the last team (Fulham) just have to slot into the only position left (n, 6th in our example)&lt;/p&gt;
&lt;p&gt;Thus the total chance becomes&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ \frac{1}{n} \cdot \frac{1}{n-1} ... \cdot \frac{1}{1} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which can also be written&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ p(ordered) = \prod_{n = 1}^{N} \frac{1}{n}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;which multiplies out to&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ p(ordered) = \frac{1}{n!} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;so for our very small league the chance of n (assumed equally strong teams)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;factorial(nrow(first_letter_names))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 720&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;so we have a 1/720 chance that this league ends perfectly in alphabetical order. For bigger leagues (for reference most large European leagues contain 18-24 teams) this denominator grows &lt;em&gt;super-exponentially&lt;/em&gt; and becomes tiny.&lt;/p&gt;
&lt;p&gt;For the English Premier League (20 teams) for instance the chance becomes&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;league_data %&amp;gt;%
  bind_rows() %&amp;gt;%
  ungroup() %&amp;gt;%
  filter(season == max(season) &amp;amp; division == 1) %&amp;gt;% 
  nrow() %&amp;gt;%
  factorial()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 2.432902e+18&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or 1 in 2.4 &lt;a href=&#34;https://en.wikipedia.org/wiki/Order_of_magnitude&#34;&gt;quintillion&lt;/a&gt;. In short, if it’s assumed that there’s no relation between order of names and team strength, we might expect the universe to end before all 20 teams finish in perfect order.&lt;/p&gt;
&lt;p&gt;We can test if our predictions bear out by looking at tiny leagues with small numbers of teams, e.g. &lt;a href=&#34;https://en.wikipedia.org/wiki/2018%E2%80%9319_UEFA_Champions_League_group_stage&#34;&gt;the group stages of the Champions/Europa Leagues&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;First we need to scrape the final tables for the last 8 years of data from both competitions:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(rvest)

#website to scrape group stage data from
fb_data &amp;lt;- &amp;quot;https://footballdatabase.com&amp;quot;
ucl_links &amp;lt;- sprintf(
  &amp;quot;/league-scores-tables/uefa-champions-league-20%s-%s&amp;quot;,
  10:18, 11:19
)
europa_links &amp;lt;- sprintf(
  &amp;quot;/league-scores-tables/uefa-europa-league-20%s-%s&amp;quot;,
  10:18, 11:19
)
#function to scrape the data from these links
get_competition_data &amp;lt;- function(competition, links) {
  data &amp;lt;- links %&amp;gt;%
    paste0(fb_data, .) %&amp;gt;%
    map_df(., function(year) {
      page_read &amp;lt;- read_html(year)
      
      groups &amp;lt;- letters[1:8] %&amp;gt;%
        map_df(., function(group) {
          page_read %&amp;gt;% 
            html_nodes(sprintf(&amp;quot;#total-group-%s &amp;gt; div &amp;gt; table&amp;quot;, group)) %&amp;gt;% 
            html_table(fill = TRUE) %&amp;gt;% 
            as.data.frame() %&amp;gt;%
            mutate(group)
        }) %&amp;gt;%
        mutate(year = gsub(&amp;quot;(.*-)([0-9]{4}-[0-9]{2})&amp;quot;, &amp;quot;\\2&amp;quot;, year))
    }) %&amp;gt;%
    mutate(competition)
}
#scrape and bind the data
uefa_data &amp;lt;- bind_rows(
  get_competition_data(&amp;quot;champions&amp;quot;, ucl_links),
  get_competition_data(&amp;quot;europa&amp;quot;, europa_links)
)
#print a cutdown version of the scraped data
head(uefa_data %&amp;gt;% select(club = Club, points = P, year, competition))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##                club points    year competition
## 1 Tottenham Hotspur     11 2010-11   champions
## 2       Inter Milan     10 2010-11   champions
## 3         FC Twente      6 2010-11   champions
## 4     Werder Bremen      5 2010-11   champions
## 5        Schalke 04     13 2010-11   champions
## 6              Lyon     10 2010-11   champions&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So now we have 128 (8 groups x 8 years x 2 competitions) ‘mini-leagues’ each of 4 teams.&lt;/p&gt;
&lt;p&gt;We can then munge this data to find all the groups where the teams finish in alphabetical order. We’d expect 128/4! leagues to finish in alphabetical order (or 5.33 to be exact).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ordered_groups &amp;lt;- uefa_data %&amp;gt;%
  #select relevant informatiob
  select(team = Club, league_pos = X., group, year, competition) %&amp;gt;%
  #by group find where teams finish in alphabetical order
  group_by(year, group, competition) %&amp;gt;%
  mutate(alph_order = rank(team, ties.method = &amp;quot;first&amp;quot;)) %&amp;gt;%
  filter(league_pos == alph_order) %&amp;gt;%
  #keep only group where all (4) teams finish in order
  summarise(n = n()) %&amp;gt;%
  filter(n == 4) %&amp;gt;%
  #join and filter back data
  left_join(uefa_data, ., by = c(&amp;quot;group&amp;quot;, &amp;quot;year&amp;quot;, &amp;quot;competition&amp;quot;)) %&amp;gt;%
  filter(!is.na(n)) %&amp;gt;%
  #select useful information
  select(team = Club, points = P, gd = X..., league_pos = X.,
         group, year, competition) %&amp;gt;%
  #split groups up
  split(., list(.$year, .$group, .$competition)) %&amp;gt;%
  keep(function(x) nrow(x) &amp;gt; 0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;which leaves us with 5 leagues that have finished in order! almost exactly what we’d predict by chance if the first letter of a teams name had no effect on the outcome.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;ordered_groups&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $`2011-12.c.champions`
##                team points gd league_pos group    year competition
## 5           Benfica     12  4          1     c 2011-12   champions
## 6          FC Basel     11  1          2     c 2011-12   champions
## 7 Manchester United      9  3          3     c 2011-12   champions
## 8     Otelul Galati      0 -8          4     c 2011-12   champions
## 
## $`2015-16.c.champions`
##                team points gd league_pos group    year competition
## 9   Atlético Madrid     13  8          1     c 2015-16   champions
## 10          Benfica     10  2          2     c 2015-16   champions
## 11      Galatasaray      5 -4          3     c 2015-16   champions
## 12 Lokomotiv Astana      4 -6          4     c 2015-16   champions
## 
## $`2010-11.f.champions`
##             team points  gd league_pos group    year competition
## 1     Chelsea FC     15  10          1     f 2010-11   champions
## 2      Marseille     12   9          2     f 2010-11   champions
## 3 Spartak Moskva      9  -3          3     f 2010-11   champions
## 4         Žilina      0 -16          4     f 2010-11   champions
## 
## $`2015-16.g.champions`
##                   team points  gd league_pos group    year competition
## 13          Chelsea FC     13  10          1     g 2015-16   champions
## 14         Dynamo Kyiv     11   4          2     g 2015-16   champions
## 15            FC Porto     10   1          3     g 2015-16   champions
## 16 Maccabi Tel Aviv FC      0 -15          4     g 2015-16   champions
## 
## $`2018-19.h.champions`
##                 team points gd league_pos group    year competition
## 17          Juventus     12  5          1     h 2018-19   champions
## 18 Manchester United     10  3          2     h 2018-19   champions
## 19          Valencia      8  0          3     h 2018-19   champions
## 20        Young Boys      4 -8          4     h 2018-19   champions
## 
## $`2012-13.h.europa`
##                      team points gd league_pos group    year competition
## 21         FC Rubin Kazan     14  7          1     h 2012-13      europa
## 22            Inter Milan     11  2          2     h 2012-13      europa
## 23                 Neftçi      3 -4          3     h 2012-13      europa
## 24 Partizan Beograd (SRB)      3 -5          4     h 2012-13      europa&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can also do a larger test by randomly selecting teams out of the English league data we looked at earlier. To do this I need two quick functions: one to sample randomly from the data, and another to carry out the correlation test.&lt;/p&gt;
&lt;p&gt;The first takes a number of samples (how many tests to run) and then selects a number of teams from each league sample. For instance, if I chose 3 teams, it might select Liverpool, Manchester United, and Watford, from the &lt;a href=&#34;https://en.wikipedia.org/wiki/2018%E2%80%9319_Premier_League&#34;&gt;last season of the Premier League&lt;/a&gt;. These teams finished 2nd, 6th, and 11th respectively, so this ‘sampled league’ would fulfill the criteria of finishing in alphabetical order.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(3459)

#take a random sample of leagues and teams withing those leagues
sample_cutdown_leagues &amp;lt;- function(nteams, nsamples, data) {
  samples &amp;lt;- sample(length(data), nsamples, replace = TRUE)
  
  sampled_league_data &amp;lt;- data[samples]
  
  league_team_serials &amp;lt;- sampled_league_data %&amp;gt;%
    lapply(., nrow) %&amp;gt;%
    lapply(., sample, size = nteams)
  
  #carry out the correlation test
  league_cor_test &amp;lt;- map2_df(
    .x = sampled_league_data,
    .y = league_team_serials,
    .f = cor_test_data
  )
}
  
#function for correlation test
cor_test_data &amp;lt;- function(full_league_data, sampled_teams) {
  sampled_league &amp;lt;- full_league_data[sampled_teams,] %&amp;gt;%
    arrange(league_pos)
  cor_test &amp;lt;- cor.test(
    sampled_league$league_pos,
    sampled_league$alph_order,
    method = &amp;quot;spearman&amp;quot;
  ) %&amp;gt;%
    tidy() %&amp;gt;%
    #mutate on information about that season and teams chosen
    mutate(teams = paste(sampled_league$team, collapse = &amp;quot;, &amp;quot;),
           season = unique(sampled_league$season),
           division = unique(sampled_league$division))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So for instance if I just run it once, randomly selecting 4 teams:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;test &amp;lt;- sample_cutdown_leagues(4, 1, league_data)
#print the teams selected
test$teams&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Brentford, Bristol Rovers, Brighton &amp;amp; Hove Albion, Chester&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;test&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 8
##   estimate statistic p.value method   alternative teams     season division
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt;    &amp;lt;int&amp;gt;
## 1      0.8      2.00   0.333 Spearma~ two.sided   Brentfor~   1994        3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It gives me 4 teams from the 1994 division 3 who didn’t finish in alphabetical order (though, amusingly, all have a very similar starting letter).&lt;/p&gt;
&lt;p&gt;We can then carry this out with 10000 samples for n_team numbers of 2:6 to see if we get roughly the expected numbers of exactly correlated league finish positions (this will take 1-2mins) by finding out how many tests give an estimate of 1 (finished exactly correlated with alphabetical order) or -1 (finished exactly anti-correlated with alphabetical order).&lt;/p&gt;
&lt;p&gt;Both these numbers should be roughly equal to the number of samples (10000) divided by the factorial of the number of teams selected.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;test_n_numbers &amp;lt;- function(nteams) {
  #run sampling function n times
  #10k should do
  sampling &amp;lt;- sample_cutdown_leagues(nteams, 10000, league_data)
  
  #find exactly correlated and anti-correlated examples
  #where teams are in exact alphabetical order ascending or descending
  correlated &amp;lt;- length(which(sampling$estimate == max(sampling$estimate)))
  anti_correlated &amp;lt;- length(which(sampling$estimate == min(sampling$estimate)))
  expected &amp;lt;- nrow(sampling) / factorial(nteams)
  
  df &amp;lt;- data.frame(n = nteams,
                   sample_cor = correlated,
                   sample_anticor = anti_correlated,
                   sample_expected = expected)
}
#run the function
testing &amp;lt;- map_df(2:6, test_n_numbers)
#print results
print(testing)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##   n sample_cor sample_anticor sample_expected
## 1 2       5010           4990      5000.00000
## 2 3       1676           1665      1666.66667
## 3 4        367            398       416.66667
## 4 5        101             81        83.33333
## 5 6         14             15        13.88889&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the numbers line up, as we would expect if there is no effect of the first letter of a team’s name upon final league position.&lt;/p&gt;
&lt;p&gt;Finally, we can do a Kendall’s correlation test to really see if there is any relationship between alphabetical team name order and final league finish for all out our English league data. We use Kendall instead of a Spearman test here because we grouping all the data together we’re going to have a lot of ties (one team has to finish 1st in every league each year).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;all_data &amp;lt;- league_data %&amp;gt;%
  bind_rows()

#do a big correlation test
kendall_test &amp;lt;- cor.test(all_data$alph_order,
                         all_data$league_pos,
                         alternative = &amp;quot;two.sided&amp;quot;,
                         method = &amp;quot;kendall&amp;quot;) %&amp;gt;%
  tidy() %&amp;gt;%
  print()&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 1 x 5
##   estimate statistic p.value method                         alternative
##      &amp;lt;dbl&amp;gt;     &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;                          &amp;lt;chr&amp;gt;      
## 1   0.0135      1.74  0.0826 Kendall&amp;#39;s rank correlation tau two.sided&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we can see that, even though our p-value is &lt;a href=&#34;https://mchankins.wordpress.com/2013/04/21/still-not-significant-2/&#34;&gt;‘approaching significance’&lt;/a&gt;, it’s not significant at our fairly liberal threshold of 0.05. Even then, the effect size (0.013) is tiny, so there’s no need for Watford to start worrying &lt;a href=&#34;https://www.bbc.co.uk/sport/football/50619972&#34;&gt;just yet&lt;/a&gt;.&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;SMALL DIGRESSION: I love blogging on this site and it also has been a great help to me in numerous ways (practice coding/writing, feeling like a “programmer”, for job interviews), but quite a lot of the time feel posts are not quite where I want them (I’m sure this feeling isn’t restricted to me) and so won’t put them up and so that time (sometimes quite a few hours!) I put into them in my spare time feels wasted and makes me feel worse about myself. I’m hoping that pushing out fairly rushed/half formed ideas like this will help with this.&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;rd-december---groan-rangers&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;3rd December - Groan Rangers&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.theguardian.com/football/2019/jul/24/which-teams-were-managed-by-their-all-time-leading-goalscorer&#34;&gt;“Berwick Rangers have conceded 42 goals in competitive matches – Scottish League 2, relegation play-off, Scottish League – since last scoring themselves, against Peterhead, on March 19th. Is this a record for a league club (I know they’ve now lost that status, but all of these matches are league level competition)?” asks Huw Richards.&lt;/a&gt;&lt;/p&gt;
&lt;div id=&#34;answer---it-beats-any-team-in-the-english-league.-reproducible-code-below-if-you-want-to-check-for-other-leagues.&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Answer - It beats any team in the English league. Reproducible code below if you want to check for other leagues.&lt;/h2&gt;
&lt;p&gt;(I did check for most of them in the dataset, although this doesn’t include foreign cup competitions. Nothing seems to get close)&lt;/p&gt;
&lt;p&gt;This is quite a nice question from a data munging point of view. It’s extremely quantifiable and only involves a little grouping by.&lt;/p&gt;
&lt;p&gt;First we’ll load the libraries we’re relying on in this little project:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(engsoccerdata)
library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I’m going to focus on the English league as it has the most data and also has data on the concurrent cup competitions. It’s super easy to sub in whichever competitions in the engsoccerdata package you want.&lt;/p&gt;
&lt;p&gt;We want to first bind the data from the league, league cup, fa cup, and league playoffs together with a little munging. Then we want to gather the data to get the goals scored and goals conceded in each game for each team.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#bind all the match data together with relevant variables
scoring_data &amp;lt;- bind_rows(
  engsoccerdata::england %&amp;gt;%
    select(date = Date, tier, home, visitor, hgoal, vgoal) %&amp;gt;%
    mutate(date = as.Date(date),
           competition = &amp;quot;league&amp;quot;),
  engsoccerdata::facup %&amp;gt;%
    select(date = Date, home, visitor, hgoal, vgoal) %&amp;gt;%
    mutate(date = as.Date(date),
           tier = NA, 
           competition = &amp;quot;fa_cup&amp;quot;),
  engsoccerdata::leaguecup %&amp;gt;%
    select(date = Date, home, visitor, hgoal, vgoal) %&amp;gt;%
    mutate(date = as.Date(date),
           tier = NA,
           competition = &amp;quot;league_cup&amp;quot;),
  engsoccerdata::englandplayoffs %&amp;gt;%
    select(date = Date, home, visitor, hgoal, vgoal, htier, vtier) %&amp;gt;%
    mutate(date = as.Date(date), 
           tier = (htier+vtier)/2, 
           competition = &amp;quot;league_playoffs&amp;quot;) %&amp;gt;%
    select(-htier, -vtier),
) %&amp;gt;%
  #gather and find matches for each team
  gather(&amp;quot;location&amp;quot;, &amp;quot;team&amp;quot;, -date, -hgoal, -vgoal, -competition, -tier) %&amp;gt;%
  split(f = .$location) %&amp;gt;%
  map2_df(., rev(.), function(df, vs_data) 
    mutate(df, opponent = vs_data$team)
  ) %&amp;gt;%
  #add in goals for and against
  mutate(goals_for = case_when(
    location == &amp;quot;home&amp;quot; ~ hgoal,
    TRUE ~ vgoal
  )) %&amp;gt;%
  mutate(goals_against = case_when(
    location == &amp;quot;visitor&amp;quot; ~ hgoal,
    TRUE ~ vgoal
  )) %&amp;gt;%
  arrange(team, date) %&amp;gt;%
  group_by(team)

head(scoring_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 10
## # Groups:   team [1]
##   date        tier hgoal vgoal competition location team  opponent
##   &amp;lt;date&amp;gt;     &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   
## 1 1875-11-06    NA     0     0 fa_cup      home     105t~ Crystal~
## 2 1875-11-20    NA     3     0 fa_cup      visitor  105t~ Crystal~
## 3 1876-11-11    NA     3     0 fa_cup      home     105t~ 1st Sur~
## 4 1876-12-14    NA     6     1 fa_cup      visitor  105t~ Oxford ~
## 5 1877-11-07    NA     0     2 fa_cup      home     105t~ Old Har~
## 6 NA            NA    NA    NA fa_cup      visitor  105t~ Minerva 
## # ... with 2 more variables: goals_for &amp;lt;dbl&amp;gt;, goals_against &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we need to find the start of each run of games where a team has failed to score. We can do this by finding the first instance of 0 goals scored using lag(). We’ll then give an id to each ‘run’ of finishing games without scoring.&lt;/p&gt;
&lt;p&gt;(I’m aware that teams can also concede goals in a run having scored first in a match but there’s no way to factor that in with the data)&lt;/p&gt;
&lt;p&gt;We then use the na.locf() function from the very useful &lt;a href=&#34;https://cran.r-project.org/web/packages/zoo/zoo.pdf&#34;&gt;zoo&lt;/a&gt; package to fill in the runs where no goals have been scored.&lt;/p&gt;
&lt;p&gt;We can then finish answering the question (already!) by grouping by run and summing the total number of goals conceded in that time.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#load the zoo library for helping filling NA values
library(zoo)

dry_runs &amp;lt;- scoring_data %&amp;gt;%
  #find the start of runs
  mutate(run_start = case_when(
    goals_for == 0 &amp;amp; lag(goals_for, default = 1) != 0 ~ 1:n()
  )) %&amp;gt;%
  #only care about games where didn&amp;#39;t score
  filter(goals_for == 0) %&amp;gt;%
  #fill in NAs to get full runs
  mutate(run_id = na.locf(run_start, na.rm = FALSE)) 

longest_dry_runs &amp;lt;- dry_runs %&amp;gt;%
  #group runs by id
  group_by(run_id, team) %&amp;gt;%
  #find total conceeded over n games
  mutate(total_conceeded = sum(goals_against),
         run_start_date = min(date),
         matches = n()) %&amp;gt;%
  #take only the last instance
  filter(!duplicated(run_id, fromLast = TRUE)) %&amp;gt;%
  select(run_start_date, run_end_date = date, team, run_id, total_conceeded, matches) %&amp;gt;%
  #find the most &amp;#39;impressive&amp;#39; runs
  filter(total_conceeded &amp;gt; 15) %&amp;gt;%
  arrange(-total_conceeded)

head(longest_dry_runs)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
## # Groups:   run_id, team [6]
##   run_start_date run_end_date team           run_id total_conceeded matches
##   &amp;lt;date&amp;gt;         &amp;lt;date&amp;gt;       &amp;lt;chr&amp;gt;           &amp;lt;int&amp;gt;           &amp;lt;dbl&amp;gt;   &amp;lt;int&amp;gt;
## 1 1899-01-14     1899-03-11   Darwen            273              38       7
## 2 1898-11-12     1898-12-26   Darwen            263              35       7
## 3 1891-12-12     1892-01-09   Darwen             60              31       5
## 4 2019-04-09     2019-08-31   Bolton Wander~   5447              29      11
## 5 1877-12-22     1886-10-23   1st Surrey Ri~      8              27       3
## 6 1880-12-18     1894-01-27   Reading             6              27       3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And can see that two 7 game runs from the (now-defunct) &lt;a href=&#34;https://en.wikipedia.org/wiki/Darwen_F.C.&#34;&gt;Darwen FC&lt;/a&gt; are top of the list. Around 1898/1899 the team conceded 35 and 38 goals without scoring themselves.&lt;/p&gt;
&lt;p&gt;Manually &lt;a href=&#34;https://www.11v11.com/teams/darwen/tab/matches/season/1899/&#34;&gt;looking at the data&lt;/a&gt;, we can see that these two streaks are broken only by a few losses over Christmas 1898, a losing run of 18 games! Indeed, Darwen only won 2 games that season and set the record for most goals conceded (141).&lt;/p&gt;
&lt;p&gt;7 Years earlier, the same team managed an impressive run of letting in 31 goals in just 5 matches, without scoring. If we want to check out the game in this, we can do by left_join() ing our data together&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#joni data to inspect individual games
dry_run_matches &amp;lt;- dry_runs %&amp;gt;%
  left_join(longest_dry_runs, by = c(&amp;quot;team&amp;quot;, &amp;quot;run_id&amp;quot;)) %&amp;gt;%
  filter(!is.na(total_conceeded)) %&amp;gt;%
  select(date, team, opponent, goals_for, goals_against,
         competition, tier, total_conceeded, run_id) %&amp;gt;%
  arrange(-total_conceeded)

#print this
print(filter(dry_run_matches, run_id == 60))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 9
## # Groups:   team [1]
##   date       team  opponent goals_for goals_against competition  tier
##   &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 1891-12-12 Darw~ Sunderl~         0             7 league          1
## 2 1891-12-25 Darw~ Blackbu~         0             4 league          1
## 3 1891-12-26 Darw~ Aston V~         0             7 league          1
## 4 1892-01-01 Darw~ Preston~         0             4 league          1
## 5 1892-01-09 Darw~ Burnley          0             9 league          1
## # ... with 2 more variables: total_conceeded &amp;lt;dbl&amp;gt;, run_id &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Also, congratulations to the &lt;a href=&#34;https://www.boltonwanderers.news/news/efl-discinplinary-panels-decision-on-wanderers-delayed-again/&#34;&gt;oft-trouble Bolton Wanderers&lt;/a&gt; who have got closest to this in modern times, failing to score in 11 straight matches, while conceding 29 goals in the process.&lt;/p&gt;
&lt;p&gt;I also wanted to find out the opposite: the team that has scored the most goals without conceding any. It’s super easy with our pipeline- just switch goals_against and goals_for in the chain.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#do the inverse
scoring_runs &amp;lt;- scoring_data %&amp;gt;%
  mutate(run_start = case_when(
    goals_against == 0 &amp;amp; lag(goals_against, default = 1) != 0 ~ 1:n()
  )) %&amp;gt;%
  filter(goals_against == 0) %&amp;gt;%
  mutate(run_id = na.locf(run_start, na.rm = FALSE)) 

longest_scoring_runs &amp;lt;- scoring_runs %&amp;gt;%
  group_by(run_id, team) %&amp;gt;%
  mutate(total_scored = sum(goals_for),
         run_start_date = min(date),
         matches = n()) %&amp;gt;%
  filter(!duplicated(run_id, fromLast = TRUE)) %&amp;gt;%
  select(run_start_date, run_end_date = date, team, run_id, total_scored, matches) %&amp;gt;%
  filter(total_scored &amp;gt; 15) %&amp;gt;%
  arrange(-total_scored)

head(longest_scoring_runs)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 6
## # Groups:   run_id, team [6]
##   run_start_date run_end_date team            run_id total_scored matches
##   &amp;lt;date&amp;gt;         &amp;lt;date&amp;gt;       &amp;lt;chr&amp;gt;            &amp;lt;int&amp;gt;        &amp;lt;dbl&amp;gt;   &amp;lt;int&amp;gt;
## 1 2010-04-25     2010-08-28   Chelsea           4372           32       7
## 2 1929-03-06     1929-03-30   Bradford City      919           29       5
## 3 2019-01-06     2019-01-26   Manchester City   5194           28       6
## 4 1903-04-10     1903-10-03   Arsenal            328           26       8
## 5 1880-01-17     1880-11-13   Clapham Rovers      25           26       5
## 6 1885-10-24     1885-12-12   Notts County        32           26       3&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Where we can see that Chelsea’s impressive end to the 2009-2010 season puts them top, having scored 32 goals without reply. Almost all the other top examples are from pre-war football, except Manchester City coming close last year with 28 goals scored without conceding.&lt;/p&gt;
&lt;p&gt;When we look at this run we can see it was greatly helped along by some demolitions in the cups, winning 5-0, 9-0 and 7-0 against Burnley, Burton Albion, and Rotherham United.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;scoring_run_matches &amp;lt;- scoring_runs %&amp;gt;%
  left_join(longest_scoring_runs, by = c(&amp;quot;team&amp;quot;, &amp;quot;run_id&amp;quot;)) %&amp;gt;%
  filter(!is.na(total_scored)) %&amp;gt;%
  select(date, team, opponent, goals_for, goals_against,
         competition, tier, total_scored, run_id) %&amp;gt;%
  arrange(-total_scored)

#print this
print(filter(scoring_run_matches, run_id == 5194))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 9
## # Groups:   team [1]
##   date       team  opponent goals_for goals_against competition  tier
##   &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;        &amp;lt;dbl&amp;gt;         &amp;lt;dbl&amp;gt; &amp;lt;chr&amp;gt;       &amp;lt;dbl&amp;gt;
## 1 2019-01-06 Manc~ Rotherh~         7             0 fa_cup         NA
## 2 2019-01-09 Manc~ Burton ~         9             0 league_cup     NA
## 3 2019-01-14 Manc~ Wolverh~         3             0 league          1
## 4 2019-01-20 Manc~ Hudders~         3             0 league          1
## 5 2019-01-23 Manc~ Burton ~         1             0 league_cup     NA
## 6 2019-01-26 Manc~ Burnley          5             0 fa_cup         NA
## # ... with 2 more variables: total_scored &amp;lt;dbl&amp;gt;, run_id &amp;lt;int&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;th-december---were-going-to-wembley&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;5th December - We’re going to Wembley&lt;/h1&gt;
&lt;blockquote class=&#34;twitter-tweet&#34;&gt;
&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;
Which team has had to travel the shortest combined distance in a cup run? (excluding regional competitions, just to make it interesting)
&lt;/p&gt;
— Chris van Thomas (&lt;span class=&#34;citation&#34;&gt;@chrisvanthomas&lt;/span&gt;) &lt;a href=&#34;https://twitter.com/chrisvanthomas/status/1148879896430731266?ref_src=twsrc%5Etfw&#34;&gt;July 10, 2019&lt;/a&gt;
&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;
&lt;div id=&#34;answer---multiple-teams-have-played-5-fa-cup-matches-all-at-home.-to-answer-the-inverse-question-queens-park-in-18831884-and-18841885-have-had-the-farthest-to-travel&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Answer - Multiple teams have played 5 FA cup matches all at home. To answer the inverse question, Queen’s Park in 1883/1884 and 1884/1885 have had the farthest to travel&lt;/h2&gt;
&lt;p&gt;For this question, I’m actually going to answer the opposite topic- which team have traveled the farthest in a cup run? The reason being is that multiple teams have had cup runs (of 5 matches in the FA cup) without travelling away from home at all. The code below could easily be changed to analyse other cup competitions, for simplicity, I’m sticking with the FA cup which has the most complete data in the engsoccerdata set.&lt;/p&gt;
&lt;p&gt;Once again, we’ll start by loading libraries. We also want the &lt;a href=&#34;https://r-spatial.github.io/sf/articles/sf1.html&#34;&gt;sf&lt;/a&gt; package that makes working with spatial data a bit cleaner.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(engsoccerdata)
library(tidyverse)
#also want sf to manipulate spatial features
library(sf)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we want to grab the data. In a &lt;a href=&#34;https://github.com/jalapic/engsoccerdata/commit/6133cf9f6fd77574a5a03097a6d2db4d213c508c&#34;&gt;recent update of the engsoccerdata package&lt;/a&gt; I added the location of grounds for teams in England which will let us find the distances teams have traveled to matches.&lt;/p&gt;
&lt;p&gt;I also download a shapefile of the UK from &lt;a href=&#34;https://gadm.org/&#34;&gt;GADM&lt;/a&gt; for plotting and to filter out any bad data in ground location (which still is very much in beta).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#download a map of the uk to plot with
shape_url &amp;lt;- &amp;quot;https://biogeo.ucdavis.edu/data/gadm3.6/Rsf/gadm36_GBR_0_sf.rds&amp;quot;
temp_dir &amp;lt;- tempdir()
download.file(shape_url, destfile = file.path(temp_dir, &amp;quot;shapefiles.rds&amp;quot;), mode = &amp;quot;wb&amp;quot;)
uk &amp;lt;- st_as_sf(readRDS(file.path(temp_dir, &amp;quot;shapefiles.rds&amp;quot;)))

#the location of football grounds in the dataset
grounds &amp;lt;- engsoccerdata::england_locations %&amp;gt;%
  st_as_sf(coords = c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;), crs = st_crs(&amp;quot;+init=epsg:4326&amp;quot;)) %&amp;gt;%
  st_transform(crs = st_crs(uk)) %&amp;gt;%
  #remove those that are bad data-outside the uk
  .[seq(nrow(.)) %in% unlist(st_contains(uk, .)),]
#get the fa cup match data
matches &amp;lt;- engsoccerdata::facup&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There’s some ambiguity in the question as to how the distance of a cup run should be measured. There’s really two ways we can do this, which I will henceforth refer to as a ‘routing’ as ‘spoking’. To illustrate the two different approaches, I’ll use Southampton’s 2017/2018 FA cup run&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#e.g. with Southampton&amp;#39;s semi final run in 2017/2018
Southampton &amp;lt;- matches %&amp;gt;%
    filter(Season == 2017 &amp;amp; 
             (home == &amp;quot;Southampton&amp;quot; | 
                visitor == &amp;quot;Southampton&amp;quot;)
           ) %&amp;gt;%
  select(Venue, Date, home, visitor, neutral) %&amp;gt;%
  gather(&amp;quot;location&amp;quot;, &amp;quot;team&amp;quot;, -Venue, -Date, -neutral) %&amp;gt;%
  filter(location == &amp;quot;home&amp;quot; | neutral == &amp;quot;yes&amp;quot;) %&amp;gt;%
  filter(!duplicated(Date)) %&amp;gt;%
  mutate(location = case_when(
    neutral == &amp;quot;yes&amp;quot; ~ Venue,
    TRUE ~ team
  ))

#print matches
Southampton&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 5 x 5
##   Venue            Date       neutral location           team              
##   &amp;lt;chr&amp;gt;            &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt;              &amp;lt;chr&amp;gt;             
## 1 Craven Cottage   2018-01-06 &amp;lt;NA&amp;gt;    Fulham             Fulham            
## 2 St Mary&amp;#39;s Stadi~ 2018-01-27 &amp;lt;NA&amp;gt;    Southampton        Southampton       
## 3 The Hawthorns    2018-02-17 &amp;lt;NA&amp;gt;    West Bromwich Alb~ West Bromwich Alb~
## 4 DW Stadium       2018-03-18 &amp;lt;NA&amp;gt;    Wigan Athletic     Wigan Athletic    
## 5 Wembley Stadium  2018-04-22 yes     Wembley Stadium    Chelsea&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’ll join the ground geography data to this to figure out distances traveled&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#will need the location of southamptons ground
Southampton_home &amp;lt;- grounds %&amp;gt;%
  filter(location == &amp;quot;Southampton&amp;quot;)
#and the locations of all their matches
match_locations &amp;lt;- Southampton %&amp;gt;%
  left_join(., select(grounds, location, geometry), by = &amp;quot;location&amp;quot;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first method of calculating distance traveled per match (‘spoking’) takes the location of each match, and finds the distance from that team’s home ground. E.g. for Southampton:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find the line from southampton&amp;#39;s ground to the match location
spoke_lines &amp;lt;- st_coordinates(match_locations$geometry) %&amp;gt;%
  split(f = rownames(.)) %&amp;gt;%
  #create line from geometry1 to geometry2
  lapply(function(x) {
    mat &amp;lt;- rbind(x, st_coordinates(Southampton_home$geometry))
    line &amp;lt;- st_linestring(mat)
    return(line)
  }) %&amp;gt;%
  #cast to multiline and add projection
  st_multilinestring() %&amp;gt;%
  st_sfc(crs = st_crs(&amp;quot;+init=epsg:4326&amp;quot;))

#plot over uk
p &amp;lt;- ggplot() +
  geom_sf(data = uk) +
  geom_sf(data = spoke_lines, colour = &amp;quot;blue&amp;quot;, size = 1.5) +
  theme_minimal()

plot(p)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-01-advent_calendar_knowledge_files/figure-html/southampton_spokes-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get the total length in metres
st_length(spoke_lines)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 698614.6 [m]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;For any home games, the distance traveled is taken to be 0m.&lt;/p&gt;
&lt;p&gt;The second method of calculating distance traveled takes the distance from each match &lt;em&gt;to&lt;/em&gt; the next match in run. I.e. it assumes a team stays in their past location until the next round (obviously not true in real life) and finds the distance to the ground for the next round game:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#need coords separate
coords &amp;lt;- st_coordinates(match_locations$geometry) %&amp;gt;%
  split(f = rownames(.))

#find distance from one coords to next
travel_lines &amp;lt;- mapply(coords, lead(coords), FUN = function(x, y) {
  #for last match no further path
  if(is.na(y)) {
    return(NULL)
  } else {
    mat &amp;lt;- rbind(x, y)
    line &amp;lt;- st_linestring(mat)
    return(line)
  }
}) %&amp;gt;%
  #filter null last element
  .[-which(lengths(.) == 0)] %&amp;gt;%
  st_multilinestring() %&amp;gt;%
  st_sfc(crs = st_crs(&amp;quot;+init=epsg:4326&amp;quot;))

#plot over uk
p &amp;lt;- ggplot() +
  geom_sf(data = uk) +
  geom_sf(data = travel_lines, colour = &amp;quot;blue&amp;quot;, size = 1.5) +
  theme_minimal()

plot(p)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-01-advent_calendar_knowledge_files/figure-html/southampton_travel-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get the length
st_length(travel_lines)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 684586.7 [m]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So Southampton here begin in London away to Fulham, before travelling to their home in Southampton, then on to Birmingham (West Brom), Wigan, and back to London to play at Wembley.&lt;/p&gt;
&lt;p&gt;Now we have the two methods, we need to prep the data we’re going to analyse. As before, this is done by gathering a df of match data so we have one row per match per team in the FA cup. We then group by team-season’s and find how many matches they played in the cup that year. For a ‘cup run’ we assume more than 3 matches have to played.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#gather each match per team into a separate row
long_campaigns &amp;lt;- matches %&amp;gt;%
  filter(!is.na(Date)) %&amp;gt;%
  select(Season, home, visitor) %&amp;gt;%
  gather(&amp;quot;location&amp;quot;, &amp;quot;team&amp;quot;, -Season) %&amp;gt;%
  #remove rows with missing teams
  filter(!is.na(team)) %&amp;gt;%
  #get the number of fa cup matches per season per team
  group_by(team, Season) %&amp;gt;%
  summarise(matches = n()) %&amp;gt;%
  #assume you need at least 3 matches for a &amp;#39;run&amp;#39;
  filter(matches &amp;gt; 3) %&amp;gt;%
  ungroup() %&amp;gt;%
  arrange(Season) %&amp;gt;%
  mutate(id = 1:n())

long_campaign_matches &amp;lt;- matches %&amp;gt;%
  select(., Season, Date, round, 
         neutral, Venue,
         team = home, opponent = visitor) %&amp;gt;%
  mutate(location = &amp;quot;home&amp;quot;) %&amp;gt;%
  #bind in the opposite data for away teams
  bind_rows(., mutate(select(., Season, Date, round,
                             neutral, Venue,
                             team = opponent, opponent = team),
                      location = &amp;quot;away&amp;quot;)) %&amp;gt;%
  filter(!is.na(team)) %&amp;gt;%
  #left join the data for long campaigns
  left_join(., long_campaigns, by = c(&amp;quot;Season&amp;quot;, &amp;quot;team&amp;quot;)) %&amp;gt;%
  #remove non-long campaigns
  filter(!is.na(matches)) %&amp;gt;%
  #get the location of the match
  mutate(location = case_when(
    neutral == &amp;quot;yes&amp;quot; ~ Venue,
    location == &amp;quot;home&amp;quot; ~ team,
    location == &amp;quot;away&amp;quot; ~ opponent,
  )) %&amp;gt;%
  #left join in the location for the corresponding ground
  left_join(grounds, c(&amp;quot;location&amp;quot;)) %&amp;gt;%
  #select columns
  select(season = Season, date = Date, round, 
         neutral, team, opponent, 
         location, matches, id, geometry)

#print 
head(long_campaign_matches)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 10
##   season date       round neutral team  opponent location matches    id
##    &amp;lt;dbl&amp;gt; &amp;lt;date&amp;gt;     &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;   &amp;lt;chr&amp;gt; &amp;lt;chr&amp;gt;    &amp;lt;chr&amp;gt;      &amp;lt;int&amp;gt; &amp;lt;int&amp;gt;
## 1   1871 1871-12-16 2     &amp;lt;NA&amp;gt;    Crys~ Maidenh~ Crystal~       5     1
## 2   1871 1871-12-16 2     &amp;lt;NA&amp;gt;    Wand~ Clapham~ Wandere~       4     3
## 3   1871 1872-01-20 3     &amp;lt;NA&amp;gt;    Wand~ Crystal~ Wandere~       4     3
## 4   1871 1872-01-27 3     &amp;lt;NA&amp;gt;    Roya~ Hampste~ Royal E~       5     2
## 5   1871 1872-02-17 s     yes     Crys~ Royal E~ Kenning~       5     1
## 6   1871 1872-03-09 s     yes     Roya~ Crystal~ Kenning~       5     2
## # ... with 1 more variable: geometry &amp;lt;POINT [°]&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then find the routing distance using a nice trick I found on &lt;a href=&#34;https://github.com/r-spatial/sf/issues/799&#34;&gt;Stack Overflow&lt;/a&gt; to find the distance between each location and the next in the data.frame.&lt;/p&gt;
&lt;p&gt;Finally, this is grouped by id and summed to get the total distance traveled in that cup campaign (when judging by the ‘routing’ metric).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#taken from
#https://github.com/r-spatial/sf/issues/799
#init an empty sfc
empty &amp;lt;- st_as_sfc(&amp;quot;POINT(EMPTY)&amp;quot;)
routing_distances &amp;lt;- long_campaign_matches %&amp;gt;%
  arrange(id, date) %&amp;gt;%
  filter(!is.na(date)) %&amp;gt;%
  group_by(id) %&amp;gt;%
  #find the distance from one game to the next
  mutate(
    distance_to_next = sf::st_distance(
      geometry, 
      lag(geometry, default = empty), 
      by_element = TRUE)
    ) 

#sum the distances
grouped_routing_distances &amp;lt;- routing_distances %&amp;gt;%
  summarise(travel_distance = sum(distance_to_next, na.rm = TRUE)) %&amp;gt;%
  merge(long_campaigns, by = &amp;quot;id&amp;quot;) %&amp;gt;%
  #conver to km
  mutate(total_distance = travel_distance / 1000) %&amp;gt;%
  select(id, team, matches, season = Season, total_distance) %&amp;gt;%
  mutate(av_distance = total_distance / matches) %&amp;gt;%
  arrange(-total_distance)

head(grouped_routing_distances)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##     id             team matches season total_distance av_distance
## 1  111      Queens Park       8   1884       2684.363    335.5454
## 2  668      Exeter City       8   1930       2362.073    295.2592
## 3  293 Newcastle United       8   1904       2316.524    289.5655
## 4  512 Newcastle United       9   1923       2112.232    234.6924
## 5 1182 Newcastle United      10   1954       2017.824    201.7824
## 6 1090        Gateshead       8   1951       2015.698    251.9623&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;By functionalising our code from earlier, we can easily plot these well-traveled runs. Using the recently-added-to-CRAN &lt;a href=&#34;https://github.com/thomasp85/patchwork&#34;&gt;patchwork&lt;/a&gt; package, we can make multiple plots and stitch them together, e.g. for the 6 FA cup runs with the longest distances traveled we get:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#functionalise our code from earlier to plot travel routes easier
plot_travel_lines &amp;lt;- function(run_team_year, plot_type) {
  run_matches &amp;lt;- long_campaign_matches %&amp;gt;%
    mutate(id = paste(team, season)) %&amp;gt;%
    filter(id == run_team_year) %&amp;gt;%
    arrange(date)
  coords &amp;lt;- st_coordinates(run_matches$geometry) %&amp;gt;%
    split(f = rownames(.))
  if(plot_type == &amp;quot;travel&amp;quot;) {
    lines &amp;lt;- mapply(coords, lead(coords), FUN = function(x, y) {
    if(is.na(y)) {
      return(NULL)
    } else {
      mat &amp;lt;- rbind(x, y)
      line &amp;lt;- st_linestring(mat)
      return(line)
    }
    }) %&amp;gt;%
    .[-which(lengths(.) == 0)] %&amp;gt;%
    st_multilinestring() %&amp;gt;%
    st_sfc(crs = st_crs(&amp;quot;+init=epsg:4326&amp;quot;))
  } else if(plot_type == &amp;quot;spokes&amp;quot;) {
    home &amp;lt;- grounds %&amp;gt;%
      filter(location == unique(run_matches$team)) %&amp;gt;%
      st_coordinates()
    lines &amp;lt;- lapply(coords, function(x) {
      mat &amp;lt;- rbind(x, home)
      line &amp;lt;- st_linestring(mat)
      return(line)
    }) %&amp;gt;%
      #cast to multiline and add projection
      st_multilinestring() %&amp;gt;%
      st_sfc(crs = st_crs(&amp;quot;+init=epsg:4326&amp;quot;))
  }
  plot &amp;lt;- ggplot() +
    geom_sf(data = uk) +
    geom_sf(data = lines, colour = &amp;quot;blue&amp;quot;, size = 1.5) +
    labs(title = paste(run_team_year)) +
    theme_minimal()
  return(plot)
}

#plot the top six
library(patchwork)
paste(grouped_routing_distances$team[1:6],
      grouped_routing_distances$season[1:6]) %&amp;gt;%
  lapply(., plot_travel_lines, plot_type = &amp;quot;travel&amp;quot;) %&amp;gt;%
  wrap_plots(.)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-01-advent_calendar_knowledge_files/figure-html/plot_run_travel-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We then need to check this against our other method of evaluating distances in a cup run- the ‘spoking’ method. This is much easier to calculate- all we have to do is left_join() in the location for each team’s home ground, and find the distance between this and the match location.&lt;/p&gt;
&lt;p&gt;Then we simply sum the total distances per campaign and plot the longest of these:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;spoke_distances &amp;lt;- long_campaign_matches %&amp;gt;%
  #left join in location data for each team
  left_join(grounds, by = c(&amp;quot;team&amp;quot; = &amp;quot;location&amp;quot;)) %&amp;gt;%
  #calculate distance between each teams home ground and the match location
  mutate(distance = st_distance(geometry.x, geometry.y, by_element = TRUE))

#group by and sum the cup run distances
grouped_spoke_distances &amp;lt;- spoke_distances %&amp;gt;%
  group_by(team, season) %&amp;gt;%
  summarise(total_distance = sum(distance/1000, na.rm = TRUE),
            av_distance = mean(distance/1000, na.rm = TRUE)) %&amp;gt;%
  arrange(-total_distance)

#print
head(grouped_spoke_distances)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 4
## # Groups:   team [3]
##   team             season total_distance av_distance
##   &amp;lt;chr&amp;gt;             &amp;lt;dbl&amp;gt;            [m]         [m]
## 1 Queens Park        1883       2150.504    307.2149
## 2 Newcastle United   1923       1974.430    219.3811
## 3 Newcastle United   1951       1957.196    279.5994
## 4 Fulham             1974       1810.676    150.8897
## 5 Newcastle United   1973       1781.279    178.1279
## 6 Queens Park        1884       1702.166    170.2166&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plot
paste(grouped_spoke_distances$team[1:6],
      grouped_spoke_distances$season[1:6]) %&amp;gt;%
  lapply(., plot_travel_lines, plot_type = &amp;quot;spokes&amp;quot;) %&amp;gt;%
  wrap_plots(.)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-01-advent_calendar_knowledge_files/figure-html/find_spoke_distances-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;th-december---this-town-aint-big-enough-for-a-league-football-team&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;10th December - This Town Ain’t Big Enough For a League Football Team&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://www.theguardian.com/football/2003/may/29/theknowledge.sport&#34;&gt;“What’s the largest town/city without a League club? I reckon Maidstone takes some beating (population 139,000 - about the same as Blackburn). Unlike Blackburn Rovers, Maidstone United play in the Kent League (of course Blackburn would not actually be eligible) which is some way below the Conference and Dr Martins Leagues. But being Maidstone United of course they play all their fixtures 12 miles away in Sittingbourne,” writes Peter Driver. IN 2003&lt;/a&gt;&lt;/p&gt;
&lt;div id=&#34;answer--&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Answer -&lt;/h2&gt;
&lt;p&gt;To answer this question, first we need data on towns and cities in England. We’re going to rank by population so can download the population table found &lt;a href=&#34;http://lovemytown.co.uk/populations/TownsTable1.asp&#34;&gt;here&lt;/a&gt; to start with&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#scrape data on town/city ppulations in UK
pops &amp;lt;- &amp;quot;http://lovemytown.co.uk/populations/TownsTable1.asp&amp;quot; %&amp;gt;%
  read_html() %&amp;gt;%
  html_nodes(&amp;quot;#mainContent &amp;gt; table:nth-child(3)&amp;quot;) %&amp;gt;%
  html_table(fill = TRUE, header = TRUE) %&amp;gt;%
  as.data.frame() %&amp;gt;%
  #some munging to match datasets later
  mutate(tcity15nm = case_when(
    grepl(&amp;quot;^St\\. &amp;quot;, Town) ~ gsub(&amp;quot;^St\\. &amp;quot;, &amp;quot;St &amp;quot;, Town),
    grepl(&amp;quot;^Hull$&amp;quot;, Town) ~ &amp;quot;Kingston upon Hull&amp;quot;,
    grepl(&amp;quot;^Burton$&amp;quot;, Town) ~ &amp;quot;Burton upon Trent&amp;quot;,
    grepl(&amp;quot;^Newcastle$&amp;quot;, Town) ~ &amp;quot;Newcastle upon Tyne&amp;quot;,
    grepl(&amp;quot;^Southend$&amp;quot;, Town) ~ &amp;quot;Southend-on-Sea&amp;quot;,
    grepl(&amp;quot;^Stoke$&amp;quot;, Town) ~ &amp;quot;Stoke-on-Trent&amp;quot;,
    TRUE ~ Town
  )) %&amp;gt;%
  #convert population to numeric
  mutate(population = as.numeric(gsub(&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;, Population))) %&amp;gt;%
  select(tcity15nm, population, status = Status)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We’re then going to want the geographic data on these towns. The UK government provides shapefiles for the outlines of ‘Major Towns and Cities’ from a few years ago which should be sufficient for the question. They’re provided as geoJSON files so I’m going to use the geojsonsf package to load them straight as sf objects.&lt;/p&gt;
&lt;p&gt;To reproduce this script, you’ll need to download the data from the &lt;a href=&#34;https://data.gov.uk/dataset/7879ab82-2863-401e-8a29-a56e264d2182/major-towns-and-cities-december-2015-boundaries&#34;&gt;UK government achives&lt;/a&gt; and point the file object towards it&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#to read in geojson data as an sf file
library(geojsonsf)

#download the shapefile from
#https://data.gov.uk/dataset/7879ab82-2863-401e-8a29-a56e264d2182/major-towns-and-cities-december-2015-boundaries
file &amp;lt;- &amp;quot;path/to/downloaded/file.geojson&amp;quot;
#load data
towns &amp;lt;- geojson_sf(file) %&amp;gt;%
  left_join(., pops, by = &amp;quot;tcity15nm&amp;quot;) %&amp;gt;%
  st_transform(st_crs(27700)) %&amp;gt;%
  #buff the town shapefiles by 2.5km to catch all clubs within
  #reasonable distance of the town
  st_buffer(., 2500)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we want the club data. In the latest release of &lt;a href=&#34;https://github.com/jalapic/engsoccerdata/pull/61&#34;&gt;engsoccer data&lt;/a&gt; I added some (very beta) non-league data so we have a greater number of teams to pick from. We’ll take the league the team played in in 2018 as this on league data hasn’t been updated to 2019 (the current season) yet.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get all league and non-league clubs
#non league clubs in new release of engsoccerdata
clubs &amp;lt;- rbind(
  select(england, home, Season, tier), 
  select(england_nonleague, home, Season, tier)) %&amp;gt;%
  #no 2019 data for non league yet
  filter(Season == 2018) %&amp;gt;%
  select(home, tier) %&amp;gt;%
  unique()

#get the locations of each of these clubs in
club_locations &amp;lt;- england_club_data %&amp;gt;%
  st_as_sf(coords = c(&amp;quot;lon&amp;quot;, &amp;quot;lat&amp;quot;), crs = st_crs(4326)) %&amp;gt;%
  #on uk grid projection
  st_transform(st_crs(27700)) %&amp;gt;%
  left_join(., clubs, by = c(&amp;quot;team&amp;quot; = &amp;quot;home&amp;quot;)) %&amp;gt;%
  select(team, tier) %&amp;gt;%
  filter(!is.na(tier))

#plot these clubs over major towns in uk
p_town_clubs &amp;lt;- ggplot() +
  geom_sf(data = uk) +
  geom_sf(data = towns, fill = &amp;quot;red&amp;quot;) +
  geom_sf(data = club_locations, alpha = 0.15, colour = &amp;quot;blue&amp;quot;) +
  labs(title = &amp;quot;location of English football teams relative to major towns&amp;quot;) +
  theme_minimal()

p_town_clubs&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-01-advent_calendar_knowledge_files/figure-html/towns_get_clubs-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;We can then run a very quick function to find the clubs that are location within each town using sf::st_contains and arrange by our parameters to answer the question!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to find which towns contain clubs
town_data &amp;lt;- st_contains(towns, club_locations) %&amp;gt;%
  map_df(., function(x) {
    n_clubs &amp;lt;- length(x)
    if(n_clubs == 0) {
      max_tier &amp;lt;- NA
      tiers &amp;lt;- NA
    } else {
      #get the tiers of the english footballing pyramid that clubs play in
      tiers &amp;lt;- I(list(club_locations$tier[x]))
      max_tier &amp;lt;- min(club_locations$tier[x])
    }
    return(data.frame(n_clubs,
                      max_tier,
                      tiers))
  }) %&amp;gt;%
  #bind to the town data
  bind_cols(towns, .) %&amp;gt;%
  select(town = tcity15nm, pop = population, n_clubs, max_tier) %&amp;gt;%
  #arrange to answer question
  arrange(n_clubs, -max_tier, -pop)

#get rid of unnessecary geometry
st_geometry(town_data) &amp;lt;- NULL

#print answer
head(town_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##               town    pop n_clubs max_tier
## 1       Gloucester 136362       0       NA
## 2      Basingstoke 107355       0       NA
## 3        Worcester 100153       0       NA
## 4 Stockton-on-Tees  82729       0       NA
## 5        Guildford  77057       0       NA
## 6 Sutton Coldfield 109015       1        8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So it appears Gloucester, Worcester and Basingstoke are the largest towns without a football club in their city limits. We can double check this using a quick grep function for the clubs (it’s possible this could miss some clubs but is probably accurate enough)&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;empty_towns &amp;lt;- c(&amp;quot;Gloucester&amp;quot;, &amp;quot;Basingstoke&amp;quot;, &amp;quot;Worcester&amp;quot;, &amp;quot;Stockton&amp;quot;, &amp;quot;Guildford&amp;quot;)

lapply(empty_towns, grep, x = clubs$home) %&amp;gt;%
  unlist() %&amp;gt;%
  clubs$home[.]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] &amp;quot;Gloucester City&amp;quot;  &amp;quot;Basingstoke Town&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So we can see that Gloucester and Basingstoke &lt;em&gt;do&lt;/em&gt; in fact have football teams, however a quick Wikipedia search shows that &lt;a href=&#34;https://en.wikipedia.org/wiki/Gloucester_City_A.F.C.&#34;&gt;they&lt;/a&gt; &lt;a href=&#34;https://en.wikipedia.org/wiki/Basingstoke_Town_F.C.&#34;&gt;both&lt;/a&gt; play outside their town (so I’m not sure if these count). The largest town* without a football team, down to the 8th tier of English football, is therefore Worcester with 100,000 people, but a team only in the &lt;a href=&#34;https://en.wikipedia.org/wiki/Worcester_City_F.C.&#34;&gt;9th tier&lt;/a&gt; of the football pyramid.&lt;/p&gt;
&lt;p&gt;The question actually does specify &lt;em&gt;‘League’&lt;/em&gt; teams, which generally only refers to the top 4 flights on English football. We can then run the function for each tier, finding the largest town without a team in that tier or above.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find the largest town without a club above tiers 5:8
by_tier &amp;lt;- lapply(4:7, function(x) {
    data &amp;lt;- town_data %&amp;gt;%
      filter(!is.na(max_tier) &amp;amp; max_tier &amp;gt; x) %&amp;gt;%
      arrange(-pop)
  })

#print by max tier
lapply(by_tier, head, n = 5)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [[1]]
##         town    pop n_clubs max_tier
## 1   Coventry 325949       1        7
## 2 Warrington 165456       1        7
## 3     Slough 155298       2        5
## 4      Poole 154718       2        7
## 5       York 152841       1        6
## 
## [[2]]
##         town    pop n_clubs max_tier
## 1   Coventry 325949       1        7
## 2 Warrington 165456       1        7
## 3      Poole 154718       2        7
## 4       York 152841       1        6
## 5    Telford 142723       1        6
## 
## [[3]]
##               town    pop n_clubs max_tier
## 1         Coventry 325949       1        7
## 2       Warrington 165456       1        7
## 3            Poole 154718       2        7
## 4         Worthing 109120       1        7
## 5 Sutton Coldfield 109015       1        8
## 
## [[4]]
##               town    pop n_clubs max_tier
## 1 Sutton Coldfield 109015       1        8
## 2         Basildon 107123       2        8
## 3        St Helens 102885       1        8
## 4        Wakefield  99251       1        8
## 5         Hastings  91053       1        8&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And the City of Coventry takes it, having a population of 325,000 and a team only in the 7th tier (&lt;a href=&#34;https://en.wikipedia.org/wiki/Bedworth_United_F.C.&#34;&gt;Bedworth United, who play just outside the city&lt;/a&gt;). This is only because the city’s main team &lt;a href=&#34;https://en.wikipedia.org/wiki/Coventry_City_F.C.&#34;&gt;Coventry City&lt;/a&gt; are playing in Birmingham due to &lt;a href=&#34;https://en.wikipedia.org/wiki/Coventry_City_F.C.#St_Andrew&amp;#39;s&#34;&gt;ongoing difficulties finding a stadium within their own city&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I think in the spirit of the question, the true answer is one of Warrington (165k), Poole (154k), York (152k), of Telford (142k). Of which York is probably the most major and independent as a town/city.&lt;/p&gt;
&lt;p&gt;Finally the article in which the question was shared posted the follow-up: what is the smallest town to hold a league club?&lt;/p&gt;
&lt;p&gt;We can answer this using the directory of population places produced by the &lt;a href=&#34;https://github.com/alasdairrae/gb-places&#34;&gt;Ordnance Survey&lt;/a&gt;. Again, download the .csv and point the script at it to reproduce.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#load the .csv of small places in the uk
small_places &amp;lt;- read.csv(&amp;quot;path/to.csv&amp;quot;, stringsAsFactors = FALSE) %&amp;gt;%
  #only interested in England
  filter(COUNTRY == &amp;quot;England&amp;quot;) %&amp;gt;%
  select(name = NAME1, x = X, y = Y) %&amp;gt;%
  st_as_sf(coords = c(&amp;quot;x&amp;quot;, &amp;quot;y&amp;quot;), crs = st_crs(27700)) %&amp;gt;%
  #find small places outside of the large towns
  .[-unique(unlist(st_contains(towns, .))),] %&amp;gt;%
  #buffer by 500m
  st_buffer(., 100)&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plot these for a cool map
plot(select(small_places))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-12-01-advent_calendar_knowledge_files/figure-html/plot_small_places-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;It’s then simple to find the small places to hold football clubs using sf::st_contains and indexing&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find clubs that are in these remaining places
small_town_clubs &amp;lt;- st_contains(small_places, filter(club_locations, tier &amp;lt; 5))
small_places[which(lengths(small_town_clubs) &amp;gt; 0),]&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Simple feature collection with 6 features and 1 field
## geometry type:  POLYGON
## dimension:      XY
## bbox:           xmin: 351959.9 ymin: 116300 xmax: 391793 ymax: 430665
## epsg (SRID):    27700
## proj4string:    +proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 +ellps=airy +towgs84=446.448,-125.157,542.06,0.15,0.247,0.842,-20.489 +units=m +no_defs
##             name                       geometry
## 3454    Laneside POLYGON ((376361 429724, 37...
## 3474     Enfield POLYGON ((375759 430165, 37...
## 8843   Moss Lane POLYGON ((391793 371719, 39...
## 17646 Houndstone POLYGON ((353128 117093.1, ...
## 17691     Lufton POLYGON ((352959.9 116800, ...
## 19419  Newmarket POLYGON ((384471.3 199698.6...&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Enfield and Moss Lane are in London and Manchester, so don’t count. Houndstone and Lufton are actually in the same town (Yeovil) but still are valid answers.&lt;/p&gt;
&lt;p&gt;Laneside is located just outside Accrington, where &lt;a href=&#34;https://en.wikipedia.org/wiki/Accrington_Stanley_F.C.&#34;&gt;Accrington Stanley&lt;/a&gt; play in the third tier (population 35,000).&lt;/p&gt;
&lt;p&gt;Yeovil (population 45,000) is home to &lt;a href=&#34;https://en.wikipedia.org/wiki/Yeovil_Town_F.C.&#34;&gt;Yeovil Town&lt;/a&gt; who play in the 4th tier.&lt;/p&gt;
&lt;p&gt;But the far and away winner is 4th tier &lt;a href=&#34;https://en.wikipedia.org/wiki/Forest_Green_Rovers_F.C.&#34;&gt;Forest Green Rovers&lt;/a&gt; who play in Nailsworth, with a population of just 5,700 people. Even more, the only remotely near town, Stroud, has a population of just 32,000 people. Most incredible of all, &lt;a href=&#34;https://en.wikipedia.org/wiki/The_New_Lawn&#34;&gt;the stadium for Forest Green Rovers&lt;/a&gt; can hold ~5,000 people, or almost the entire surrounding population.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>R-inforcement Learning Part One- Tic Tac Toe</title>
      <link>/post/r-inforcement_learning_one/</link>
      <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/r-inforcement_learning_one/</guid>
      <description>


&lt;p&gt;I’m extremely biased, but to me, one of the real success* stories in neuroscience over the last (just over) two decades has been in studying reward signals. Since the &lt;a href=&#34;https://www.ncbi.nlm.nih.gov/pubmed/9054347&#34;&gt;seminal 1997 paper&lt;/a&gt;, a lot of work has gone into figuring out how the brain assigns value to outcomes.&lt;/p&gt;
&lt;p&gt;*ugh, maybe. This isn’t a blog post about that&lt;/p&gt;
&lt;p&gt;My PhD project looks at novel ways of eliciting valuation behaviour to study these signals, but as a key part of the modelling involved in this work, it’s important to get a handle on &lt;a href=&#34;https://en.wikipedia.org/wiki/Reinforcement_learning&#34;&gt;reinforcement learning&lt;/a&gt;. When originally working through the &lt;a href=&#34;http://incompleteideas.net/book/the-book.html&#34;&gt;Sutton and Barto books&lt;/a&gt;, I threw together some code a few years ago for the problem sets- mostly in python and MATLAB. As someone who runs a blog nominally about coding in R, however, I thought there might be some value in going through said code and refactoring into R. As R can struggle with the speed necessary for reinforcement learning (which typically relies on large numbers of iterating behaviour), it also provided a good chance to crack out some C++ code using the always excellent &lt;a href=&#34;http://adv-r.had.co.nz/Rcpp.html&#34;&gt;Rcpp package&lt;/a&gt;, which is always worth practicing.&lt;/p&gt;
&lt;p&gt;In this first example of Reinforcement Learning in R (and C++), we’re going to train our computers to play Noughts and Crosses (or tic tac toe for Americans) to at least/super human level.&lt;/p&gt;
&lt;p&gt;Let’s get started with the libraries we’ll need. I want to stick to base for speed here, as well as obviously Rcpp. In theory you can easily generalise all the code here to any size board, but I only have tested in with 3x3 boards so YMMV.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#will use ggplot
#everything else Ive used base of listed packages
library(ggplot2)
#Rcpp for some vroom vroom
library(Rcpp)

#in theory this stuff should work for boards of any size
#but I haven&amp;#39;t tested that
board_cols = 3
board_rows = 3
squares &amp;lt;- board_cols * board_rows&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The very first thing we’ll want to do is find a way to store the information in a game state and convert between this, and a human readable form.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to plot boards in a human readable way
#not generalised to all board sizes but easy enough to
plot_board &amp;lt;- function(string) {
  pieced &amp;lt;- rep(&amp;quot;&amp;quot;, length(string))
  pieced[which(string == 1)] &amp;lt;- &amp;quot;x&amp;quot;
  pieced[which(string == -1)] &amp;lt;- &amp;quot;o&amp;quot;
  pieced[which(string == 0)] &amp;lt;- &amp;quot;*&amp;quot;
  board &amp;lt;- gsub(&amp;quot; \\|$&amp;quot;, &amp;quot;&amp;quot;, paste(pieced, &amp;quot;|&amp;quot;, collapse = &amp;quot; &amp;quot;))
  board_lines &amp;lt;- gsub(&amp;quot;(. \\| . \\| . )\\|( . \\| . \\| . )\\|( . \\| . \\| .)&amp;quot;, 
                      &amp;quot;\n \\1\n-----------\n\\2\n-----------\n\\3&amp;quot;,
                      board
                      )
  return(writeLines(board_lines))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Next we’re going to want to find every possible state we might encounter so we can test for any exceptions. I’m storing strings as a list of 9 0s (unused), 1s (Xs) and -1s (Os) representing the squares 1-&amp;gt;9 from the top left corner.&lt;/p&gt;
&lt;p&gt;It’s simple and fast enough to do this with a quick R function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get all possible boards
possible_boards &amp;lt;- gtools::permutations(
  board_cols, squares,
  c(-1,0,1),
  repeats.allowed = TRUE
  )

#can only have a sum of 1 or 0
possible_boards &amp;lt;- possible_boards[which(rowSums(possible_boards) %in% c(0,1)),]

#plot a random example
plot_board(c(1,0,0,-1,0,0,0,0,1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  x | * | * 
## -----------
##  o | * | * 
## -----------
##  * | * | x&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have the representations of any possible board, we want to find a way to store this is a more compressed format as a hash. I originally wrote a pretty quick function to do this in R and then threw up a quick one underneath compiled in Rcpp for comparison.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#get a unique hash for each board
calc_hash &amp;lt;- function(board) {
  hash &amp;lt;- 0
  for(piece in seq(squares)) {
    hash &amp;lt;- (hash*board_cols) + board[piece] + 1
  }
  return(hash)
}

#and the equivalent in Cpp
cppFunction(&amp;#39;int calc_hashCpp(NumericVector board, int squaresize) {
    //need to init vals in C++
    int hash = 0;
    int boardsize = squaresize * squaresize;
    
    //C++ for loops have start, end, and by
    for (int i=0; i &amp;lt;= boardsize - 1; ++i) {
      hash = (hash * squaresize) + board[i] + 1;
    }
    
    //always have to declare a return
    return hash;
}&amp;#39;)

#get a list of all the possible hashes
hashes &amp;lt;- lapply(purrr::array_tree(possible_boards, margin = 1),
                 calc_hashCpp, squaresize = 3)

#should all be unique
which(duplicated(hashes))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## integer(0)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In order to play noughts and crosses, we then need some way for a game to end. An easy way to check this is when our board string (0s,1s,and-1s) add up to 3/-3 along any row, column or diagonal.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#first we need a function to check when a game has been won
cppFunction(&amp;#39;int check_winnerCpp(NumericVector board) {
  int winner = 0;

  int vec_length = board.size();
  int square_size = sqrt(vec_length);

  //check rows and columns for a winner
  for (int i=0; i &amp;lt;= square_size - 1; ++i) {
    //check row i
    NumericVector row_squares = NumericVector::create(0,1,2);
    row_squares = row_squares + (square_size * i);
    NumericVector row_elements = board[row_squares];
    int row_sum = sum(row_elements);
    if(abs(row_sum) == square_size) {
      if(row_sum &amp;gt; 0) {
        winner = 1;
      } else {
        winner = -1;
      }
    }
    
    //check col i
    NumericVector col_squares = NumericVector::create(0,3,6);
    col_squares = col_squares + i;
    NumericVector col_elements = board[col_squares];
    int col_sum = sum(col_elements);
    if(abs(col_sum) == square_size) {
      if(col_sum &amp;gt; 0) {
        winner = 1;
      } else {
        winner = -1;
      }
    }
  }
  
  //check the diagonalsNumericVector 
  NumericVector rising_diag_squares = NumericVector::create();
  NumericVector falling_diag_squares = NumericVector::create();
  for (int i=0; i &amp;lt;= square_size - 1; ++i) {
    int rising_diag_square = (square_size * i) + i;
    rising_diag_squares.push_back(rising_diag_square);
    
    int falling_diag_square = (square_size - 1) * (i+1);
    falling_diag_squares.push_back(falling_diag_square);
  }
  
  NumericVector rising_diag_elements = board[rising_diag_squares];
  NumericVector falling_diag_elements = board[falling_diag_squares];
  int rising_sum = sum(rising_diag_elements);
  int falling_sum = sum(falling_diag_elements);
  
  if(abs(falling_sum) == square_size) {
    if(falling_sum &amp;gt; 0) {
      winner = 1;
    } else {
      winner = -1;
    }
  }
  if(abs(rising_sum) == square_size) {
    if(rising_sum &amp;gt; 0) {
      winner = 1;
    } else {
      winner = -1;
    }
  }
    
  //return the winner
  //0 for no winner, 999 for draw
  return winner;
}&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can then apply this function to every possible board and find the ones that indicate a winning state. We also init a data frame containing all possible boards, their hash, and their ‘value’ (0 for all for now, more on this later). Finally, I plot the first one in this set just because why not?&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find which boards are winning positions
winning &amp;lt;- purrr::map(purrr::array_tree(possible_boards, margin = 1), check_winnerCpp)

#going to create a df to store the values of all moves
moves_df &amp;lt;- data.frame(hash = unlist(hashes),
                       value = 0,
                       winning = unlist(winning))

#store all boards as a list
#purrr::aray_tree is a really nice way to convert matrix to lists
moves_df$board = purrr::array_tree(possible_boards, margin = 1)

#plot the first board just why not
plot_board(unlist(moves_df$board[1]))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## 
##  o | o | o 
## -----------
##  o | * | x 
## -----------
##  x | x | x&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As we can see, we still have some impossible boards here. This particular board will never occur in actual play because X wins before O can make a move to complete the top row. It doesn’t matter, but useful to keep in mind for a plot later.&lt;/p&gt;
&lt;p&gt;We then need a function telling the computer how to make a move. For this post we’re going to use what’s called ‘E (epsilon)-greedy’ selection. A computer has a parameter epsilon such that&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{cases}
    v &amp;amp;\text{if } \epsilon \leq \rho\\
    V_{max} &amp;amp;\text{if } \epsilon &amp;gt; \rho\\
\end{cases} \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;if epsilon is greater than a random number rho, the computer makes the most valuable choice possible. It chooses whatever it thinks (rightly or wrongly) will lead to the best outcome. This is called &lt;em&gt;exploitation&lt;/em&gt;. If epsilon is less than or equal to rho, the computer randomly chooses any possible action v. This is known as &lt;em&gt;exploration&lt;/em&gt; to test any possibly rewarding but unvalued paths.&lt;/p&gt;
&lt;p&gt;(I may have gotten epsilon the wrong way round here. It really doesn’t matter at all.)&lt;/p&gt;
&lt;p&gt;Let’s implement this in C++&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;cppFunction(&amp;#39;int choose_moveCpp(NumericVector epsilon, NumericVector values) {
  //random number to decide if computer should explore or exploit
  NumericVector random_number = runif(1);
  int move_choice = 0;
  NumericVector choices = NumericVector::create();
  
  //exploit the best move
  if(epsilon[0] &amp;gt; random_number[0]) {
    double max = Rcpp::max(values);
    std::vector&amp;lt; int &amp;gt; res;
    
    int i;
    for(i = 0; i &amp;lt; values.size(); ++i) {
      if(values[i] == max) { 
        res.push_back(i);
      }
    }
    IntegerVector max_indexes(res.begin(), res.end());
    if(max_indexes.size() &amp;gt; 1) {
      std::random_shuffle(max_indexes.begin(), max_indexes.end());
      move_choice = max_indexes[0] + 1;
    } else {
      move_choice = max_indexes[0] + 1;
    }
   //explore all moves randomly
  } else {
    int potential_choices = values.size();
    choices = seq(1, potential_choices);
    std::random_shuffle(choices.begin(), choices.end());
    move_choice = choices[0];
  }
  
  return move_choice;
}&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We also want a little helper func to find all the possible hashes so we can look up which moves a computer can make before choosing between them.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#find all possible next moves
get_next_hashes &amp;lt;- function(board, piece) {
  unused &amp;lt;- which(board == 0)
  
  next_boards &amp;lt;- lapply(unused, function(x, piece) {
    board[x] &amp;lt;- piece
    return(board)
  }, piece = piece)
  #get the hashes of the next boards
  hashes &amp;lt;- lapply(next_boards, calc_hashCpp, squaresize = 3)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Finally, we need to reward the computer for making good actions, and punish it for making bad ones. We’ll do this using Temporal Difference (TD) error learning.&lt;/p&gt;
&lt;p&gt;The computer looks at how good an end point was (for noughts and crosses this can be a win, lose, or draw) and then decides if that outcome is better or worse than it was expecting. It then re-evaluates its beliefs about the choices it made to lead to that end state. It can be formulated as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[V_{state} = V_{state} + TD  error \cdot scalar \]&lt;/span&gt;
the scalar here is the &lt;em&gt;learning rate&lt;/em&gt; of the computer. Do we want it to forget everything it new about the world seconds earlier and take only the most recent information (1), or update it’s beliefs very slowly (~0). We’ll refer to this as lr in subsequent equations.&lt;/p&gt;
&lt;p&gt;The TD error itself is calculated as&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[TD error = (\gamma \cdot reward - V_{state}) \]&lt;/span&gt;
Where gamma acts to make sure we don’t overfit too far back into the past. It reduces the reward as you go further back and is set between 0 and 1. The reward here will (e.g.) be 1 if the computer has just won with it’s latest move, otherwise it will be the value of the state the computer might move into.&lt;/p&gt;
&lt;p&gt;Putting these together we get&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[ V_{state} = V_{state} + lr \cdot (\gamma \cdot V_{state+1} - V_{state}) \]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Let’s implement this using Rcpp&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to feed reward back to the agent based on results
cppFunction(&amp;#39;NumericVector backfeed_rewardCpp(NumericVector values, double reward, double learning_rate, double gamma) {
  int states = values.size();
  NumericVector new_values = NumericVector::create();
  
  //go from last state backwards
  for( int state = states-1; state &amp;gt;= 0; state--) {
    double new_value = values[state] + learning_rate * ((gamma * reward) - values[state]);
    new_values.push_back(new_value);
    //recurse the reward
    reward = new_value;
  }
  return new_values;
}&amp;#39;)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can start actually playing games! I wrote out a long function in R to play through the various bits. It surely could be refactored a little more concisely but it works for now and I was getting tired by this point.&lt;/p&gt;
&lt;p&gt;We first add two functions (one to make moves/play the game, and one to update the values using the formula above) then put it all into to one uber-function&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#function to choose and implement computer moves
computer_move &amp;lt;- function(piece, board, epsilon) {
  #get potential moves
  potential_move_hashes &amp;lt;- get_next_hashes(board, piece)
  #get the values of the potential moves
  potential_move_vals &amp;lt;- moves_df$value[
    unlist(lapply(potential_move_hashes, function(x) which(moves_df$hash == x)))]
  #choose move based on rewards
  player_move &amp;lt;- choose_moveCpp(epsilon, potential_move_vals)
  #update the board with the new move
  updated_board &amp;lt;- unlist(moves_df$board[
    moves_df$hash == unlist(potential_move_hashes)[player_move]])
  return(updated_board)
}

#function to get the values for each state based on the reward
update_move_vals &amp;lt;- function(player1_reward, player2_reward, 
                             player1_hashes, player2_hashes,
                             learning_rate,gamma) {
  player1_newvals &amp;lt;- backfeed_rewardCpp(moves_df$value[
    unlist(lapply(player1_hashes, function(x) which(moves_df$hash == x)))],
    player1_reward, learning_rate, gamma)
  player2_newvals &amp;lt;- backfeed_rewardCpp(moves_df$value[
    unlist(lapply(player2_hashes, function(x) which(moves_df$hash == x)))],
    player2_reward, learning_rate, gamma)
  new_vals &amp;lt;- list(player1_newvals, player2_newvals)
  return(new_vals)
}

#function to get two computers to play each other
play_game_computers &amp;lt;- function(player1_epsilon, 
                                player2_epsilon,
                                learning_rate, gamma) {
  #init board
  board &amp;lt;- rep(0, squares)
  winner &amp;lt;- 0
  moves &amp;lt;- 0
  #init hash storage
  player1_hashes &amp;lt;- c()
  player2_hashes &amp;lt;- c()
  
  #keep moving until game is over
  while(winner == 0 &amp;amp; moves &amp;lt; 9) {
    #iterate moves
    moves &amp;lt;- moves + 1
    #player 1 moves
    board &amp;lt;- computer_move(1, board, player1_epsilon)
    player1_hashes &amp;lt;- append(calc_hashCpp(board, board_cols), player1_hashes)
    winner &amp;lt;- check_winnerCpp(board)
    
    #same for player 2
    if(winner == 0  &amp;amp; moves &amp;lt; 9) {
      moves &amp;lt;- moves + 1
      board &amp;lt;- computer_move(-1, board, player1_epsilon)
      player2_hashes &amp;lt;- append(calc_hashCpp(board, board_cols), player2_hashes)
      winner &amp;lt;- check_winnerCpp(board)
    }
  }
  
  #update policies
  if(winner == 1) {
    message &amp;lt;- &amp;quot;x wins!&amp;quot;
    new_vals &amp;lt;- update_move_vals(1, 0, player1_hashes, player2_hashes,
                                 learning_rate, gamma)
  } else if(winner == -1) {
    message &amp;lt;- &amp;quot;o wins!&amp;quot;
    new_vals &amp;lt;- update_move_vals(0, 1, player1_hashes, player2_hashes, 
                                 learning_rate, gamma)
  } else {
    message &amp;lt;- &amp;quot;draw!&amp;quot;
    new_vals &amp;lt;- update_move_vals(0.1, 0.5, player1_hashes, player2_hashes, learning_rate, gamma)
  }
  #push the values back into the dictionary data frame
  moves_df$value[unlist(lapply(player1_hashes, function(x) which(moves_df$hash == x)))] &amp;lt;&amp;lt;- new_vals[[1]]
  moves_df$value[unlist(lapply(player2_hashes, function(x) which(moves_df$hash == x)))] &amp;lt;&amp;lt;- new_vals[[2]]
  return(message)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So that the computer can learn the value of moves, we first want to run this on a training epoch. We’ll get the computer to play 100000 games against itself with an epsilon &amp;lt; 1 so that it explores the game state and learns by reinforcement. We’ll then plot the values it’s learn for all moves based upon if they are winning or not.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#test on 10000 games with a little randomness thrown in
train &amp;lt;- purrr::rerun(100000, play_game_computers(0.8, 0.8, 0.35, 0.9))

#test how fast our function is
microbenchmark::microbenchmark(play_game_computers(0.8, 0.8, 0.35, 0.9), times = 1000)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## Unit: microseconds
##                                      expr   min      lq     mean median
##  play_game_computers(0.8, 0.8, 0.35, 0.9) 838.7 1061.05 1352.258 1222.2
##       uq    max neval
##  1361.45 4548.4  1000&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#plot the updated values of moves
p1 &amp;lt;- ggplot(moves_df, aes(x = value, group = as.character(winning))) +
  geom_density(alpha = 0.5, aes(fill = as.character(winning))) +
  scale_fill_manual(values = c(&amp;quot;red&amp;quot;, &amp;quot;blue&amp;quot;, &amp;quot;green&amp;quot;), name = &amp;quot;winning move&amp;quot;) +
  theme_minimal()
p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-28-Rinforcement_learning_part_1_files/figure-html/train_computer-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Thankfully the computer has learned that winning moves are more valuable than non-winning moves! The reason there are peaks at 0 is because these are ‘winning’ moves that are impossible as referenced nearer the top of the post.&lt;/p&gt;
&lt;p&gt;We’ll then run 2500 testing games where the computer is trying to play optimally. Noughts and crosses is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Solved_game&#34;&gt;solved&lt;/a&gt; game. Unless a play chooses a non-optimal move, the game should end in a draw. Let’s see what proportion actually do end in a draw by grouping every 500 games of the testing set.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#run on an extra 2500 games with no exploration (just exploit)
test &amp;lt;- purrr::rerun(2500, play_game_computers(1, 1, 0.35, 0.9))

#group by each 500 games
test_df &amp;lt;- data.frame(result = unlist(test),
                      group = rep(1:5, each = 500))

#plot percentage of games that are drawn
p2 &amp;lt;- ggplot(test_df, aes(x = group, fill = result)) +
  geom_bar(stat = &amp;quot;count&amp;quot;) +
  labs(x = &amp;quot;group (every 500 games)&amp;quot;) +
  theme_minimal()
p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-28-Rinforcement_learning_part_1_files/figure-html/test_computer-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And it seems like the computer learns after a final bit of optimisation to always draw! hooray!!&lt;/p&gt;
&lt;p&gt;Finally, because obviously this post wouldn’t be complete without human testing, I wrote a quick and dirty function to play a game against the now proficient computer. Enjoy below!!&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;player_move &amp;lt;- function(board){
  #find free spaces a move can be made into
  free_spaces &amp;lt;- which(board == 0)
  cat(&amp;quot;Please move to one of the following board spaces: [&amp;quot;, free_spaces,  &amp;quot;]\n&amp;quot;)
  #user input
  submitted_move &amp;lt;- as.integer(readline(prompt = &amp;quot;&amp;quot;))
  #need valid input
  while(!submitted_move %in% free_spaces) {
    if(submitted_move == 0) {
      break
    } else {
      cat(&amp;quot;Illegal Move! Please move to one of the following board spaces: [&amp;quot;, free_spaces,  &amp;quot;] or press 0 to quit\n&amp;quot;)
      submitted_move &amp;lt;- as.integer(readline(prompt = &amp;quot;&amp;quot;))
    }
  }
  #return move
  return(submitted_move)
}&lt;/code&gt;&lt;/pre&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#only need a computer epsilon and which piece (turn order)
play_game_human &amp;lt;- function(human_piece, computer_epsilon = 1) {
  board &amp;lt;- rep(0, 9)
  moves &amp;lt;- 0
  winner &amp;lt;- 0
  
  #play the game as before but with a human player
  if (human_piece == 1) {
    while (winner == 0 &amp;amp; moves &amp;lt; 9) {
      moves &amp;lt;- moves + 1
      plot_board(board)
      human_move &amp;lt;- player_move(board)
      
      if (human_move == 0) {
        break
      } else {
        board[human_move] &amp;lt;- human_piece
      }
      i &amp;lt;&amp;lt;- board
      j &amp;lt;&amp;lt;- board
      winner &amp;lt;- check_winnerCpp(board)
      if (winner == 0 &amp;amp; moves &amp;lt; 9) {
        moves &amp;lt;- moves + 1
        piece &amp;lt;- human_piece * -1

        board &amp;lt;- computer_move(-1, board, computer_epsilon)
        winner &amp;lt;- check_winnerCpp(board)
      }
    }
  } else {
    while (winner == 0 &amp;amp; moves &amp;lt; 9) {
      moves &amp;lt;- moves + 1
      piece &amp;lt;- human_piece * -1

      board &amp;lt;- computer_move(-1, board, player1_epsilon)
      winner &amp;lt;- check_winnerCpp(board)

      if (winner == 0 &amp;amp; moves &amp;lt; 9) {
        moves &amp;lt;- moves + 1
        plot_board(board)
        human_move &amp;lt;- player_move(board)
        if (human_move == 0) {
          break
        } else {
          board[human_move] &amp;lt;- human_piece
        }
        winner &amp;lt;- check_winnerCpp(board)
      }
    }
  }
  #little ending flavour
  if (winner == human_piece) {
    print(&amp;quot;you win!!&amp;quot;)
  } else if(winner == -human_piece) {
    print(&amp;quot;oh no! you lost!&amp;quot;)
  } else {
    print(&amp;quot;a draw..&amp;quot;)
  }
  plot_board(board)
}

#run like:
play_game_human(1, 1)&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Predicting the Unpredictable- Analysing Rowing in Cambridge pt. 1</title>
      <link>/post/cam_rowing_1/</link>
      <pubDate>Sun, 24 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/cam_rowing_1/</guid>
      <description>


&lt;p&gt;In my free time away from PhD and data science work, I (used to) enjoy rowing. Aside from obvious benefits like socialising, providing a (very intense) workout, seeing the outdoors at least a few times a week… there are really two things that I love(d) about rowing:&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;It’s the sport that is closest to a simple engineering problem. Going fast basically boils down to how in time and how hard you can get 1-8 guys to move an oar through the water. Realistically, you could probably model how good a boat of guys will row just by tracking them on a rowing machine (and I have suspicions that this is what British Rowing etc. do for national teams).&lt;/li&gt;
&lt;li&gt;I learnt to row as an undergraduate at Oxford, and really got serious about it as a postgraduate student at Cambridge. This might seem like a irrelevant detail but it’s not.&lt;/li&gt;
&lt;/ol&gt;
&lt;div id=&#34;how-rowing-usually-works&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;How rowing usually works&lt;/h1&gt;
&lt;p&gt;Generally when racing boats, some n number of rowing crews line up alongside each other, and row straight down a lake (usually ~2km). The first boat to cross the finish line is generally considered the winner. For an example of such a race, see this Olympic final from 2012:&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://youtu.be/x6wHZNWF7pA?t=655&#34; frameborder=&#34;0&#34; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;You might notice that there are four men in each boat here, each of whom are rowing. This works well on a reservoir where this race was held, but not so well on (e.g.) the River Cam that flows through Cambridge, which is both a pretty thin river, and has lots of tight corners.&lt;/p&gt;
&lt;div class=&#34;figure&#34;&gt;
&lt;img src=&#34;/img/river_cam.png&#34; alt=&#34;the river cam&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;the river cam&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;how-rowing-in-cambridgeoxford-works&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;How rowing in Cambridge/Oxford works&lt;/h1&gt;
&lt;p&gt;Instead of these rivers, boat typically contain 8 rowers, and one cox, who is responsible for steering the boat. In lieu of the space needed to row side by side, various races across the year are run as time trials down a portion of the river. The &lt;em&gt;real&lt;/em&gt; highlight of the year however, are two four day competitions in which crews line up one-behind-the-other and attempt to chase down and ‘bump’ the crew ahead (before being chased down themselves).&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/watch?v=x6N6-B_ob2k&#34; frameborder=&#34;0&#34; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;Upon hitting the boat that starts ahead, the two crews switch places the next day and then the race is run again, until hopefully, the positions roughly reflect the speeds of the boats.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;predicting-bumps-races&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Predicting bumps races&lt;/h1&gt;
&lt;p&gt;Generally therefore, if two boats line up for a bumps race, the faster one should catch the slower boat (or if the positions are reversed, the faster boat should fail to be caught by the slower boat behind). It &lt;em&gt;should&lt;/em&gt; be fairly easy to predict bumps races, but it isn’t. The nature of the relative inexperience of lots of crews, the panic of the races, and the pretty tight course means mistakes are made early and often.&lt;/p&gt;
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://youtu.be/SCaeOsQmpTs?t=59&#34; frameborder=&#34;0&#34; allowfullscreen&gt;
&lt;/iframe&gt;
&lt;p&gt;However, I wanted to see how possible it was. The only real data to train predictions on are the time-trial races that happen before bumps, so I’m going to see how well it’s possible to model a bumps race using the implied speeds of crews from these previous time trials.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;libraries-and-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Libraries and Data&lt;/h1&gt;
&lt;p&gt;For this post, I’m only going to do some simple munging and logistic regression, so I only need the (new) version of the Tidyverse (as I’m also going to play with pivot_longer and pivot_shorter for the &lt;a href=&#34;&#34;&gt;first time&lt;/a&gt;).&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The data comes from my own scraping of race results on the river cam over the last ten years. I’ll eventually package this up properly. For now it can be found at &lt;a href=&#34;https://github.com/RobWHickman/CamStroker&#34;&gt;my Github&lt;/a&gt;. Today I’ll just read in the raw .csv files.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#download the raw data
#wil lbe packages eventually
race_results &amp;lt;- read.csv(&amp;quot;https://raw.githubusercontent.com/RobWHickman/CamStroker/master/data-raw/cambridge_race_results.csv&amp;quot;,
                         stringsAsFactors = FALSE)
bumps_results &amp;lt;- read.csv(&amp;quot;https://raw.githubusercontent.com/RobWHickman/CamStroker/master/data-raw/cambridge_bumps_results.csv&amp;quot;,
                          stringsAsFactors = FALSE)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;data-munging&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Data Munging&lt;/h1&gt;
&lt;p&gt;We then want to lengthen out the bumps data by days to squeeze as much data as possible out of possible combinations of boats we have data for. I need to line boats up by the start position each day, so I also init a column for this at the end&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;bumps_long &amp;lt;- bumps_results %&amp;gt;%
  #pivot bumps results to longer so we can model each day of racing
  pivot_longer(., starts_with(&amp;quot;Day&amp;quot;),
               names_to = &amp;quot;Day&amp;quot;, values_to = &amp;quot;Bump&amp;quot;) %&amp;gt;%
  mutate(Bump = case_when(
    is.na(Bump) ~ 0,
    TRUE ~ as.numeric(Bump)
  )) %&amp;gt;%
  group_by(Competition, College, Year, Crew, Gender) %&amp;gt;%
  #calculate day start and end positions
  mutate(day_end = StartPos - cumsum(Bump)) %&amp;gt;%
  mutate(day_start = day_end + Bump)

head(bumps_long)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 10
## # Groups:   Competition, College, Year, Crew, Gender [2]
##   Competition College  Year  Crew Gender StartPos Day    Bump day_end
##   &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 Lent        Caius    2016    NA M             1 Day1      0       1
## 2 Lent        Caius    2016    NA M             1 Day2      0       1
## 3 Lent        Caius    2016    NA M             1 Day3      0       1
## 4 Lent        Caius    2016    NA M             1 Day4      0       1
## 5 Lent        Downing  2016    NA M             2 Day1      0       2
## 6 Lent        Downing  2016    NA M             2 Day2      0       2
## # ... with 1 more variable: day_start &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;And we want to do the opposite for the race data so we can efficiently join this onto the bumps data. As the speed of the crew is all we care about I calculate this as the course distance / seconds taken to get an idea of roughly how fast each crew is.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;race_wide &amp;lt;- race_results %&amp;gt;%
  #calculate implied racing speed
  mutate(race_id = paste(race, leg),
         av_speed = distance / seconds) %&amp;gt;%
  select(Year = year, College = college, Crew = crew, Gender = gender,
         race_id, av_speed) %&amp;gt;%
  pivot_wider(., id_cols = c(&amp;quot;Year&amp;quot;, &amp;quot;College&amp;quot;, &amp;quot;Crew&amp;quot;, &amp;quot;Gender&amp;quot;),
              names_from = race_id, values_from = av_speed) %&amp;gt;%
  #rename to tidy up
  rename(NSC = `Newnham Short Course NA`,
         Frbrn = `Fairbairns NA`,
         WH2H1 = `Winter Head 2 Head leg1`,
         WH2H2 = `Winter Head 2 Head leg2`,
         Rbnsn = `Robinson Head NA`) %&amp;gt;%
  #not much data for Robinson regatta so leave out
  select(-Rbnsn)

head(race_wide)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 8
##    Year College    Crew Gender   NSC Frbrn WH2H1 WH2H2
##   &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;  &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt; &amp;lt;dbl&amp;gt;
## 1  2010 Catz          1 M       5.42    NA    NA    NA
## 2  2010 Robinson      1 M       5.41    NA    NA    NA
## 3  2010 Sidney        1 M       5.39    NA    NA    NA
## 4  2010 Caius         1 M       5.38    NA    NA    NA
## 5  2010 Girton        1 M       5.22    NA    NA    NA
## 6  2010 Churchill     1 M       5.21    NA    NA    NA&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we simply join the data and calculate the implied speed differential between two crew who start a bumps race behind each other.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;regression_data &amp;lt;- bumps_long %&amp;gt;%
  ungroup() %&amp;gt;%
  #join datasets
  left_join(race_wide, by = c(&amp;quot;Year&amp;quot;, &amp;quot;College&amp;quot;, &amp;quot;Crew&amp;quot;, &amp;quot;Gender&amp;quot;)) %&amp;gt;%
  group_by(Competition, Year, Gender, Day) %&amp;gt;%
  arrange(Competition, Year, Gender, Day, day_start) %&amp;gt;%
  #calculate speed difference between boats starting bumps data behind each other
  mutate(frbrn_diff = Frbrn - lag(Frbrn),
         NSC_diff = NSC - lag(NSC),
         WH2H1_diff = WH2H1 - lag(WH2H1),
         WH2H2_diff = WH2H2 - lag(WH2H2)) %&amp;gt;%
  select(-NSC, -Frbrn, -WH2H1, -WH2H2) %&amp;gt;%
  #pivot longer for plotting
  pivot_longer(., frbrn_diff:WH2H2_diff,
               names_to = &amp;quot;race&amp;quot;, values_to = &amp;quot;speed_difference&amp;quot;) %&amp;gt;%
  filter(!is.na(speed_difference)) %&amp;gt;%
  #tidy up plotting data
  filter(Bump %in% c(1, 0)) %&amp;gt;%
  filter(Competition == &amp;quot;Lent&amp;quot;)

head(regression_data)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## # A tibble: 6 x 12
## # Groups:   Competition, Year, Gender, Day [2]
##   Competition College  Year  Crew Gender StartPos Day    Bump day_end
##   &amp;lt;chr&amp;gt;       &amp;lt;chr&amp;gt;   &amp;lt;int&amp;gt; &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt;     &amp;lt;int&amp;gt; &amp;lt;chr&amp;gt; &amp;lt;dbl&amp;gt;   &amp;lt;dbl&amp;gt;
## 1 Lent        Sidney   2010     2 F            40 Day1      1      39
## 2 Lent        Christs  2010     2 F            41 Day1      0      41
## 3 Lent        Sidney   2010     2 F            40 Day2      0      39
## 4 Lent        Christs  2010     2 F            41 Day2      1      40
## 5 Lent        Magdal~  2010     2 F            46 Day2      0      45
## 6 Lent        Newnham  2010     3 F            52 Day2      0      51
## # ... with 3 more variables: day_start &amp;lt;dbl&amp;gt;, race &amp;lt;chr&amp;gt;,
## #   speed_difference &amp;lt;dbl&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;plotting-data&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Plotting Data&lt;/h1&gt;
&lt;p&gt;We can then plot the data and see if the speed differential of races earlier in theyear is a useful predictor of bumping a boat ahead of you. We can model this as a logistic problem where bumping is either a 1 (to catch the boat ahead) or a 0 (did not catch). This does cut out some data in weird ways that I’ll get onto in later posts, but will do for now.&lt;/p&gt;
&lt;p&gt;For the logistic regression I use geom_smooth and a binomial generalised linear model. Again, there’s more we can explore here, but this is just a quick intro post so we won’t worry about standrad error etc. I also split out by Male/Female crews as I imagine gender might play a role.&lt;/p&gt;
&lt;p&gt;Given that this week is the first race of the 2019/2020 calendar (Fairbairns) I first limited myself to only data from that race.&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;p1 &amp;lt;- regression_data %&amp;gt;%
  #filter only Fairbairns results
  filter(race == &amp;quot;frbrn_diff&amp;quot;) %&amp;gt;%
  ggplot(., aes(x = speed_difference, y = Bump)) +
  geom_point() +
  #model as a logistic event
  geom_smooth(method = &amp;quot;glm&amp;quot;, 
    method.args = list(family = &amp;quot;binomial&amp;quot;), 
    se = FALSE) +
  facet_wrap(~Gender, scales = &amp;quot;free_x&amp;quot;) +
  theme_minimal()

#plot
p1&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-24-cambridge_rowing_1_files/figure-html/plot_fairbairns-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;And it seems being faster than a boat ahead of you does increase your chance of bumping, but not a huge amount.&lt;/p&gt;
&lt;p&gt;There’s good reason to beleive Fairbairns regatta might not be the best predictor of performance later in the year. It’s the first race, where many collges are still testing out their crew. It also takes place during a weekday, so many students cannot take part, and is a 4.5km race, instead of the usual 2km of later races and bumps itself.&lt;/p&gt;
&lt;p&gt;If we look at how all races predict later bumps success we can see much nicer logistic curves:&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;#do the same but for all race data
p2 &amp;lt;- regression_data %&amp;gt;%
  ggplot(., aes(x = speed_difference, y = Bump)) +
  geom_point() +
  geom_smooth(method = &amp;quot;glm&amp;quot;, 
    method.args = list(family = &amp;quot;binomial&amp;quot;), 
    se = FALSE) +
  geom_vline(xintercept = 0, colour = &amp;quot;red&amp;quot;, linetype = &amp;quot;dashed&amp;quot;) +
  facet_grid(race~Gender, scales = &amp;quot;free_x&amp;quot;) +
  theme_minimal()

p2&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&#34;/post/2019-11-24-cambridge_rowing_1_files/figure-html/plot_all_races-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;Especially Newnham Short Course and the two legs of Winter Head 2 Head show nice curves where boats that are faster on these races have a greater chance of bumping later in the year.&lt;/p&gt;
&lt;p&gt;There’s a lot more to do to properly model a bumps regatta, but the first step of validating our ideas and data seems to show promising results!&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Could Yorkshire Win the World Cup</title>
      <link>/project/yorkshire_world_cup/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/yorkshire_world_cup/</guid>
      <description>

&lt;p&gt;In 2018, after watching the &lt;a href=&#34;https://en.wikipedia.org/wiki/2018_CONIFA_World_Football_Cup&#34; target=&#34;_blank&#34;&gt;CONIFA World Cup&lt;/a&gt; final live, I wondered if an Independent Yorkshire could win the FIFA World Cup. This resulted in a few blogposts that were turned into an article in &lt;a href=&#34;https://www.citymetric.com/horizons/football-could-independent-yorkshire-win-world-cup-3961&#34; target=&#34;_blank&#34;&gt;Citymetric magazine&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;This page lists the blog posts and a one line description of techniques therein. The copies the article text below.&lt;/p&gt;

&lt;h1 id=&#34;blog-posts&#34;&gt;Blog Posts&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/yorkshire_world_cup_1/&#34; target=&#34;_blank&#34;&gt;Data and Scraping&lt;/a&gt; - Grabbing the FIFA video game player data and UK maps&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/yorkshire_world_cup_2/&#34; target=&#34;_blank&#34;&gt;Player Position LASSO&lt;/a&gt; - Using LASSO regression to calculate player abilities in various positions&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/yorkshire_world_cup_3/&#34; target=&#34;_blank&#34;&gt;Finding Birthplaces&lt;/a&gt; - Scraping the birthplaces of British players and binning by county&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/yorkshire_world_cup_4/&#34; target=&#34;_blank&#34;&gt;Picking Teams&lt;/a&gt; - Simulating various lineups to find the best team each nation/county can put out on the field&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/yorkshire_world_cup_5/&#34; target=&#34;_blank&#34;&gt;Simulating World Cup&lt;/a&gt; - Calculate implied county ELO and simulate World Cups to get a sense of the chance of a county winning it&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/yorkshire_world_cup_6/&#34; target=&#34;_blank&#34;&gt;&lt;em&gt;Bonus&lt;/em&gt; UK/Rest of the World teams&lt;/a&gt; - Doing the same but for an all UK team/ players from Nations who did not qualify for the World Cup&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;article-text&#34;&gt;Article Text&lt;/h1&gt;

&lt;p&gt;With less than a week until the start of the 2018 World Cup in Russia, it’s worth remembering, that another World Cup – the 2018 ConIFA World Cup for stateless people, minorities, and regions unaffiliated with FIFA - is also taking place in London.&lt;/p&gt;

&lt;p&gt;Though happening in the UK, neither of the local ConIFA members will be competing. The Ellan Vannin team from the Isle of Man withdrew midway; and the latest ConIFA member, Yorkshire, only gained membership earlier this year.&lt;/p&gt;

&lt;p&gt;One of Yorkshire’s most obvious characteristics, is that it’s absolutely huge compared to most other UK counties. It also – probably – has the highest contemporary population of any of the historic British counties. Indeed, as recently as this February the region resisted attempts to split control of the region up, demanding a “One Yorkshire” devolution deal instead of the proposed control to regions surrounding four of it’s major cities – and in May, a vocal proponent of such a “One Yorkshire” devolution, Dan Jarvis, the Labour MP for Barnsley, was elected as mayor of one of the Sheffield City region.&lt;/p&gt;

&lt;p&gt;Given its size, ConIFA membership, and pushes for further devolution, I was wondering how Yorkshire would do as an independent full FIFA member. If it seceded as a whole from the rest of the UK could it field a team that could challenge internationally? Could any of the historic British counties?&lt;/p&gt;

&lt;p&gt;Overall, there are 88 historic counties in Great Britain, plus the 6 counties of Northern Ireland (I couldn’t find shapefiles for the older subdivisions) which could be potential independent FIFA members.&lt;/p&gt;

&lt;p&gt;Once I had these, I needed some way to rate potential players, and therefore teams. Luckily, the popular video game FIFA18 maintains up to date ratings of thousands of players across 36 different stats (e.g. dribbling, heading, pace etc.). After scraping an online database of players, I’m left with 18,058 players of various nationalities and abilities.&lt;/p&gt;

&lt;p&gt;Using a simple regression model, I can use these abilities and the player’s listed preferred positions to predict what each players rating for each position, and use these position ratings to train a computer to pick optimal teams across a variety of formations. If we do this do for every nation that has at least 11 players in the database (10 outfield + 1 goalkeeper), the best 4 national teams that can be fielded are from Brazil, Germany, Spain, and Belgium.&lt;/p&gt;

&lt;p&gt;To pick the teams for each county, though, I first had to find the birthplace of player. To simplify things a bit I only check players listed as English, Scottish, Welsh, Northern Irish, or Irish (due to the weirdness of the Irish FA) in my database of FIFA players. For each of these I ran a script to look the player up on wikipedia and scrape their birthplace. Once this was geocoded, I had a map of each British player and their birthplace, and therefore, the county of their birth.&lt;/p&gt;

&lt;p&gt;Unsurprisingly, it basically shows a population density map of the UK, with more players born in the urban centres of London, Birmingham, the Lancashire cities and the West Yorkshire urban centres. After binning the players by county of birth, twenty historic counties have enough players to field a team.&lt;/p&gt;

&lt;p&gt;On this chart, ‘FIFA_ability’ is the perceived ability of the optimal 11 players in a starting line up for that county, as judged by FIFA stats.&lt;/p&gt;

&lt;p&gt;Perhaps a little surprisingly, the Lancashire team is rated slightly higher than the Yorkshire team – though looking at the sheer number of players they can select from it makes sense. Elsewhere, the home counties do well, as do Glasgow and Warwickshire (which contains much of contemporary Birmingham).&lt;/p&gt;

&lt;p&gt;Looking at the selections the alogirthm chooses, it’s pretty clear some of these teams tend to be a bit flawed but overall make sense. The Yorkshire/Lancashire teams in particular are full of England international players and are lacking only an experienced top level goalkeeper.&lt;/p&gt;

&lt;p&gt;In order to predict how these teams would do at a World Cup, I needed some form of quantifiable rating of a team;s ability. Luckily, ELO ratings in chess can do exactly that: the likelihood of any team A beating a team B is a direct function in the difference in their ELO rating.&lt;/p&gt;

&lt;p&gt;Plotting the ELO ratings of each actual national team (an up to date calculation is maintained at ELOrating.net) against the ability of each national team as judged by FIFA18 shows a pretty clear linear trend. Using a regression model of this relationship, we can predict the ability of each hypothetical county national team.&lt;/p&gt;

&lt;p&gt;When plotted, these ELO ratings show that some of the counties are definitely in the ball park of established world cup qualifiers – and so we might expected a post-super-devolution Britain to be sending multiple teams to the World Cup.&lt;/p&gt;

&lt;p&gt;In fact, Yorkshire and Lancashire are predicted to be about as good as the national teams of Serbia and Sweden. Lagging a bit behind, Essex and Surrey – both of which take in large chunks of what is now London – could expect to be competititve with teams like Turkey and Morocco.&lt;/p&gt;

&lt;p&gt;However, just finding out how good these teams would be wasn’t what I wanted to know. I wanted to see if an independent British county could win the World Cup.&lt;/p&gt;

&lt;p&gt;To do this, I swapped each of these counties in for the national English team and ran 10000 simulations of the post-devolution 2018 World Cup, uusing the same draws and fixtures as the real tournament uses.&lt;/p&gt;

&lt;p&gt;The bad news is, the real-life favourites tend to dominate the simulations. Brazil or Germany were predicted to win the tournament in almost half of all the simulations. On the graph, it;s just possible to make out the red bars of Yorkshire and Lancashire, both of which won 41 out of 10000 simulations (a 0.41 per cent chance of winning any random World Cup).&lt;/p&gt;

&lt;p&gt;This seems pretty low – but is comparable to pretty respectable teams like Denmark (0.775 per cent), Senegal (0.217 per cent), and even higher than the Iceland team which knocked england out of Euro2016 (0.339 per cent). It’s way higher than the chances the simulation gives the Russian hosts (0.07 per cent).&lt;/p&gt;

&lt;p&gt;Scaling down to just these pretty hopeless nations/counties really shows how little hope the independent British counties would have at an international tournament. However, the best four counties (Lancashire, Yorkshire, Essex, and Surrey) all have about a 0.2 per cent or higher chance, or 500-1 odds, at winning the 2018 World Cup were they to replace England at the last minute. This is an order of magnitude greater than the 5000-1 odds given to Leicester City at the start of 2015-2016 Premier League season, so there’s always a chance.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Guardian: The Knowledge</title>
      <link>/project/guardian_knowledge/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/guardian_knowledge/</guid>
      <description>

&lt;p&gt;When I have a free afternoon, I enjoy answering the questions listed on The Guardian&amp;rsquo;s &lt;a href=&#34;https://www.theguardian.com/football/series/theknowledge&#34; target=&#34;_blank&#34;&gt;The Knowledge&lt;/a&gt; blog. This munging generally ends up as &lt;a href=&#34;http://www.robert-hickman.eu/post/&#34; target=&#34;_blank&#34;&gt;blogposts&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Here are the current examples I have published:&lt;/p&gt;

&lt;h1 id=&#34;august-2018-http-www-robert-hickman-eu-post-the-knowledge-4th-august-2018&#34;&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/the-knowledge-4th-august-2018/&#34; target=&#34;_blank&#34;&gt;August 2018&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;Looked at successive runs of fixtures for English clubs against identical suffix/prefixes. Also scraped FIFA World Cup squads and looked at players who played in a lower shirt number than their age.&lt;/p&gt;

&lt;h1 id=&#34;january-2019-http-www-robert-hickman-eu-post-counties-league-points&#34;&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/counties_league_points/&#34; target=&#34;_blank&#34;&gt;January 2019&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;Grouped football teams by their county and looked at which counties had won the most points over the past 140 years of league football&lt;/p&gt;

&lt;h1 id=&#34;febuary-2019-http-www-robert-hickman-eu-post-the-knowledge-7th-february-2019&#34;&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/the-knowledge-7th-february-2019/&#34; target=&#34;_blank&#34;&gt;Febuary 2019&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;Answered 4 questions:
- which football players have scored on the most unique days of the year (Cristiano Ronaldo)
- which football teams had finished 2nd in a league the most times (Manchester United in the 1st Division - 14times)
- what is the earliest a team has been relegated from a league the earliest (Rochdale, with 8 games to go in &lt;sup&gt;1973&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1974&lt;/sub&gt;)
- what is the longest run of games without a draw in the English leagues (Aston Villa with 50 games in &lt;sup&gt;1891&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1892&lt;/sub&gt;)&lt;/p&gt;

&lt;h1 id=&#34;june-2019-http-www-robert-hickman-eu-post-guardian-knowledge-june&#34;&gt;&lt;a href=&#34;http://www.robert-hickman.eu/post/guardian_knowledge_june/&#34; target=&#34;_blank&#34;&gt;June 2019&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;A pretty fun post trying to work out the players who had played in the Premier League while representing low ranked countries. It turns out it&amp;rsquo;s pretty difficult to answer conclusively, but it seems that Zesh Rehman (Fulham/Pakistan) in 2005 is the lowest ranked, whereas Christpher Wreh seems to be the player with the lowest ranked nationality to actually win the league&lt;/p&gt;

&lt;p&gt;For these questions I tend to rely on the &lt;a href=&#34;https://github.com/jalapic/engsoccerdata&#34; target=&#34;_blank&#34;&gt;engsoccerdata&lt;/a&gt; package in R, to which I am a frequent contributor. I also tend to do a fair bit of web scraping using simple (and sometimes &lt;a href=&#34;http://www.robert-hickman.eu/post/dynamic_web_scraping/&#34; target=&#34;_blank&#34;&gt;not so simple&lt;/a&gt;) methods.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>R Packages</title>
      <link>/project/r_packages/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/r_packages/</guid>
      <description>

&lt;p&gt;Some R packages I have authored. Most/all can be found at my &lt;a href=&#34;https://github.com/RobWHickman&#34; target=&#34;_blank&#34;&gt;Github page&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;karpov&#34;&gt;KaRpov&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;/img/packages/immortal_game.gif&#34; alt=&#34;Immortal Game GIF&#39;d using kaRpov&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A small package in base R to read pgn files of chess matches and turn them into animations of the game using ggplot2. &lt;a href=&#34;https://github.com/RobWHickman/kaRpov&#34; target=&#34;_blank&#34;&gt;https://github.com/RobWHickman/kaRpov&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;ggparliament&#34;&gt;ggparliament&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/RobWHickman/ggparliament/master/man/figures/HexSticker.png&#34; alt=&#34;ggparliament&#34; /&gt;&lt;/p&gt;

&lt;p&gt;An extension to ggplot2 written with Thomas Leeper and Zoe Meers to plot the layour of various parliamentary chambers and their composition by party. Resulted in a &lt;a href=&#34;https://www.theoj.org/joss-papers/joss.01313/10.21105.joss.01313.pdf&#34; target=&#34;_blank&#34;&gt;JOSS paper&lt;/a&gt;. Over 4000 downloads from CRAN and 115 Github stars as of November 2019.&lt;/p&gt;

&lt;h1 id=&#34;jeb&#34;&gt;Jeb!&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/RobWHickman/Jeb/master/man/figure/HexSticker.png&#34; alt=&#34;Jeb!&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A small joke package written to quickly generate maps akin to the &lt;a href=&#34;https://knowyourmeme.com/memes/jeb-wins&#34; target=&#34;_blank&#34;&gt;Jeb wins meme&lt;/a&gt; using sf and ggplot2.&lt;/p&gt;

&lt;h1 id=&#34;epv&#34;&gt;EPV&lt;/h1&gt;

&lt;p&gt;&lt;img src=&#34;https://raw.githubusercontent.com/RobWHickman/EPV/master/hex_sticker/HexSticker2.png&#34; alt=&#34;EPV&#34; /&gt;&lt;/p&gt;

&lt;p&gt;A small package to include code from the my work for the 2019 Statsbomb Conference on Expected Threat Models. To be extended into other Expected Posession Value models when time allows.&lt;/p&gt;

&lt;h1 id=&#34;camstroke&#34;&gt;CamStroke&lt;/h1&gt;

&lt;p&gt;A package to download data related to Cambridge collegiate rowing. Contains cleaned results files for various races and data on the various college boat clubs.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Statsbomb Conference</title>
      <link>/project/statsbomb_conference/</link>
      <pubDate>Thu, 21 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/project/statsbomb_conference/</guid>
      <description>

&lt;p&gt;In August 2019, I won the oppurtunity to present a research talk at the inagural &lt;a href=&#34;https://statsbomb.com/conference/&#34; target=&#34;_blank&#34;&gt;Statsbomb football analytics conference&lt;/a&gt;. My proposal focused on &lt;a href=&#34;https://karun.in/blog/expected-threat.html&#34; target=&#34;_blank&#34;&gt;Markov models&lt;/a&gt; of possession value when playing football, and incorporating a risk factor into these models.&lt;/p&gt;

&lt;p&gt;I presented a 25 minute talk on my work at the conference in October 2019. Below is a list of resources related to the project.&lt;/p&gt;

&lt;h1 id=&#34;original-application&#34;&gt;Original Application&lt;/h1&gt;

&lt;p&gt;&amp;lt; to be added &amp;gt;&lt;/p&gt;

&lt;h1 id=&#34;the-talk&#34;&gt;The Talk&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://www.youtube.com/watch?v=nzaHaWEa9BA&#34; title=&#34;my talk&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;/img/statsbomb_talk.png&#34; alt=&#34;My Statsbomb Talk Video&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&#34;talk-slides&#34;&gt;Talk Slides&lt;/h1&gt;

&lt;p&gt;&amp;lt; to be added &amp;gt;&lt;/p&gt;

&lt;h1 id=&#34;white-paper&#34;&gt;White Paper&lt;/h1&gt;

&lt;p&gt;currently in the process of writing up a white paper based on the research. Will upload here when completed.&lt;/p&gt;

&lt;h1 id=&#34;r-package&#34;&gt;R Package&lt;/h1&gt;

&lt;p&gt;alongside the white paper, I am putting together an R package to easily reproduce the findings, and also extend into other similar models of possession value. The code can be found &lt;a href=&#34;https://github.com/RobWHickman/EPV&#34; target=&#34;_blank&#34;&gt;on Github&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
